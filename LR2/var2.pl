/*
Вариант 2
1. Сортировка списка простой вставкой (по возрастанию).


Алгоритм:
1. Упорядочить хвост Хв списка  L.
2. Вставить голову X списка L в упорядоченный хвост,
поместив ее в такое место, чтобы получившийся список остался упорядоченным.
3. Список отсортирован.

тест:

простаявставка([],L).
L = [].

простаявставка([1],L).
L = [1].

простаявставка([5,6,3],L).
L = [3,5,6].
*/

% простаявставка(+Список, -УпорСписок).
простаявставка([],[]).          % граничный случай, если исходный список - пустой
простаявставка([X],[X]).        % раничный случай, если исходный список состоит их одного элемента

простаявставка([X|Хвост], УпорСписок):- % основной цикл
    простаявставка(Хвост, УпорХвост),   % опорядочить хвост, рекурсивно опускаемся до граничных значений
    вставка(X,УпорХвост,УпорСписок).    % вставить Х в нужное место полученного упорядоченного списка (УпорХвост)


% вставка(+X, +УпорСписок, -УпорСписокНов).

вставка(X,[],[X]).

вставка(X,[Y|УпорСписок], [Y|УпорСписокНов]):-  % Основной цикл, элементы храним в аргументах
    больше(X,Y),!,                              % Условие для продолжения цикла X > Y
    вставка(X,УпорСписок,УпорСписокНов).        % Продолжаем  цикл 

вставка(X,УпорСписок,[X|УпорСписок]).           % если X < Y. вставить X в начало УпорСписок(а) и вернуть его 

/*
тест:

вставка(2,[1,3],L).
L = [1,2,3]

вставка(4,[1],L).   % проверка граничного вараинта
L = [1,4].

*/

% больше(+X, +Y).
больше(X,Y):-
    X > Y.


/*
2. Сортировка списка простым выбором (по возрастанию).

Алгоритм:

1. Найти максимальный элемент неотсортированного списка
2. Добавить его в новый отсортированый список
3. Удалить найденный элемент из неотсортированного списка
4. Повторять п.1. пока не закончится неотсортированный список.

тест:
простойвыбор([],L).
L = [].

простойвыбор([1],L).
L = [1].

простойвыбор([2,1],L).
L = [1,2].

простойвыбор([3,6,4,1],L).
L = [1,3,4,6].

простойвыбор([3,6,4,1,6],L).
L = [1,3,4,6,6].

*/

%   простойвыбор(+Список, -УпорСписок) - по возрастанию.

простойвыбор(Список,[Мин|УпорСписок]):-    % добавить максимальное число (Мин) в упорядоченный список (УпорСписок)
    взятьмин(Список,Мин,НовСписок),       % получить максимальное число (Мин) и вернуть новый неупорядоченный список (НовСписок)
    простойвыбор(НовСписок,УпорСписок).     % в цикле получить (УпорСписок) из неупорядоченного списка (НовСписок)

простойвыбор([],[]).                        % граничное значение. опускаемся в цикле до пустого исходного списка,
                                            % инициируем значение УпорСписок = []




/*
взятьмин(+Список, -Мин, -НовСписок)
ищем минимальное значение в списке, возвращаем:
-Мин - найденное минимальное значение.
-НовСписок - возвратить новый список на основе старого с с удалённым минимальный значением.

тест:
взятьмин([],N,L).
false.

взятьмин([1],N,L).
N = 1.
L = [].

взятьмин([2,1],N,L).
N = 1,
L = [2].

*/
взятьмин([X],X,[]).     % граничный случай + инициализация аргумента - НовСписок

взятьмин([X|Список],Мин1,[X|НовСписок1]):-  % проход в цикле по списку
    взятьмин(Список,Мин1,НовСписок1),       % вычисляем минимальное значение в Мин1
    Мин1 < X.                               % сравниваемвычисленное сничение Мин1 с X. 

взятьмин([X|Список],X,[Мин1|НовСписок]):-   % если X - не является минимальным значением, то добавить его в НовСписок
    взятьмин(Список,Мин1,НовСписок).        % продолжить цикл.

