<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <stylesheet type="text/css">
                                                                                                  section section section title { page-break-before: auto }
  image + p { page-break-before: avoid; margin-bottom: 1em }
  cite { font-style: normal; }
 </stylesheet>
 <description>
  <title-info>
   <genre>comp_programming</genre>
   <author>
    <first-name>Иван</first-name>
    <last-name>Братко</last-name>
   </author>
   <book-title>Программирование на языке Пролог для искусственного интеллекта</book-title>
   <annotation>
    <p>Книга известного специалиста по программированию (Югославия), содержащая основы языка Пролог и его приложения для решения задач искусственного интеллекта. Изложение отличается методическими достоинствами — книга написана в хорошем стиле, живым языком. Книга дополняет имеющуюся на русском языке литературу по языку Пролог.</p>
    <p>Для программистов разной квалификации, специалистов по искусственному интеллекту, для всех изучающих программирование.</p>
   </annotation>
   <date>1990</date>
   <coverpage>
    <image l:href="#_3.jpg"/></coverpage>
   <lang>ru</lang>
   <src-lang>en</src-lang>
   <translator>
    <first-name>А.</first-name>
    <middle-name>И.</middle-name>
    <last-name>Лупенко</last-name>
   </translator>
   <translator>
    <first-name>А.</first-name>
    <middle-name>М.</middle-name>
    <last-name>Степанов</last-name>
   </translator>
  </title-info>
  <src-title-info>
   <genre>comp_programming</genre>
   <author>
    <first-name>Ivan</first-name>
    <last-name>Bratko</last-name>
   </author>
   <book-title>Prolog Programming For Artificial Intelligence</book-title>
   <date>1986</date>
   <lang>en</lang>
  </src-title-info>
  <document-info>
   <author>
    <first-name></first-name>
    <last-name>Неизвестно</last-name>
   </author>
   <program-used>calibre 0.8.21, FictionBook Editor Release 2.6</program-used>
   <date value="2012-04-13">10.10.2011</date>
   <id>e131adf8-79d1-4daf-a8df-4c92d7eadae0</id>
   <version>1.1</version>
   <history>
    <p>1.1 (honorato bonafe) &#8213; description, аннотация, структура, форматирование, оптимизация рисунков</p>
   </history>
  </document-info>
  <publish-info>
   <book-name>Программирование на языке Пролог для искусственного интеллекта</book-name>
   <publisher>Мир</publisher>
   <city>Москва</city>
   <year>1990</year>
   <isbn>5-03-001425-Х</isbn>
  </publish-info>
 </description>
 <body>
  <title>
   <p>Иван Братко </p>
   <p>Программирование на языке Пролог для искусственного интеллекта</p>
  </title>
  <epigraph>
   <p>Посвящается Бранке, Андрею и Тадею</p>
  </epigraph>
  <section>
   <title>
    <p>От редактора перевода</p>
   </title>
   <p>По существующей традиции предисловие редактора перевода — это своего рода рецензия, в которой обычно излагается история вопроса, а затем дается обзор содержания книги и оценка ее качества (как правило, рекламного характера). В данном случае моя задача несколько упрощается, так как все это читатель, перевернув страницу, найдет в предисловии известного американского ученого, специалиста по искусственному интеллекту П. Уинстона, а затем — в предисловии автора. Мне остается только присоединиться к авторитетному мнению П. Уинстона, что перед нами прекрасно написанный учебник до Прологу, ориентированный на практическое использование в области искусственного интеллекта. Добавлю также, что для советского читателя потребность в такой книге особенно велика, поскольку в нашей стране Пролог пока еще не получил того распространения, которого он заслуживает.</p>
   <p>Несколько замечаний относительно особенностей перевода. Кроме обычных терминологических трудностей, как правило возникающих при переводе книг по программированию, переводчикам пришлось преодолевать одну дополнительную сложность. Дело в том, что в Прологе идентификаторы (имена переменных, процедур и атомов) несут на себе значительно большую смысловую нагрузку, чем в традиционных языках программирования. Поэтому программные примеры пришлось излагать на некоей условной русской версии Пролога — в противном случае, для читателей, не владеющих английским языком, эти примеры стали бы значительно менее понятными. Мы оставили без перевода все имена встроенных операторов и процедур, все же остальные имена переводились на русский язык. Следует признать, что в ряде случаев русская версия этих имен оказалась менее эстетически привлекательной, чем исходный английский вариант. Пытаясь наиболее точно передать смысл того или иного имени, переводчик нередко оказывался перед нелегким выбором между громоздким идентификатором (иногда из нескольких слов) и неблагозвучной аббревиатурой. Впрочем, все эти проблемы хорошо известны любому "русскоязычному" программисту.</p>
   <p>Главы 1-8 перевел А.И. Лупенко, а предисловия и главы 9-16 — А.М. Степанов. Подготовку оригинала-макета книги на ЭВМ выполнили А.H. Черных и H.Г. Черных.</p>
   <p>Эту книгу можно рекомендовать как тем читателям, которые впервые приступают к изучению Пролога и искусственного интеллекта, так и программистам, уже имеющим опыт составления пролог-программ.</p>
   <cite>
    <text-author>А. М. Степанов</text-author>
   </cite>
  </section>
  <section>
   <title>
    <p>Предисловие</p>
   </title>
   <p>В средние века знание латинского и греческого языков являлось существенной частью образования любого ученого. Ученый, владеющий только одним языком, неизбежно чувствовал себя неполноценным, поскольку он был лишен той полноты восприятия, которая возникает благодаря возможности посмотреть на мир сразу с двух точек зрения. Таким же неполноценным ощущает себя сегодняшний исследователь в области искусственного интеллекта, если он не обладает основательным знакомством как с Лиспом, так и с Прологом — с этими двумя основополагающими языками искусственного интеллекта, без знания которых невозможен более широкий взгляд на предмет исследования.</p>
   <p>Сам я приверженец Лиспа, так как воспитывался в Массачусетском технологическом институте, где этот язык был изобретен. Тем не менее, я никогда не забуду того волнения, которое я испытал, увидев в действии свою первую программу, написанную в прологовском стиле. Эта программа была частью знаменитой системы Shrdlu Терри Винограда. Решатель задач, встроенный в систему, работал в "мире кубиков" и заставлял руку робота (точнее, ее модель) перемещать кубики на экране дисплея, решая при этом хитроумные задачи, поставленные оператором.</p>
   <p>Решатель задач Винограда был написан на Микропленнере, языке, который, как мы теперь понимаем, был своего рода Прологом в миниатюре. Любой прологоподобный язык заставляет программиста мыслить в терминах целей, поэтому, несмотря на все недостатки Микропленнера, достоинством этой программы было то, что в ее структуре содержались многочисленные явные указания на те или иные цели. Процедуры-цели "схватить", "освободить", "избавиться", "переместить", "отпустить" и т.п. делали программу простой и компактной, а поведение ее казалось поразительно разумным.</p>
   <p>Решатель задач Винограда навсегда изменил мое программистское мышление. Я даже переписал его на Лиспе и привел в своем учебнике по Лиспу в качестве примера — настолько эта программа всегда поражала меня мощью заложенной в ней философии "целевого" программирования, да и само программирование в терминах целей всегда доставляло мне удовольствие.</p>
   <p>Однако учиться целевому программированию на примерах лисповских программ — это все равно, что читать Шекспира на языке, отличном от английского. Какое-то впечатление вы получите, но сила эстетического воздействия будет меньшей, чем при чтении оригинала. Аналогично этому, лучший способ научиться целевому программированию — это читать и писать программы на Прологе, поскольку сама сущность Пролога как раз и состоит в программировании в терминах целей.</p>
   <p>В самом широком смысле слова эволюция языков программирования — это движение от языков низкого уровня, пользуясь которыми, программист описывает, <emphasis>как</emphasis> что-либо следует делать, к языкам высокого уровня, на которых просто указывается, <emphasis>что</emphasis> необходимо сделать. Так, например, появление Фортрана освободило программистов от необходимости разговаривать с машиной на прокрустовом языке адресов и регистров. Теперь они уже могли говорить на своем (или почти на своем) языке, только изредка делая уступки примитивному миру 80-колонных перфокарт.</p>
   <p>Однако Фортран и почти все другие языки программирования все еще остаются языками типа "как". И чемпионом среди этих языков является, пожалуй, современный модернизированный Лисп. Так, скажем, Common Lisp, имея богатейшие выразительные возможности, разрешает программисту описывать наиболее "выразительно" именно то, <emphasis>как</emphasis> что-либо следует делать. В то же время очевидно, что Пролог порывает с традициями языков типа "как", поскольку он определенным образом направляет программистское мышление, заставляя программиста давать определения ситуаций и формулировать задачи вместо того, чтобы во всех деталях описывать способ решения этих задач.</p>
   <p>Отсюда следует, насколько важен вводный курс по Прологу для всех студентов, изучающих вычислительную технику и программирование — просто не существует лучшего способа понять, что из себя представляет программирование типа "что".</p>
   <p>Многие страницы этой книги могут служить хорошей иллюстрацией того различия, которое существует между этими двумя стилями программистского мышления. Например, в первой главе это различие иллюстрируется на задачах, относящихся к семейным отношениям. Прологовский программист дает простое и естественное описание понятия "дедушка": дедушка — это отец родителя. На Прологе это выглядит так:</p>
   <p><code>дедушка( X, Z) :- отец( X, Y), родитель( Y, Z).</code></p>
   <p>Как только пролог-система узнала, что такое дедушка, ей можно задать вопрос, например: кто является дедушкой Патрика? В обозначениях Пролога этот вопрос и типичный ответ имеют вид:</p>
   <p><code>?-  дедушка( X, патрик).</code></p>
   <p><code>X = джеймс;</code></p>
   <empty-line/>
   <p><code>X = карл.</code></p>
   <p>Каким образом решать эту задачу, как "прочесывать" базу данных, в которой записаны все известные отношения "отец" и "родитель", — это уже забота самой пролог-системы. Программист только сообщает системе то, что ему известно, и задает вопросы. Его в большей степени интересуют знания и в меньшей — алгоритмы, при помощи которых из этих знаний извлекается нужная информация.</p>
   <p>Поняв, что очень важно научиться Прологу, естественно задать себе следующий вопрос — как это сделать. Я убежден, что изучение языка программирования во многом сходно с изучением естественного языка. Так, например, в первом случае может пригодиться инструкция по программированию точно так же, как во втором — словарь. Но никто не изучает язык при помощи словаря, так как слова — это только часть знаний, необходимых для овладения языком. Изучающий язык должен кроме того узнать те соглашения, следуя которым, можно получать осмысленные сочетания слов, а затем научиться у мастеров слова искусству литературного стиля.</p>
   <p>Точно так же, никто не изучает язык программирования, пользуясь только инструкцией по программированию, так как в инструкциях очень мало или вообще ничего не говорится о том, как хорошие программисты используют элементарные конструкции языка. Поэтому необходим учебник, причем лучшие учебники обычно предлагают читателю богатый набор примеров. Ведь в хороших примерах сконцентрирован опыт лучших программистов, а именно на опыте мы, в основном, и учимся.</p>
   <p>В этой книге первый пример появляется уже на первой странице, а далее на читателя как из рога изобилия обрушивается поток примеров прологовских программ, написанных программистом-энтузиастом, горячим приверженцем прологовской идеологии программирования. После тщательного изучения этих примеров читатель не только узнает, как "работает" Пролог, но и станет обладателем личной коллекции программ-прецедентов, готовых к употреблению: он может разбирать эти программы на части, приспосабливать каждую часть к своей задаче, а затем снова собирать их вместе, получая при этом новые программы. Такое усвоение предшествующего опыта можно считать первым шагом на пути от новичка к программисту-мастеру.</p>
   <p>Изучение хороших программных примеров дает, как правило, один полезный побочный эффект: мы узнаем из них не только очень многое о самом программировании, но и кое-что - о какой-нибудь интересной научной области. В данной книге такой научной областью, стоящей за большинством примеров, является искусственный интеллект. Читатель узнает о таких идеях в области автоматического решения задач, как сведение задач к подзадачам, прямое и обратное построение цепочки рассуждений, ответы на вопросы "как" и "почему", а также разнообразные методы поиска.</p>
   <p>Одним из замечательных свойств Пролога является то, что это достаточно простой язык, и студенты могли бы использовать его непосредственно в процессе изучения вводного курса по искусственному интеллекту. Я не сомневаюсь, что многие преподаватели включат эту книгу в свои курсы искусственного интеллекта с тем, чтобы студенты смогли увидеть, как при помощи Пролога абстрактные идеи приобретают конкретные и действенные формы.</p>
   <p>Полагаю, что среди учебников по Прологу эта книга окажется особенно популярной, и не только из-за своих хороших примеров, но также из-за целого ряда других своих привлекательных черт:</p>
   <p>• тщательно составленные резюме появляются на всем протяжении книги;</p>
   <p>• все вводимые понятия подкрепляются многочисленными упражнениями;</p>
   <p>• процедуры выборки элементов структур подводят нас к понятию абстракции данных;</p>
   <p>• обсуждение вопросов стиля и методологии программирования занимает целую главу;</p>
   <p>• автор не только показывает приятные свойства языка, но и со всей откровенностью обращает наше внимание на трудные проблемы, возникающие при программировании на Прологе.</p>
   <p>Все это говорит о том, что перед нами прекрасно написанная, увлекательная и полезная книга.</p>
   <cite>
    <text-author>Патрик Г. Уинстон</text-author>
    <text-author>Кеймбридж, Массачусетс </text-author>
   </cite>
  </section>
  <section>
   <title>
    <p>Предисловие автора </p>
   </title>
   <p>Язык программирования Пролог базируется на ограниченном наборе механизмов, включающих в себя сопоставление образцов, древовидное представление структур данных и автоматический возврат. Этот небольшой набор образует удивительно мощный и гибкий программный аппарат. Пролог особенно хорошо приспособлен для решения задач, в которых фигурируют объекты (в частности, структуры) и отношения между ними. Например, в качестве легкого упражнения, можно попробовать выразить на Прологе пространственные отношения между объектами, изображенными на обложке этой книги. Пример такого отношения: верхний шар расположен дальше, чем левый шар. Нетрудно также сформулировать и более общее положение в виде следующего правила: если X ближе к наблюдателю, чем Y, a Y — ближе, чем Z, то объект X находится ближе, чем Z. Пользуясь правилами и фактами, пролог-система может проводить рассуждения относительно имеющихся пространственных отношений и, в частности, проверить, насколько они согласуются с вышеуказанным общим правилом. Все эти возможности придают Прологу черты мощного языка для решения задач искусственного интеллекта, а также любых задач, требующих нечислового программирования.</p>
   <p>Само название <emphasis>Пролог</emphasis> есть сокращение, означающее <emphasis>программирование в терминах логики</emphasis>. Идея использовать логику в качестве языка программирования возникла впервые в начале 70-x годов. Первыми исследователями, разрабатывавшими эту идею, были Роберт Ковальский из Эдинбурга (теоретические аспекты), Маартен ван Эмден из Эдинбурга (экспериментальная демонстрационная система) и Ален Колмероэ из Марселя (реализация). Сегодняшней своей популярности Пролог во многом обязан эффективной реализации этого языка, полученной в Эдинбурге Дэвидом Уорреном в середине 70-x годов.</p>
   <p>Поскольку Пролог уходит своими корнями в математическую логику, его преподавание часто начинают с изложения логики. Однако такое введение в Пролог, насыщенное математическими понятиями, приносит мало пользы в том случае, когда Пролог изучается в качестве практического инструмента программирования. Поэтому в данной книге мы не будем заниматься математическими аспектами этого языка, вместо этого мы сосредоточим свое внимание на навыках использования базовых механизмов Пролога, для решения целого ряда содержательных задач. В то время, как традиционные языки программирования являются процедурно-ориентированными, Пролог основан на описательной или <emphasis>декларативной</emphasis> точке зрения на программирование. Это свойство Пролога коренным образом меняет программистское мышление и делает обучение программированию на Прологе увлекательным занятием, требующим определенных интеллектуальных усилий.</p>
   <p>В первой части книги содержится введение в Пролог, в ней показано, как составлять программы на Прологе. Во второй части демонстрируется, как мощные средства языка применяются в некоторых областях искусственного интеллекта, таких как, например, решение задач, эвристический поиск, экспертные системы, машинные игры и системы, управляемые образцами. В этой части излагаются фундаментальные методы в области искусственного интеллекта. Далее они прорабатываются достаточно глубоко для того, чтобы реализовать их на Прологе и получить готовые программы. Эти программы можно использовать в качестве "кирпичиков" для построения сложных прикладных систем. В книге рассматриваются также вопросы обработки таких сложных структур данных, как графы и деревья, хотя эти вопросы, строго говоря, и не имеют прямого отношения к искусственному интеллекту. В программах искусственного интеллекта методы обработки структур применяются довольно часто, и, реализуя их, читатель приобретет самые общие навыки программирования на Прологе. В книге особое внимание уделяется простоте и ясности составляемых программ. Повсеместно мы стремились избегать программистских "хитростей", повышающих эффективность за счет учета особенностей конкретной реализации Пролога.</p>
   <p>Эта книга предназначена для тех, кто изучает Пролог и искусственный интеллект. Материал книги можно использовать в курсе лекций по искусственному интеллекту, ориентированном на прологовскую реализацию. Предполагается, что читатель имеет общее представление о вычислительных машинах, но предварительные знания в области искусственного интеллекта необязательны. От читателя не требуется также какого-либо программистского опыта. Дело в том, что богатый программистский опыт вместе с приверженностью к традиционному процедурному программированию (например, на Паскале) может стать помехой при изучении Пролога, требующего свежего программистского мышления.</p>
   <p>Среди различных диалектов Пролога наиболее широко распространен так называемый эдинбургский синтаксис (или синтаксис DEC-10), который мы я принимаем в данной книге. Для того, чтобы обеспечить совместимость с различными реализациями Пролога, мы используем в книге сравнительно небольшое подмножество встроенных средств, имеющихся во многих вариантах Пролога.</p>
   <p>Как читать эту книгу? В первой части порядок чтения естественным образом совпадает с порядком изложения, принятым в книге. Впрочем, часть разд. 2.4, в которой дается более формальное описание процедурной семантики Пролога, можно опустить. В главе 4 приводятся примеры программ, которые можно читать только выборочно. Вторая часть книги допускает более гибкий порядок чтения, поскольку различные главы этой части предполагаются взаимно независимыми. Однако некоторые из тем было бы естественным прочесть раньше других - это относится к основным понятиям, связанным со структурами данных (гл. 9), и к базовым стратегиям поиска (гл. 11 и 13). В приведенной ниже диаграмме показана наиболее естественная последовательность чтения глав.</p>
   <p><image l:href="#_4.png"/></p>
   <p>Существует целый ряд исторически сложившихся и противоречащих друг другу взглядов на Пролог. Пролог быстро завоевал популярность в Европе как практический инструмент программирования. В Японии Пролог оказался в центре разработки компьютеров пятого поколения. С другой стороны, в связи с определенными историческими факторами, в США Пролог получил признание несколько позднее. Один из этих факторов был связан с предварительным знакомством с Микропленнером, языком, близким к логическому программированию, но реализованным не эффективно. Этот отрицательный опыт, относящийся к Микропленнеру, был неоправданно распространен и на Пролог, но позднее, после появления эффективной реализации, предложенной Дэвидом Уорреном, это предубеждение было убедительно снято. Определенная сдержанность по отношению к Прологу объяснялась также существованием "ортодоксальной школы" логического программирования, сторонники которой настаивали на использовании чистой логики, не запятнанной добавлением практически полезных внелогических средств. Практикам в области применения Пролога удалось изменить эту бескомпромиссную позицию и принять более прагматический подход, позволивший удачно сочетать декларативный принцип с традиционным - процедурным. И наконец, третьим фактором, приведшим к задержке признания Пролога, явилось то обстоятельство, что в США в течение долгого времени Лисп не имел серьезных конкурентов среди языков искусственного интеллекта. Понятно поэтому, что в исследовательских центрах с сильными лисповскими традициями возникало естественное противодействие Прологу. Но со временем соперничество между Прологом и Лиспом потеряло свою остроту, и в настоящее время многие считают, что оптимальный подход состоит в сочетании идей, лежащих в основе этих двух языков.</p>
   <subtitle>Благодарности</subtitle>
   <p>Интерес к Прологу впервые возник у меня под влиянием Дональда Мики. Я благодарен также Лоренсу Берду, Фернандо Перейра и Дэвиду Г. Уоррену, входившим в свое время в эдинбургскую группу разработчиков Пролога, за их советы по составлению программ и многочисленные дискуссии. Чрезвычайно полезными были замечания и предложения, высказанные Эндрью Макгеттриком и Патриком Уинстоном. Среди прочитавших рукопись книги и сделавших ценные замечания были также Игорь Кононенко, Таня Маярон, Игорь Мозетик, Тимоти Ниблетт и Фрэнк Зердин. Мне бы хотелось также поблагодарить Дебру Майсон-Этерингтон и Саймона Пламтри из издательства Эддисон-Уэсли за труд, вложенный в издание этой книги. И наконец, эта книга не могла бы появиться на свет без стимулирующего влияния творческой деятельности всего международного сообщества специалистов по логическому программированию.</p>
   <cite>
    <text-author>Иван Братко</text-author>
    <text-author>Институт Тьюринга, Глазго</text-author>
    <text-author>Январь 1986 </text-author>
   </cite>
  </section>
  <section>
   <title>
    <p>Часть 1</p>
    <p>Язык Пролог</p>
   </title>
   <image l:href="#_5.png"/>
   <section>
    <title>
     <p>Глава 1</p>
     <p>Общий обзор языка Пролог</p>
    </title>
    <section>
     <p>В этой главе на примере конкретной программы рассматриваются основные механизмы Пролога. Несмотря на то, что материал излагается в основном неформально, здесь вводятся многие важные понятия.</p>
    </section>
    <section>
     <title>
      <p>1.1. Пример программы: родственные отношения</p>
     </title>
     <p>Пролог — это язык программирования, предназначенный для обработки символьной нечисловой информации. Особенно хорошо он приспособлен для решения задач, в которых фигурируют объекты и отношения между ними. На рис. 1.1 представлен пример — родственные отношения. Тот факт, что Том является родителем Боба, можно записать на Прологе так:</p>
     <p><code>родитель( том, боб).</code></p>
     <p>Здесь мы выбрали <code>родитель</code> в качестве имени отношения, <code>том</code> и <code>боб</code> — в качестве аргументов этого отношения. По причинам, которые станут понятны позднее, мы записываем такие имена, как <code>том</code>, начиная со строчной буквы. Все дерево родственных отношений рис. 1.1 описывается следующей пролог-программой:</p>
     <p><code>родитель( пам, боб).</code></p>
     <p><code>родитель( том, боб).</code></p>
     <p><code>родитель( том, лиз).</code></p>
     <p><code>родитель( боб, энн).</code></p>
     <p><code>родитель( боб, пат).</code></p>
     <p><code>родитель( пам, джим).</code></p>
     <image l:href="#_6.png"/>
     <p><strong>Рис. 1.1.</strong>  Дерево родственных отношений.</p>
     <p>Эта программа содержит шесть <emphasis>предложений</emphasis>. Каждое предложение объявляет об одном факте наличия отношения <code>родитель</code>.</p>
     <p>После ввода такой программы в пролог-систему последней можно будет задавать вопросы, касающиеся отношения <strong><code><strong>родитель</strong></code></strong>. Например, является ли Боб родителем Пат? Этот вопрос можно передать пролог-системе, набрав на клавиатуре терминала:</p>
     <p><code>?-  родитель( боб, пат).</code></p>
     <p>Найдя этот факт в программе, система ответит</p>
     <p><code>yes        </code> (да)</p>
     <p>Другим вопросом мог бы быть такой:</p>
     <p><code>?-  родитель( лиз, пат).</code></p>
     <p>Система ответит</p>
     <p><code>no            </code> (нет),</p>
     <p>поскольку в программе ничего не говорится о том, является ли Лиз родителем Пат. Программа ответит "нет" и на вопрос</p>
     <p><code>?-  родитель( том, бен).</code></p>
     <p>потому, что имя Бен в программе даже не упоминается.</p>
     <p>Можно задавать и более интересные вопросы. Например:"Кто является родителем Лиз?"</p>
     <p><code>?-  родитель( X, лиз).</code></p>
     <p>На этот раз система ответит не просто "да" или "нет". Она скажет нам, каким должно быть значение <code>X</code> (ранее неизвестное), чтобы вышеприведенное утверждение было истинным. Поэтому мы получим ответ:</p>
     <p><code>X  =  том</code></p>
     <p>Вопрос "Кто дети Боба?" можно передать пролог-системе в такой форме:</p>
     <p><code>?-  родитель( боб, X).</code></p>
     <p>В этом случае возможно несколько ответов. Сначала система сообщит первое решение:</p>
     <p><code>X  =  энн</code></p>
     <p>Возможно, мы захотим увидеть и другие решения. О нашем желании мы можем сообщить системе (во многих реализациях для этого надо набрать точку с запятой), и она найдет другой ответ:</p>
     <p><code>X  =  пат</code></p>
     <p>Если мы потребуем дальнейших решений, система ответит "нет", поскольку все решения исчерпаны.</p>
     <p>Нашей программе можно задавать и более общие вопросы: "Кто чей родитель?" Приведем другую формулировку этого вопроса:</p>
     <p>Найти X и Y такие, что X — родитель Y.</p>
     <p>На Прологе это записывается так:</p>
     <p><code>?-  родитель( X, Y).</code></p>
     <p>Система будет по очереди находить все пары вида "родитель-ребенок". По мере того, как мы будем требовать от системы новых решений, они будут выводиться на экран одно за другим до тех пор, пока все они не будут найдены. Ответы выводятся следующим образом:</p>
     <p><code>X  =  пам</code></p>
     <p><code>Y  =  боб;</code></p>
     <empty-line/>
     <p><code>X  =  том</code></p>
     <p><code>Y  =  боб;</code></p>
     <empty-line/>
     <p><code>X  =  том</code></p>
     <p><code>Y  =  лиз;</code></p>
     <p><code>...</code></p>
     <p>Мы можем остановить поток решений, набрав, например, точку вместо точки с запятой (выбор конкретного символа зависит от реализации).</p>
     <p>Нашей программе можно задавать и еще более сложные вопросы, скажем, кто является родителем родителя Джима? Поскольку в нашей программе прямо не сказано, что представляет собой отношение <code>родительродителя</code>, такой вопрос следует задавать в два этапа, как это показано на рис. 1.2.</p>
     <p>(1)    Кто родитель Джима?   Предположим, что это некоторый Y.</p>
     <p>(2)    Кто родитель Y?   Предположим, что это некоторый X.</p>
     <p>Такой составной вопрос на Прологе записывается в виде последовательности двух простых вопросов:</p>
     <p><code>?-  родитель( Y, джим), родитель( X, Y).</code></p>
     <p>Ответ будет:</p>
     <p><code>X  =  боб</code></p>
     <p><code>Y  =  пат</code></p>
     <empty-line/>
     <image l:href="#_7.png"/>
     <p><strong>Рис. 1.2.</strong> Отношение <code>родительродителя</code>, выраженное через композицию двух отношений <code>родитель</code>.</p>
     <p>Наш составной вопрос можно интерпретировать и так: "Найти X и Y, удовлетворяющие следующим двум требованиям":</p>
     <p><code>родитель( Y, джим) </code>и <code>родитель( X, Y)</code></p>
     <p>Если мы поменяем порядок этих двух требований, то логический смысл останется прежним:</p>
     <p><code>родитель( X, Y)</code> и <code>родитель( Y, джим)</code></p>
     <p>Этот вопрос можно задать нашей пролог-системе и в такой форме:</p>
     <p><code>?-  родитель( X, Y), родитель( Y, джим).</code></p>
     <p>При этом результат будет тем же. Таким же образом можно спросить: "Кто внуки Тома?"</p>
     <p><code>?-  родитель( том, X), родитель( X, Y).</code></p>
     <p>Система ответит так:</p>
     <p><code>X  =  боб</code></p>
     <p><code>Y  =  энн;</code></p>
     <empty-line/>
     <p><code>X  =  боб</code></p>
     <p><code>Y  =  пат</code></p>
     <p>Следующим вопросом мог бы быть такой: "Есть ли у Энн и Пат общий родитель?" Его тоже можно выразить в два этапа:</p>
     <p>(1)    Какой X является родителем Энн?</p>
     <p>(2)    Является ли (тот же) X родителем Пат?</p>
     <p>Соответствующий запрос к пролог-системе будет тогда выглядеть так:</p>
     <p><code>?-  родитель( X, энн), родитель( X, пат).</code></p>
     <p>Ответ:</p>
     <p><code>X  =  боб</code></p>
     <p>Наша программа-пример помогла проиллюстрировать некоторые важные моменты:</p>
     <p>• На Прологе легко определить отношение, подобное отношению <code>родитель</code>, указав <emphasis>n</emphasis>-ку объектов, для которых это отношение выполняется.</p>
     <p>• Пользователь может легко задавать пролог-системе вопросы, касающиеся отношений, определенных в программе.</p>
     <p>• Пролог-программа состоит из предложений. Каждое предложение заканчивается точкой.</p>
     <p>• Аргументы отношения могут быть (среди прочего): конкретными объектами, или константами (такими, как <code>том</code> и <code>энн</code>), или абстрактными объектами, такими, как <code>X </code>и <code>Y</code>. Объекты первого типа называются <emphasis>атомами</emphasis>. Объекты второго типа — <emphasis>переменными</emphasis>.</p>
     <p>• Вопросы к системе состоят из одного или более целевых утверждений (или кратко <emphasis>целей</emphasis>). Последовательность целей, такая как</p>
     <p><code>родитель( X, энн), родитель( X, пат)</code></p>
     <p>означает конъюнкцию этих целевых утверждений:</p>
     <p>X  —  родитель Энн <emphasis>  и</emphasis></p>
     <p>X  —  родитель Пат.</p>
     <p>Пролог-система рассматривает вопросы как цели, к достижению которых нужно стремиться.</p>
     <p>• Ответ на вопрос может оказаться или положительным или отрицательным в зависимости от того, может ли быть соответствующая цель достигнута или нет. В случае положительного ответа мы говорим, что соответствующая цель <emphasis>достижима</emphasis> и <emphasis>успешна</emphasis>. В противном случае цель <emphasis>  недостижима</emphasis>, <emphasis>  имеет неуспех</emphasis>   или   <emphasis>терпит неудачу</emphasis>.</p>
     <p>• Если на вопрос существует несколько ответов, пролог-система найдет столько из них, сколько пожелает пользователь.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>1.1.</strong> Считая, что отношение <code>родитель</code> определено так же, как и раньше в данном разделе (см. рис. 1.1), найдите, какими будут ответы пролог-системы на следующие вопросы:</p>
     <p>(a)  <code>?-  родитель( джим, X).</code></p>
     <p>(b)  <code>?-  родитель( X, джим).</code></p>
     <p>(c)  <code>?-  родитель( пам,X), родитель( X, пат).</code></p>
     <p>(d)  <code>?-  родитель( пам, X), родитель( X, Y),</code></p>
     <p><code>       родитель( Y, джим).</code></p>
     <p><strong>1.2.</strong>  Сформулируйте на Прологе следующие вопросы об отношении <code>родитель</code>:</p>
     <p>(a)  Кто родитель Пат?</p>
     <p>(b)  Есть ли у Лиз ребенок?</p>
     <p>(c)  Кто является родителем родителя Пат? </p>
    </section>
    <section>
     <title>
      <p>1.2. Расширение программы-примера с помощью правил</p>
     </title>
     <p>Нашу программу-пример можно легко расширить многими интересными способами. Давайте сперва добавим информацию о том, каков пол людей, участвующих в отношении <code>родитель</code>. Это можно сделать, просто добавив в нее следующие факты:</p>
     <p><code>женщина( пам).</code></p>
     <p><code>мужчина( том).</code></p>
     <p><code>мужчина( боб).</code></p>
     <p><code>женщина( лиз).</code></p>
     <p><code>женщина( пат).</code></p>
     <p><code>женщина( энн).</code></p>
     <p><code>мужчина( джим).</code></p>
     <p>Мы ввели здесь два новых отношения — <code>мужчина</code> и <code>женщина</code>. Эти отношения — унарные (или одноместные). Бинарное отношение, такое как <code>родитель</code>, определяет отношение между <emphasis>двумя</emphasis> объектами; унарные же можно использовать для объявления наличия (отсутствия) простых свойств у объектов. Первое из приведенных выше предложений читается так: Пам — женщина. Можно было бы выразить информацию, представляемую этими двумя унарными отношениями (<code>мужчина</code> и <code>женщина</code>), по-другому - с помощью одного бинарного отношения <code>пол</code>. Тогда новый фрагмент нашей программы выглядел бы так:</p>
     <p><code>пол( пам, женский).</code></p>
     <p><code>пол( том, мужской).</code></p>
     <p><code>пол( боб, мужской).</code></p>
     <p><code>...</code></p>
     <p>В качестве дальнейшего расширения нашей программы-примера давайте введем отношение <code>отпрыск</code>, которое обратно отношению <code>родитель</code>. Можно было бы определить <code>отпрыск</code> тем же способом, что и <code>родитель</code>, т.е. представив список простых фактов наличия этого отношения для конкретных пар объектов, таких, что один является отпрыском другого. Например:</p>
     <p><code>отпрыск( лиз, том).</code></p>
     <p>Однако это отношение можно определить значительно элегантнее, использовав тот факт, что оно обратно отношению <code>родитель</code>, которое уже определено. Такой альтернативный способ основывается на следующем логическом утверждении:</p>
     <p>Для всех X и Y</p>
     <p> Y является отпрыском X, если</p>
     <p> X является родителем Y.</p>
     <p>Эта формулировка уже близка к формализму, принятому в Прологе. Вот соответствующее прологовское предложение, имеющее тот же смысл:</p>
     <p><code>отпрыск( Y, X) :- родитель( X, Y).</code></p>
     <p>Это предложение можно прочитать еще и так:</p>
     <p>Для всех X и Y,</p>
     <p>  если X — родитель Y, то</p>
     <p>  Y — отпрыск X.</p>
     <p>Такие предложения Пролога, как</p>
     <p><code>отпрыск( Y, X) :- родитель( X, Y).</code></p>
     <p>называются <emphasis>правилами</emphasis>. Есть существенное различие между фактами и правилами. Факт, подобный факту</p>
     <p><code>родитель( том, лиз).</code></p>
     <p>это нечто такое, что всегда, безусловно истинно. Напротив, правила описывают утверждения, которые могут быть истинными, только если выполнено некоторое условие. Поэтому можно сказать, что правила имеют</p>
     <p>• условную часть (правая половина правила) и</p>
     <p>• часть вывода (левая половина правила).</p>
     <p>Вывод называют также <emphasis>головой</emphasis> предложения, а условную часть — его <emphasis>телом</emphasis>. Например:</p>
     <p><code>отпрыск( Y, X) :- родитель( X, Y).</code></p>
     <p><code><emphasis>голова            тело</emphasis></code></p>
     <p>Если условие <code>родитель( X, Y)</code> выполняется (оно истинно), то логическим следствием из него является утверждение <code>отпрыск( Y, X)</code>.</p>
     <p>На приведенном ниже примере проследим, как в действительности правила используются Прологом. Спросим нашу программу, является ли Лиз отпрыском Тома:</p>
     <p><code>?- отпрыск( лиз, том).</code></p>
     <p>В программе нет фактов об отпрысках, поэтому единственный способ ответить на такой вопрос — это применить правило о них. Правило универсально в том смысле, что оно применимо к любым объектам X и Y, следовательно, его можно применить и к таким конкретным объектам, как <code>лиз</code> и <code>том</code>. Чтобы это сделать, нужно вместо <code>Y</code> подставить в него <code>лиз</code>, а вместо <code>X</code> — <code>том</code>. В этом случае мы будем говорить, что переменные X и Y конкретизируются:</p>
     <p><code>X = том</code> и <code>Y = лиз</code></p>
     <p>После конкретизации мы получаем частный случай нашего общего правила. Вот он:</p>
     <p><code>отпрыск( лиз, том) :- родитель( том, лиз).</code></p>
     <p>Условная часть приняла вид:</p>
     <p><code>родитель( том, лиз)</code></p>
     <p>Теперь пролог-система попытается выяснить, выполняется ли это условие (является ли оно истинным). Для этого исходная цель</p>
     <p><code>отпрыск( лиз, том)</code></p>
     <p>заменяется подцелью</p>
     <p><code>родитель( том, лиз)</code></p>
     <p>Эта (новая) цель достигается тривиально, поскольку такой факт можно найти в нашей программе. Это означает, что утверждение, содержащееся в выводе правила, также истинно, и система ответит на вопрос <code>yes</code> (да).</p>
     <p>Добавим теперь в нашу программу-пример еще несколько родственных отношений. Определение отношения <code>мать</code> может быть основано на следующем логическом утверждении:</p>
     <p>Для всех X и Y</p>
     <p>  X является матерью Y, если</p>
     <p>  X является родителем Y и</p>
     <p>  X — женщина.</p>
     <p>На Пролог это переводится в виде такого правила:</p>
     <p><code>мать( X, Y) :- родитель( X, Y), женщина( X).</code></p>
     <p>Запятая между двумя условиями указывает на конъюнкцию условий. Это означает, что они должны быть выполнены оба одновременно.</p>
     <image l:href="#_8.png"/>
     <p><strong>Рис. 1.3.</strong>  Графы отношений <code>родительродителя</code>, <code>мать</code> и <code>отпрыск</code>, определенных через другие отношения.</p>
     <p>Такие отношения как <code>родитель</code>, <code>отпрыск</code> и <code>мать</code> можно изобразить в виде диаграмм, приведенных на рис. 1.3. Они нарисованы с учетом следующих соглашений. Вершины графа соответствуют объектам, т.е. аргументам отношений. Дуги между вершинами соответствуют бинарным (двуместным) отношениям. Дуги направлены от первого аргумента к второму. Унарные отношения на диаграмме изображаются просто пометкой соответствующих объектов именем отношения. Отношения, определяемые через другие отношения, представлены штриховыми дугами. Таким образом, любую диаграмму следует понимать так: если выполнены отношения, изображенные сплошными дугами, тогда и отношение, изображенное штриховой дугой, тоже выполнено. В соответствии с рис. 1.3, отношение <code>родительродителя</code> можно сразу записать на Прологе:</p>
     <p><code>родительродителя( X, Z) :- родитель( X, Y),</code></p>
     <p><code>                           родитель( Y, Z).</code></p>
     <p>Здесь уместно сделать несколько замечаний о внешнем виде нашей программы. Пролог дает почти полную свободу расположения текста на листе. Так что можно вставлять пробелы и переходить к новой строке в любом месте текста по вкусу. Вообще мы хотим сделать так, чтобы наша программа имела красивый и аккуратный вид, а самое главное, легко читалась. Для этого мы часто будем помещать голову предложения и каждую цель на отдельной строке. При этом цели мы будем писать с отступом, чтобы сделать разницу между головой и целями более заметной. Например, правило <code>родительродителя</code> в соответствии с этими соглашениями запишется так:</p>
     <p><code>родительродителя( X, Z) :-</code></p>
     <p><code> родитель( X, Y),</code></p>
     <p><code> родитель( Y, Z).</code></p>
     <p>На рис. 1.4 показано отношение <code>сестра</code>:</p>
     <p>Для любых X и Y</p>
     <p>  X является сестрой Y, если</p>
     <p>  (1)  у X и Y есть общий родитель, и</p>
     <p>  (2)  X — женщина.</p>
     <image l:href="#_5.png"/>
     <p><strong>Рис. 1.4.</strong> Определение отношения <code>сестра</code>.</p>
     <p>Граф на рис. 1.4 можно перевести на Пролог так:</p>
     <p><code>сестра( X, Y) :-</code></p>
     <p><code> родитель( Z, X),</code></p>
     <p><code> родитель( Z, Y),</code></p>
     <p><code> женщина( X).</code></p>
     <p>Обратите внимание на способ, с помощью которого выражается требование "у X и Y есть общий родитель". Была использована следующая логическая формулировка: "некоторый Z должен быть родителем X и <emphasis>этот же самый</emphasis> Z должен быть родителем Y". По-другому, менее красиво, можно было бы сказать так: "Z1 - родитель X, Z2 - родитель Y и Z1 равен Z2".</p>
     <p>Теперь можно спросить:</p>
     <p><code>?- сестра( энн, пат).</code></p>
     <p>Как и ожидается, ответ будет "<code>yes</code>" (да) (см. рис. 1.1). Мы могли бы заключить отсюда, что определенное нами отношение <code>сестра</code> работает правильно. Тем не менее в нашей программе есть маленькое упущение, которое обнаружится, если задать вопрос: "Кто является сестрой Пат?"</p>
     <p><code>?-  сестра( X, пат).</code></p>
     <p>Система найдет два ответа, один из которых может показаться неожиданным:</p>
     <p><code>X = энн;</code></p>
     <p><code>X = пат</code></p>
     <p>Получается, что Пат — сестра себе самой?! Наверное, когда мы определяли отношение <code>сестра</code>, мы не имели этого ввиду. Однако ответ Пролога совершенно логичен, поскольку он руководствовался нашим правилом, а это правило ничего не говорит о том, что, если X — сестра Y, то X и Y не должны совпадать. Пролог (с полным правом) считает, что X и Y могут быть одним и тем же объектом и в качестве следствия из этого делает вывод, что любая женщина, имеющая родителя, является сестрой самой себе.</p>
     <p>Чтобы исправить наше правило о сестрах, его нужно дополнить утверждением, что X и Y должны различаться. В следующих главах мы увидим, как это можно сделать, в данный же момент мы предположим, что отношение <code>различны</code> уже известно пролог-системе и что цель</p>
     <p><code>различны( X, Y)</code></p>
     <p>достигается тогда и только тогда, когда X и Y не равны. Усовершенствованное правило для отношения <code>сестра</code> примет тогда следующий вид:</p>
     <p><code>сестра( X, Y) :-</code></p>
     <p><code> родитель( Z, X),</code></p>
     <p><code> родители( Z, Y),</code></p>
     <p><code> женщина( X),</code></p>
     <p><code> различны( X, Y).</code></p>
     <p>Некоторые важные моменты этого раздела:</p>
     <p>• Пролог-программы можно расширять, добавляя в них новые предложения.</p>
     <p>• Прологовские предложения бывают трех типов: <emphasis>факты</emphasis>, <emphasis>правила </emphasis>и <emphasis>вопросы</emphasis>.</p>
     <p>• <emphasis>Факты</emphasis> содержат утверждения, которые являются всегда, безусловно верными.</p>
     <p>• <emphasis>Правила</emphasis> содержат утверждения, истинность которых зависит от некоторых условий.</p>
     <p>• С помощью <emphasis>вопросов</emphasis> пользователь может спрашивать систему о том, какие утверждения являются истинными.</p>
     <p>• Предложения Пролога состоят из <emphasis>головы </emphasis>и <emphasis>тела</emphasis>. Тело — это список <emphasis>целей</emphasis>, разделенных запятыми. Запятая понимается как конъюнкция.</p>
     <p>• Факты — это предложения, имеющие пустое тело. Вопросы имеют только тело. Правила имеют голову и (непустое) тело.</p>
     <p>• По ходу вычислений вместо переменной может быть подставлен другой объект. Мы говорим в этом случае, что переменная <emphasis>конкретизирована</emphasis>.</p>
     <p>Предполагается, что на переменные действует квантор всеобщности, читаемый как "для всех…". Однако для переменных, появляющихся только в теле, возможны и другие формулировки. Например,</p>
     <p><code>имеетребенка( X) :- родитель( X, Y).</code></p>
     <p>можно прочитать двумя способами:</p>
     <p>(а) <emphasis>Для всех</emphasis> X и Y,</p>
     <p>     если X — отец Y, то</p>
     <p>     X имеет ребенка.</p>
     <p>(б) <emphasis>Для всех</emphasis> X,</p>
     <p>     X имеет ребенка, если</p>
     <p>     существует <emphasis>некоторый</emphasis> Y, такой, что</p>
     <p>     X — родитель Y.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>1.3.</strong> Оттранслируйте следующие утверждения в правила на Прологе:</p>
     <p>(a) Всякий, кто имеет ребенка, — счастлив (введите одноаргументное отношение <code>счастлив</code>).</p>
     <p>(b) Всякий X, имеющий ребенка, у которого есть сестра, имеет двух детей (введите новое отношение <code>иметьдвухдетей</code>).</p>
     <p><strong>1.4.</strong> Определите отношение <code>внук</code>, используя отношение <code>родитель</code>. Указание: оно будет похоже на отношение <code>родительродителя</code> (см. рис. 1.3).</p>
     <p><strong>1.5.</strong> Определите отношение <code>тетя( X, Y)</code> через отношение <code>родитель</code> и <code>сестра</code>. Для облегчения работы можно сначала изобразить отношение <code>тетя</code> в виде диаграммы по типу тех, что изображены на рис. 1.3. </p>
    </section>
    <section>
     <title>
      <p>1.3. Рекурсивное определение правил</p>
     </title>
     <p>Давайте добавим к нашей программе о родственных связях еще одно отношение — <strong>предок</strong>. Определим его через отношение <code>родитель</code>. Все отношение можно выразить с помощью двух правил. Первое правило будет определять непосредственных (ближайших) предков, а второе — отдаленных. Будем говорить, что некоторый является отдаленным предком некоторого Z, если между X и Z существует цепочка людей, связанных между собой отношением родитель-ребенок, как показано на рис.1.5. В нашем примере на рис. 1.1 Том — ближайший предок Лиз и отдаленный предок Пат.</p>
     <image l:href="#_10.jpg_0"/>
     <p><strong>Рис. 1.5.</strong> Пример отношения <code>предок</code>: (а) <code>X</code> — <emphasis>ближайший</emphasis> предок <code>Z</code>; (b) <code>X</code> — отдаленный предок <code>Z</code>.</p>
     <p>Первое правило простое и его можно сформулировать так:</p>
     <p>Для всех X и Z,</p>
     <p>  X — предок Z, если</p>
     <p>  X — родитель Z.</p>
     <p>Это непосредственно переводится на Пролог как</p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Z).</code></p>
     <p>Второе правило сложнее, поскольку построение цепочки отношений <code>родитель</code> может вызвать некоторые трудности. Один из способов определения отдаленных родственников мог бы быть таким, как показано на рис. 1.6. В соответствии с ним отношение предок определялось бы следующим множеством предложений:</p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Z).</code></p>
     <empty-line/>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Y),</code></p>
     <p><code> родитель( Y, Z).</code></p>
     <empty-line/>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Y1),</code></p>
     <p><code> родитель( Yl, Y2),</code></p>
     <p><code> родитель( Y2, Z).</code></p>
     <empty-line/>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Y1),</code></p>
     <p><code> родитель( Y1, Y2),</code></p>
     <p><code> родитель( Y2, Y3),</code></p>
     <p><code> родитель( Y3, Z).</code></p>
     <empty-line/>
     <p><code>...</code></p>
     <image l:href="#_11.png"/>
     <p><strong>Рис. 1.6.</strong> Пары предок-потомок, разделенных разным числом поколений.</p>
     <p>Эта программа длинна и, что более важно, работает только в определенных пределах. Она будет обнаруживать предков лишь до определенной глубины фамильного дерева, поскольку длина цепочки людей между предком и потомком ограничена длиной наших предложений в определении отношения.</p>
     <p>Существует, однако, корректная и элегантная формулировка отношения <code>предок</code> — корректная в том смысле, что будет работать для предков произвольной отдаленности. Ключевая идея здесь — определить отношение <code>предок</code> через него самого. Рис 1.7 иллюстрирует эту идею:</p>
     <p>Для всех X и Z,</p>
     <p>  X — предок Z, если</p>
     <p> существует Y, такой, что</p>
     <p> (1)  X — родитель Y и</p>
     <p> (2)  Y — предок Z.</p>
     <p>Предложение Пролога, имеющее тот же смысл, записывается так:</p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Y),</code></p>
     <p><code> предок( Y, Z).</code></p>
     <p>Теперь мы построили полную программу для отношения <code>предок</code>, содержащую два правила: одно для ближайших предков и другое для отдаленных предков. Здесь приводятся они оба вместе:</p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Z).</code></p>
     <empty-line/>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Y),</code></p>
     <p><code> предок( Y, Z).</code></p>
     <empty-line/>
     <image l:href="#_12.png"/>
     <p><strong>Рис. 1.7.</strong>  Рекурсивная формулировка отношения <code>предок</code>.</p>
     <p>Ключевым моментом в данной формулировке было использование самого отношения <code>предок</code> в его определении. Такое определение может озадачить - допустимо ли при определении какого-либо понятия использовать его же, ведь оно определено еще не полностью. Такие определения называются <emphasis>рекурсивными</emphasis>. Логически они совершенно корректны и понятны; интуитивно это ясно, если посмотреть на рис. 1.7. Но будет ли в состоянии пролог-система использовать рекурсивные правила? Оказывается, что пролог-система очень легко может обрабатывать рекурсивные определения. На самом деле, рекурсия — один из фундаментальных приемов программирования на Прологе. Без рекурсии с его помощью невозможно решать задачи сколько-нибудь ощутимой сложности.</p>
     <p>Возвращаясь к нашей программе, можно теперь задать системе вопрос: "Кто потомки Пам?" То есть: "Кто тот человек, чьим предком является Пам?"</p>
     <p><code>?-  предок( пам, X).</code></p>
     <empty-line/>
     <p><code>X  =  боб;</code></p>
     <p><code>X  =  энн;</code></p>
     <p><code>X  =  пат;</code></p>
     <p><code>X  =  джим</code></p>
     <p>Ответы системы, конечно, правильны, и они логически вытекают из наших определений отношений <code>предок</code> и <code>родитель</code>. Возникает, однако, довольно важный вопрос: "<emphasis>Как</emphasis> в действительности система использует программу для отыскания этих ответов?"</p>
     <p>Неформальное объяснение того, как система это делает, приведено в следующем разделе. Но сначала давайте объединим все фрагменты нашей программы о родственных отношениях, которая постепенно расширялась по мере того, как мы вводили в нее новые факты и правила. Окончательный вид программы показан на рис. 1.8.</p>
     <p>При рассмотрении рис. 1.8 следует учесть два новых момента: первый касается понятия "процедура", второй — комментариев в программах. Программа, приведенная на рис. 1.8, определяет несколько отношений — <code>родитель</code>, <code>мужчина</code>, <code>женщина</code>, <code>предок</code> и т.д. Отношение <code>предок</code>, например, определено с помощью двух предложений. Будем говорить, что эти два предложения входят в состав отношения <code>предок</code>. Иногда бывает удобно рассматривать в целом все множество предложений, входящих в состав одного отношения. Такое множество называется <emphasis>процедурой</emphasis>.</p>
     <p><code>родитель( пам, боб). % Пам - родитель Боба</code></p>
     <p><code>родитель( том, боб).</code></p>
     <p><code>родитель( том, лиз).</code></p>
     <p><code>родитель( бoб, энн).</code></p>
     <p><code>родитель( боб, пат).</code></p>
     <p><code>родитель( пат, джим).</code></p>
     <empty-line/>
     <p><code>женщина( пам).       % Пам - женщина</code></p>
     <p><code>мужчина( том).       % Том - мужчина</code></p>
     <p><code>мужчина( боб).</code></p>
     <p><code>женщина( лиз).</code></p>
     <p><code>женщина( энн).</code></p>
     <p><code>женщина( пат).</code></p>
     <p><code>мужчина( джим).</code></p>
     <empty-line/>
     <p><code>отпрыск( Y, X) :-    % Y - отпрыск X, если</code></p>
     <p><code> родитель( X, Y).    % X - родитель Y</code></p>
     <empty-line/>
     <p><code>мать( X, Y) :-       % X - мать Y, если</code></p>
     <p><code> родитель( X, Y),    % X - родитель Y и</code></p>
     <p><code> женщина( X).        % X - женщина</code></p>
     <empty-line/>
     <p><code>родительродителя( X, Z) :-</code></p>
     <p><code> % X - родитель родителя Z, если</code></p>
     <p><code> родитель( X, Y),    % X - родитель Y и</code></p>
     <p><code> родитель( Y, Z).    % Y - родитель Z</code></p>
     <empty-line/>
     <p><code>сестра( X, Y) :-     % X - сестра Y</code></p>
     <p><code> родитель( Z, X),</code></p>
     <p><code> родитель( Z, Y)     % X и Y имеют общего родителя</code></p>
     <p><code> женщина( X, Y),     % X - женщина и</code></p>
     <p><code> различны( X, Y).    % X отличается от Y</code></p>
     <empty-line/>
     <p><code>предок( X, Z) :-     % Правило пр1:  X - предок Z</code></p>
     <p><code> родитель( X, Z).</code></p>
     <p><code>предок( X, Z) :-     % Правило пр2:  X - предок Z</code></p>
     <p><code> родитель( X, Y),</code></p>
     <p><code> предок( Y, Z).</code></p>
     <p><strong>Рис. 1.8.</strong> Программа о родственных отношениях.</p>
     <empty-line/>
     <p>На рис. 1.8 два предложения, входящие в состав отношения <code>предок</code>, выделены именами "пр1" и "пр2", добавленными в программу в виде <emphasis>комментариев</emphasis>. Эти имена будут использоваться в дальнейшем для ссылок на соответствующие правила. Вообще говоря, комментарии пролог-системой игнорируются. Они нужны лишь человеку, который читает программу. В Прологе комментарии отделяются от остального текста программы специальными скобками "<code>/*</code>" и "<code>*/</code>". Таким образом, прологовский комментарий выглядит так</p>
     <p><code>/* Это комментарий */</code></p>
     <p>Другой способ, более практичный для коротких комментариев, использует символ процента <code>%</code>. Все, что находится между <code>%</code> и концом строки, расценивается как комментарии:</p>
     <p><code>% Это тоже комментарий</code></p>
     <subtitle>Упражнение</subtitle>
     <p><strong>1.6.</strong> Рассмотрим другой вариант отношения предок:</p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Z).</code></p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( Y, Z),</code></p>
     <p><code> предок( X, Y).</code></p>
     <p>Верно ли и такое определение? Сможете ли Вы изменить диаграмму на рис. 1.7 таким образом, чтобы она соответствовала новому определению?</p>
    </section>
    <section>
     <title>
      <p>1.4. Как пролог-система отвечает на вопросы</p>
     </title>
     <p>В данном разделе приводится неформальное объяснение того, <emphasis>как</emphasis> пролог-система отвечает на вопросы.</p>
     <p>Вопрос к системе — это всегда последовательность, состоящая из одной или нескольких целей. Для того, чтобы ответить на вопрос, система пытается достичь всех целей. Что значит достичь цели? Достичь цели — это значит показать, что утверждения, содержащиеся в вопросе, истинны в предположении, что все отношения программы истинны. Другими словами, достичь цели - это значит показать, что она <emphasis>логически</emphasis> следует из фактов и правил программы. Если вопрос содержит переменные, система должна к тому же найти конкретные объекты, которые (будучи подставленными вместо переменных) обеспечивают достижение цели. Найденные конкретизации сообщаются пользователю. Если для некоторой конкретизации система не в состоянии вывести цель из остальных предложений программы, то ее ответом на вопрос будет "нет".</p>
     <p>Таким образом, подходящей интерпретацией пролог-программы в математических терминах будет следующая: пролог-система рассматривает факты и правила в качестве множества аксиом, а вопрос пользователя — как <emphasis>теорему</emphasis>; затем она пытается доказать эту теорему, т.е. показать, что ее можно логически вывести из аксиом.</p>
     <p>Проиллюстрируем этот подход на классическом примере. Пусть имеются следующие аксиомы:</p>
     <p> Все люди смертны.</p>
     <p> Сократ — человек.</p>
     <p>Теорема, логически вытекающая из этих двух аксиом:</p>
     <p> Сократ смертен.</p>
     <p>Первую из вышеуказанных аксиом можно переписать так:</p>
     <p> Для всех X, если X — человек, то X смертен.</p>
     <p>Соответственно наш пример можно перевести на Пролог следующим образом:</p>
     <p><code>смертен( X) :- человек( X). % Все люди смертны</code></p>
     <p><code>человек( сократ).           % Сократ - человек</code></p>
     <p><code>?-  смертен( сократ).       % Сократ смертен?</code></p>
     <p><code>yes                  </code> (да)</p>
     <p>Более сложный пример из программы о родственных отношениях, приведенной на рис. 1.8:</p>
     <p><code>?- предок( том, пат)</code></p>
     <p>Мы знаем, что <code>родитель( боб, пат)</code> — это факт. Используя этот факт и правило <emphasis>пр1</emphasis>, мы можем сделать вывод, что утверждение <code>предок( боб, пат)</code> истинно. Этот факт получен в результате <emphasis>вывода</emphasis> — его нельзя найти непосредственно в программе, но можно вывести, пользуясь содержащимися в ней фактами и правилами. Подобный шаг вывода можно коротко записать</p>
     <p><code>родитель( боб, пат) ==&gt; предок( боб, пат)</code></p>
     <p>Эту запись можно прочитать так: из <code>родитель( боб, пат)</code> следует <code>предок( боб, пат)</code> на основании правила <emphasis>пр1</emphasis>. Далее, нам известен факт <code>родитель( том, боб)</code>. На основании этого факта и выведенного факта <code>предок( боб, пат)</code> можно заключить, что, в силу правила <emphasis>пр2</emphasis>, наше целевое утверждение <code>предок( том, пат)</code> истинно. Весь процесс вывода, состоящий из двух шагов, можно записать так:</p>
     <p><code>родитель(боб, пат) ==&gt; предок( боб, пат)</code></p>
     <p><code>родитель(том, боб)</code> <emphasis>и</emphasis> <code>  предок( боб, пат) ==&gt;</code></p>
     <p><code> предок( том, пат)</code></p>
     <p>Таким образом, мы показали, <emphasis>какой</emphasis> может быть последовательность шагов для достижения цели, т.е. для демонстрации истинности целевого утверждения. Назовем такую последовательность цепочкой доказательства. Однако мы еще не показали как пролог-система в действительности строит такую цепочку.</p>
     <p>Пролог-система строит цепочку доказательства в порядке, обратном по отношению к тому, которым мы только что воспользовались. Вместо того, чтобы начинать с простых фактов, приведенных в программе, система начинает с целей и, применяя правила, подменяет текущие цели новыми, до тех пор, пока эти новые цели не окажутся простыми фактами. Если задан вопрос</p>
     <p><code>?-  предок( том, пат).</code></p>
     <p>система попытается достичь этой цели. Для того, чтобы это сделать, она пробует найти такое предложение в программе, из которого немедленно следует упомянутая цель. Очевидно, единственными подходящими для этого предложениями являются <emphasis>пр1</emphasis> и <emphasis>пр2</emphasis>.</p>
     <image l:href="#_13.png"/>
     <p><strong>Рис. 1.9.</strong>  Первый шаг вычислений. Верхняя цель истинна, если истинна нижняя.</p>
     <p>Это правила, входящие в отношение предок. Будем говорить, что головы этих правил сопоставимы с целью.</p>
     <p>Два предложения <emphasis>пр1</emphasis> и <emphasis>пр2</emphasis> описывают два варианта продолжения рассуждений для пролог-системы. Вначале система пробует предложение, стоящее в программе первым:</p>
     <p><code>предок( X, Z) :- родитель( X, Z).</code></p>
     <p>Поскольку цель — предок( том, пат), значения переменным должны быть приписаны следующим образом:</p>
     <p><code>X = том, Z = пат</code></p>
     <p>Тогда исходная цель <code>предок( том, пат)</code> заменяется новой целью:</p>
     <p><code>родитель( том, пат)</code></p>
     <p>Такое действие по замене одной цели на другую на основании некоторого правила показано на рис. 1.9. В программе нет правила, голова которого была бы сопоставима с целью <code>родитель(том, пат)</code>, поэтому такая цель оказывается неуспешной. Теперь система делает <emphasis>возврат</emphasis> к исходной цели, чтобы попробовать второй вариант вывода цели верхнего уровня <code>предок( том, пат)</code>. То есть, пробуется правило <emphasis>пр2</emphasis>:</p>
     <p><code>предок( X, Z) :-</code></p>
     <p><code> родитель( X, Y),</code></p>
     <p><code> предок( Y, Z).</code></p>
     <p>Как и раньше, переменным X и Z приписываются значения:</p>
     <p><code>X = том, Z = пат</code></p>
     <p>В этот момент переменной Y еще не приписано никакого значения. Верхняя цель <code>предок( том, пат)</code> заменяется двумя целями:</p>
     <p><code>родитель( том, Y),</code></p>
     <p><code>предок( Y, пат)</code></p>
     <p>Этот шаг вычислений показан на рис. 1.10, который представляет развитие ситуации, изображенной на рис. 1.9.</p>
     <image l:href="#_14.png"/>
     <p><strong>Рис. 1.10.</strong> Продолжение процесса вычислений, показанного на рис. 1.9.</p>
     <p>Имея теперь перед собой <emphasis>две </emphasis>цели, система пытается достичь их в том порядке, каком они записаны. Достичь первой из них легко, поскольку она соответствует факту из программы. Процесс установления соответствия — сопоставление (унификация) вызывает приписывание переменной Y значения <code>боб</code>. Тем самым достигается первая цель, а оставшаяся превращается в</p>
     <p><code>предок( боб, пат)</code></p>
     <p>Для достижения этой цели вновь применяется правило <emphasis>пр1</emphasis>. Заметим, — что это (второе) применение правила никак не связано с его первым применением. Поэтому система использует новое множество переменных правила всякий раз, как оно применяется. Чтобы указать это, мы переименуем переменные правила <emphasis>пр1</emphasis> для нового его применения следующим образом:</p>
     <p><code>предок( X', Z') :-</code></p>
     <p><code> родитель( X', Z').</code></p>
     <p>Голова этого правила должна соответствовать нашей текущей цели <code>предок( боб, пат)</code>. Поэтому</p>
     <p><code>X' = боб, Z' = пат</code></p>
     <p>Текущая цель заменяется на</p>
     <p><code>родитель( боб, пат)</code></p>
     <p>Такая цель немедленно достигается, поскольку встречается в программе в качестве факта. Этот шаг завершает вычисление, что графически показано на рис. 1.11.</p>
     <image l:href="#_15.png"/>
     <p><strong>Рис. 1.11.</strong>  Все шаги достижения цели <code>предок( том, пат)</code>. Правая ветвь демонстрирует, что цель достижима.</p>
     <p>Графическое представление шагов вычисления на рис. 1.11 имеет форму дерева. Вершины дерева соответствуют целям или спискам целей, которые требуется достичь. Дуги между вершинами соответствуют применению (альтернативных) предложений программы, которые преобразуют цель, соответствующую одной вершине, в цель, соответствующую другой вершине. Корневая (верхняя) цель достигается тогда, когда находится путь от корня дерева (верхней вершины) к его листу, помеченному меткой "да". Лист помечается меткой "да", если он представляет собой простой факт. Выполнение пролог-программы состоит в поиске таких путей. В процессе такого поиска система может входить и в ветви, приводящие к неуспеху. В тот момент, когда она обнаруживает, что ветвь не приводит к успеху, происходит автоматический <emphasis>возврат</emphasis> к предыдущей вершине, и далее следует попытка применить к ней альтернативное предложение.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>1.7.</strong> Постарайтесь понять, как пролог-система, используя программу, приведенную на рис. 1.8, выводит ответы на указанные ниже вопросы. Попытайтесь нарисовать соответствующие диаграммы вывода по типу тех, что изображены на рис.1.9–1.11. Будут ли встречаться возвраты при выводе ответов на какие-либо из этих вопросов?</p>
     <p>(a)  <code>?- родитель( пам, боб).</code></p>
     <p>(b)  <code>?- мать( пам, боб).</code></p>
     <p>(с)  <code>?- родительродителя( пам, энн).</code></p>
     <p>(d)  <code>?- родительродителя( боб, джим).</code> </p>
    </section>
    <section>
     <title>
      <p>1.5. Декларативный и процедурный смысл программ</p>
     </title>
     <p>До сих пор во всех наших примерах всегда можно было понять результаты работы программы, точно не зная, <emphasis>как</emphasis> система в действительности их нашла. Поэтому стоит различать два уровня смысла программы на Прологе, а именно:</p>
     <p>• <emphasis>декларативный смысл</emphasis> и</p>
     <p>• <emphasis>процедурный смысл</emphasis>.</p>
     <p>Декларативный смысл касается только <emphasis>отношений</emphasis>, определенных в программе. Таким образом, декларативный смысл определяет, <emphasis>что</emphasis> должно быть результатом работы программы. С другой стороны, процедурный смысл определяет еще и <emphasis>как</emphasis> этот результат был получен, т.е. как отношения реально обрабатываются пролог-системой.</p>
     <p>Способность пролог-системы прорабатывать многие процедурные детали самостоятельно считается одним из специфических преимуществ Пролога. Это свойство побуждает программиста рассматривать декларативный смысл программы относительно независимо от ее процедурного смысла. Поскольку результаты работы программы в принципе определяются ее декларативным смыслом, последнего (Опять же в принципе) достаточно для написания программ. Этот факт имеет практическое значение, поскольку декларативные аспекты программы являются, обычно, более легкими для понимания, нежели процедурные детали. Чтобы извлечь из этого обстоятельства наибольшую пользу, программисту следует сосредоточиться главным образом на декларативном смысле и по возможности не отвлекаться на детали процесса вычислений. Последние следует в возможно большей мере предоставить самой пролог-системе.</p>
     <p>Такой декларативный подход и в самом деле часто делает программирование на Прологе более легким, чем на таких типичных процедурно-ориентированных языках, как Паскаль. К сожалению, однако, декларативного подхода не всегда оказывается, достаточно. Далее станет ясно, что, особенно в больших программах, программист не может полностью игнорировать процедурные аспекты по соображениям эффективности вычислений. Тем не менее следует поощрять декларативный стиль мышления при написании пролог-программ, а процедурные аспекты игнорировать в тех пределах, которые устанавливаются практическими ограничениями.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Программирование на Прологе состоит в определении отношений и в постановке вопросов, касающихся этих отношений.</p>
     <p>• Программа состоит из предложений. Предложения бывают трех типов: <emphasis>факты</emphasis>, <emphasis>правила</emphasis> и <emphasis>вопросы.</emphasis></p>
     <p>• Отношение может определяться <emphasis>фактами</emphasis>, перечисляющими <emphasis>n</emphasis>-ки объектов, для которых это отношение выполняется, или же оно может определяться <emphasis>правилами</emphasis>.</p>
     <p>• <emphasis>Процедура</emphasis> — это множество предложений об одном и том же отношении.</p>
     <p>• <emphasis>Вопросы</emphasis> напоминают запросы к некоторой базе данных. Ответ системы на вопрос представляет собой множество объектов, которые удовлетворяют запросу.</p>
     <p>• Процесс, в результате которого пролог-система устанавливает, удовлетворяет ли объект запросу, часто довольно сложен и включает в себя логический вывод, исследование различных вариантов и, возможно, <emphasis>возвраты</emphasis>. Все это делается автоматически самой пролог-системой и по большей части скрыто от пользователя.</p>
     <p>• Различают два типа смысла пролог-программ: декларативный и процедурный. Декларативный подход предпочтительнее с точки зрения программирования. Тем не менее, программист должен часто учитывать также и процедурные детали.</p>
     <p>• В данной главе были введены следующие понятия:</p>
     <p>  предложение, факт, правило, вопрос</p>
     <p>  голова предложения, тело предложения</p>
     <p>  рекурсивное правило</p>
     <p>  рекурсивное определение</p>
     <p>  процедура</p>
     <p>  атом, переменная</p>
     <p>  конкретизация переменной</p>
     <p>  цель</p>
     <p>  цель достижима, цель успешна</p>
     <p>  цель недостижима,</p>
     <p>  цель имеет неуспех, цель терпит неудачу</p>
     <p>  возврат</p>
     <p>  декларативный смысл, процедурный смысл.</p>
     <subtitle>Литература</subtitle>
     <p>Различные реализации Пролога используют разные синтаксические соглашения. В данной книге мы применяем так называемый Эдинбургский синтаксис (его называют также синтаксисом DEC-10, поскольку он принят в известной реализации Пролога для машины DEC-10; см. Pereira и др. 1978), он используется во многих популярных пролог-системах, таких как Quintus Prolog, Poplog, CProlog, Arity/Prolog, Prolog-2 и т.д.</p>
     <p>Bowen D. L. (1981). <emphasis>DECsystem-10 Prolog User's Manual.</emphasis> University of Edinburgh: Department of Artificial Intelligence.</p>
     <p>Mellish С. and Hardy S. (1984). <emphasis>Integrating Prolog in the POPLOG environment. Implementations of Prolog (J. A. Campbell, ed.).</emphasis> Ellis Horwood.</p>
     <p>Pereira F. (1982). <emphasis>C-Prolog User's Manual.</emphasis> University of Edinburgh: Department of Computer-Aided Architectural Design.</p>
     <p>Pereira L. M., Pereira F., Warren D. H. D. (1978). <emphasis>User's Guide to DECsystem-10 Prolog.</emphasis> University of Edinburgh: Department of Artificial Intelligence.</p>
     <p><emphasis>Quintus Prolog User's Guide and Reference Manual.</emphasis> Palo Alto: Quintus Computer System Inc. (1985).</p>
     <p><emphasis>The Arity/Prolog Programming Language.</emphasis> Concord, Massachusetts: Arity Corporation (1986). </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 2</p>
     <p>Синтаксис и семантика Пролог-программ</p>
    </title>
    <section>
     <p>В данной главе дается систематическое изложение синтаксиса и семантики основных понятий Пролога, а также вводятся структурные объекты данных. Рассматриваются следующие темы:</p>
     <p>• простые объекты данных (атомы, числа, переменные)</p>
     <p>• структурные объекты</p>
     <p>• сопоставление как основная операция над объектами</p>
     <p>• декларативная (или непроцедурная) семантика программ</p>
     <p>• взаимосвязь между декларативным и процедурным смыслами программ</p>
     <p>• изменение процедурного смысла путем изменения порядка следования предложений и целей</p>
     <p>Большая часть этих тем уже была затронута в гл. 1. Теперь их изложение будет более формальным и детализированным.</p>
    </section>
    <section>
     <title>
      <p>2.1.  Объекты данных</p>
     </title>
     <section>
      <p>На рис. 2.1 приведена классификация объектов данных Пролога. Пролог-система распознает тип объекта по его синтаксической форме в тексте программы. Это возможно благодаря тому, что синтаксис Пролога предписывает различные формы записи для различных типов объектов данных. В гл. 1 мы уже видели способ, с помощью которого можно отличить атомы от переменных: переменные начинаются с прописной буквы, тогда как атомы — со строчной. Для того, чтобы пролог-система распознала тип объекта, ей не требуется сообщать больше никакой дополнительной информации (такой, например, как объявление типа данных).</p>
      <image l:href="#_16.png"/>
      <p><strong>Рис. 2.1.</strong> Обьекты данных Пролога.</p>
     </section>
     <section>
      <title>
       <p>2.1.1. Атомы и числа</p>
      </title>
      <p>В гл. 1 мы уже видели несколько простых примеров атомов и переменных. Вообще же они могут принимать более сложные формы, а именно представлять собой цепочки следующих символов:</p>
      <p>• прописные буквы А, В, …, Z</p>
      <p>• строчные буквы а, b, …, z</p>
      <p>• цифры 0, 1, 2, …, 9</p>
      <p>• специальные символы, такие как </p>
      <p>   +  -  *  /   =  :  .  &amp;  _  ~</p>
      <p>Атомы можно создавать тремя способами:</p>
      <p>(1) из цепочки букв, цифр и символа подчеркивания _, начиная такую цепочку со строчной буквы:</p>
      <p><code>анна</code></p>
      <p><code>nil</code></p>
      <p><code>х25</code></p>
      <p><code>x_25</code></p>
      <p><code>x_25AB</code></p>
      <p><code>x_</code></p>
      <p><code>x__y</code></p>
      <p><code>альфа_бета_процедура</code></p>
      <p><code>мисс_Джонс</code></p>
      <p><code>сара_джонс</code></p>
      <p>(2) из специальных символов:</p>
      <p><code>&lt;---&gt;</code></p>
      <p><code>======&gt;</code></p>
      <p><code>...</code></p>
      <p><code>.:.</code></p>
      <p><code>::=</code></p>
      <p>Пользуясь атомами такой формы, следует соблюдать некоторую осторожность, поскольку часть цепочек специальных символов имеют в Прологе заранее определенный смысл. Примером может служить <code>:-</code> .</p>
      <p>(3) из цепочки символов, заключенной в одинарные кавычки. Это удобно, если мы хотим, например, иметь атом, начинающийся с прописной буквы. Заключая его в кавычки, мы делаем его отличным от переменной:</p>
      <p><code>'Том'</code></p>
      <p><code>'Южная_Америка'</code></p>
      <p><code>'Сара Джонс'</code></p>
      <p>Числа в Прологе бывают целыми и вещественными. Синтаксис целых чисел прост, как это видно из следующих примеров: 1, 1313, 0, -97. Не все целые числа могут быть представлены в машине, поэтому диапазон целых чисел ограничен интервалом между некоторыми минимальным и максимальным числами, определяемыми конкретной реализацией Пролога. Обычно реализация допускает диапазон хотя бы от -16 383 до 16 383, а часто, и значительно более широкий.</p>
      <p>Синтаксис вещественных чисел зависит от реализации. Мы будем придерживаться простых правил, видных из следующих примеров: 3.14, -0.0035, 100.2. При обычном программировании на Прологе вещественные числа используются редко. Причина этого кроется в том, что Пролог — это язык, предназначенный в первую очередь для обработки символьной, а не числовой информации, в противоположность языкам типа Фортрана, ориентированным на числовую обработку. При символьной обработке часто используются целые числа, например, для подсчета количества элементов списка; нужда же в вещественных числах невелика.</p>
      <p>Кроме отсутствия необходимости в использовании вещественных чисел в обычных применениях Пролога, существует и другая причина избегать их. Мы всегда стремимся поддерживать наши программы в таком виде, чтобы их смысл был предельно ясен. Введение вещественных чисел в некоторой степени нарушает эту ясность из-за ошибок вычислений, связанных с округлением во время выполнения арифметических действий. Например, результатом вычисления выражения 10000 + 0.0001 - 10000 может оказаться 0 вместо правильного значения 0.0001.</p>
     </section>
     <section>
      <title>
       <p>2.1.2. Переменные</p>
      </title>
      <p>Переменные — это цепочки, состоящие из букв, цифр и символов подчеркивания. Они начинаются с прописной буквы или с символа подчеркивания:</p>
      <p><code>X</code></p>
      <p><code>Результат</code></p>
      <p><code>Объект2</code></p>
      <p><code>Список_участников</code></p>
      <p><code>СписокПокупок</code></p>
      <p><code>_x23</code></p>
      <p><code>_23</code></p>
      <p>Если переменная встречается в предложения только один раз, то нет необходимости изобретать ей имя. Можно использовать так называемую "анонимную" переменную, которая записывается в виде одного символа подчеркивания. Рассмотрим, например, следующее правило:</p>
      <p><code>имеетребенка( X) :- родитель( X, Y).</code></p>
      <p>Это правило гласит: "Для всех X,  X имеет ребенка, если X является родителем некоторого Y". Здесь мы определяем свойство <code>имеетребенка</code> таким образом, что оно не зависит от имени ребенка. Следовательно, это как раз тот случай, когда уместно использовать анонимную переменную. Поэтому вышеприведенное правило можно переписать так:</p>
      <p><code>имеетребенка( X) :- родитель( X, _).</code></p>
      <p>Всякий раз, когда в предложения появляется одиночный символ подчеркивания, он обозначает новую анонимную переменную. Например, можно сказать, что существует некто, кто имеет ребенка, если существуют два объекта, такие, что один из них является родителем другого:</p>
      <p><code>некто_имеет_ребенка :- родитель( _, _).</code></p>
      <p>Это предложение эквивалентно следующему:</p>
      <p><code>некто_имеет_ребенка :- родитель( X, Y).</code></p>
      <p>Однако оно имеет совершенно другой смысл, нежели</p>
      <p><code>некто_имеет_ребенка :- родитель( X, X).</code></p>
      <p>Если анонимная переменная встречается в вопросе, то ее значение не выводится при ответе системы на этот вопрос. Если нас интересуют люди, имеющие детей, но не имена этих детей, мы можем просто спросить:</p>
      <p><code>?-  родитель( X, _ ).</code></p>
      <p>Лексический диапазон имени — одно предложение. Это значит, что если, например, имя X15 встречается в двух предложениях, то оно обозначает две разные переменные. Однако внутри одного предложения каждое его появлений обозначает одну и ту же переменную. Для констант ситуация другая: один и тот же атом обозначает один и тот же объект в любом предложении, иначе говоря, — во всей программе.</p>
     </section>
     <section>
      <title>
       <p>2.1.3. Структуры</p>
      </title>
      <p>Структурные объекты (или просто структуры) — это объекты, которые состоят из нескольких компонент. Эти компоненты, в свою очередь, могут быть структурами. Например, дату можно рассматривать как структуру, состоящую из трех компонент: день, месяц, год. Хотя они и составлены из нескольких компонент, структуры в программе ведут себя как единые объекты. Для того, чтобы объединить компоненты в структуру, требуется выбрать <emphasis>функтор</emphasis>. Для нашего примера подойдет функтор <code>дата</code>. Тогда дату 1-e мая 1983 г. можно записать так:</p>
      <p><code>дата( 1, май, 1983)</code></p>
      <p>(см. рис. 2.2).</p>
      <p>Все компоненты в данном примере являются константами (две компоненты — целые числа и одна — атом). Компоненты могут быть также переменными или структурами. Произвольный день в мае можно представить структурой:</p>
      <p><code>дата( День, май, 1983)</code></p>
      <p>Заметим, что <code>День</code> является переменной и ей можно приписать произвольное значение на некотором более позднем этапе вычислений.</p>
      <p>Такой метод структурирования данных прост и эффективен. Это является одной из причин того, почему Пролог естественно использовать для решения задач обработки символьной информации.</p>
      <p>Синтаксически все объекты данных в Прологе представляют собой <emphasis>термы</emphasis>. Например,</p>
      <p><code>май</code></p>
      <p>и</p>
      <p><code>дата( 1, май, 1983)</code></p>
      <p>суть термы.</p>
      <p>Все структурные объекты можно изображать в виде деревьев (пример см. на рис. 2.2). Корнем дерева служит функтор, ветвями, выходящими из него, — компоненты. Если некоторая компонента тоже является структурой, тогда ей соответствует поддерево в дереве, изображающем весь структурный объект.</p>
      <p>Наш следующий пример показывает, как можно использовать структуры для представления геометрических объектов (см. рис. 2.3). Точка в двумерном пространстве определяется двумя координатами; отрезок определяется двумя точками, а треугольник можно задать тремя точками. Введем следующие функторы:</p>
      <p><code>точка        </code>для точек</p>
      <p><code>отрезок      </code>для отрезков и</p>
      <p><code>треугольник  </code>для треугольников.</p>
      <image l:href="#_17.png"/>
      <p><strong>Рис. 2.2.</strong> Дата — пример структурного объекта: (а) его представление в виде дерева; (б) запись на Прологе.</p>
      <p>Тогда объекты, приведенные на рис. 2.3, можно представить следующими прологовскими термами:</p>
      <p><code>P1 = точка( 1, 1)</code></p>
      <empty-line/>
      <p><code>P2 = точка( 2, 3)</code></p>
      <empty-line/>
      <p><code>S = отрезок( P1, P2) =</code></p>
      <p><code> отрезок( точка( 1, 1), точка( 2, 3) )</code></p>
      <empty-line/>
      <p><code>T = треугольник( точка( 4, 2), точка( 6, 4),</code></p>
      <p><code> точка( 7, 1) )</code></p>
      <image l:href="#Bezymjannyjj.png"/>
      <p><strong>Рис. 2.3.</strong> Простые геометрические объекты.</p>
      <p>Соответствующее представление этих объектов в виде деревьев приводится на рис. 2.4. Функтор, служащий корнем дерева, называется <emphasis>главным функтором</emphasis> терма.</p>
      <image l:href="#_19.png"/>
      <p><strong>Рис. 2. 4.</strong>  Представление объектов с рис. 2.3  в виде деревьев.</p>
      <p>Если бы в такой же программе фигурировали точки трехмерного пространства, то можно было бы для их представления использовать другой функтор, скажем <code>точка3</code>:</p>
      <p><code>точка3( X, Y, Z)</code></p>
      <p>Можно, однако, воспользоваться одним и тем же именем <code>точка</code> одновременно и для точек двумерного и трехмерного пространств и написать, например, так:</p>
      <p><code>точка( XI, Y1)</code> и <code>точка( X, Y, Z)</code></p>
      <p>Если одно и то же имя появляется в программе в двух различных смыслах, как в вышеупомянутом примере с точкой, то пролог-система будет различать их по числу аргументов и интерпретировать это имя как два функтора: один — двухаргументный; второй — трех. Это возможно потому, что каждый функтор определяется двумя параметрами:</p>
      <p>(1) именем, синтаксис которого совпадает с синтаксисом атомов;</p>
      <p>(2) <emphasis>арностью</emphasis> — т.е. числом аргументов.</p>
      <p>Как уже объяснялось, все структурные объекты в Прологе — это деревья, представленные в программе термами. Рассмотрим еще два примера, чтобы показать, насколько удобно сложные объекты данных представляются с помощью прологовских термов. На рис. 2.5 показана древовидная структура, соответствующая арифметическому выражению</p>
      <p><emphasis> (a + b)*(c - 5)</emphasis></p>
      <p>В соответствии с введенным к настоящему моменту синтаксисом, такое выражение, используя символы <code>*</code>,  <code>+</code>  и  <code>-</code>  в качестве функторов, можно записать следующим образом:</p>
      <p><code>*( +( a, b), -( c, 5))</code></p>
      <empty-line/>
      <image l:href="#_20.png"/>
      <p><strong>Рис. 2.5.</strong> Древовидная структура, соответствующая арифметическому выражению <emphasis>(a + b)*(c - 5)</emphasis>.</p>
      <p>Это, конечно, совершенно правильный прологовский терм, однако это не та форма, которую нам хотелось бы иметь, при записи арифметических выражений. Хотелось бы применять обычную инфиксную запись, принятую в математике. На самом деле Пролог допускает использование инфиксной нотации, при которой символы <code>*</code>,  <code>+</code>   и  <code>-</code>  записываются как инфиксные операторы. Детали того, как программист может определять свои собственные операторы, мы приведем в гл. 3.</p>
      <p>В качестве последнего примера рассмотрим некоторые простые электрические цепи, изображенные на рис. 2.6. В правой части рисунка помещены древовидные представления этих цепей. Атомы <code>r1</code>, <code>r2</code>, <code>r3</code> и <code>r4</code> — имена резисторов. Функторы <code>пар</code> и <code>посл</code> обозначают соответственно параллельное и последовательное соединение резисторов. Вот соответствующие прологовские термы:</p>
      <p><code>посл( r1, r2)</code></p>
      <p><code>пар( r1, r2)</code></p>
      <p><code>паp( rl, пap( r2, r3))</code></p>
      <p><code>пар( r1, посл( пар( r2, r3), r4))</code></p>
      <image l:href="#_21.png"/>
      <p><strong>Рис. 2.6.</strong> Некоторые простые электрические цепи и их представление: (а) последовательное соединение резисторов r1 и r2; (b) параллельное соединение двух резисторов; (с) параллельное соединение трех резисторов; (d) параллельное соединение r1 и еще одной цепи.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>2.1.</strong> Какие из следующих выражений представляют собой правильные объекты в смысле Пролога? Что это за объекты (атомы, числа, переменные, структуры)?</p>
      <p>(а)  <code>Диана</code></p>
      <p>(b)  <code>диана</code></p>
      <p>(с)  <code>'Диана'</code></p>
      <p>(d)  <code>_диана</code></p>
      <p>(e)  <code>'Диана едет на юг'</code></p>
      <p>(f)  <code>едет( диана, юг)</code></p>
      <p>(g)  <code>45</code></p>
      <p>(h)  <code>5( X, Y)</code></p>
      <p>(i)  <code>+( север, запад)</code></p>
      <p>(j)  <code>три( Черные( Кошки))</code></p>
      <p><strong>2.2.</strong> Предложите представление для прямоугольников, квадратов и окружностей в виде структурных объектов Пролога. Используйте подход, аналогичный приведенному на рис. 2.4. Например, прямоугольник можно представить четырьмя точками (а может быть, только тремя точками). Напишите несколько термов конкретных объектов такого типа с использованием предложенного вами представления. </p>
     </section>
    </section>
    <section>
     <title>
      <p>2.2. Сопоставление</p>
     </title>
     <p>В предыдущем разделе мы видели, как используются термы для представления сложных объектов данных. Наиболее важной операцией над термами является <emphasis>сопоставление</emphasis>. Сопоставление само по себе может производить содержательные вычисления.</p>
     <p>Пусть даны два терма. Будем говорить, что они <emphasis>сопоставимы</emphasis>, если:</p>
     <p>(1) они идентичны или</p>
     <p>(2) переменным в обоих термах можно приписать в качестве значений объекты (т.е. конкретизировать их) таким образом, чтобы после подстановки этих объектов в термы вместо переменных, последние стали идентичными.</p>
     <p>Например, термы <code>дата( Д, М, 1983)</code> и <code>дата( Д1, май, Y1)</code> сопоставимы. Одной из конкретизации, которая делает эти термы идентичными, является следующая:</p>
     <p>• <code>Д  </code>заменяется на <code>Д1</code></p>
     <p>• <code>М  </code>заменяется на <code>май</code></p>
     <p><strong>• </strong><code>Y1 </code>заменяется на <code>1983</code></p>
     <p>Более компактно такая подстановка записывается в привычной форме, т.е. в той, в которой пролог-система выводит результаты:</p>
     <p><code>Д = Д1</code></p>
     <p><code>М = май</code></p>
     <p><code>Y1 = 1983</code></p>
     <p>С другой стороны, <code>дата( Д, М, 1983)</code> и <code>дата( Д1, M1, 1944)</code> не сопоставимы, как и термы <code>дата( X, Y, Z)</code> и <code>точка( X, Y, Z)</code>.</p>
     <p><emphasis>Сопоставление</emphasis> — это процесс, на вход которого подаются два терма, а он проверяет, соответствуют ли эти термы друг другу. Если термы не сопоставимы, будем говорить, что этот процесс терпит <emphasis>неуспех</emphasis>. Если же они сопоставимы, тогда процесс находит конкретизацию переменных, делающую эти термы тождественными, и завершается <emphasis>успешно</emphasis>.</p>
     <p>Рассмотрим еще раз сопоставление двух дат. Запрос на проведение такой операции можно передать системе, использовав оператор '<code>=</code>':</p>
     <p><code>?- дата( Д, М, 1983) = дата( Д1, май, Y1).</code></p>
     <p>Мы уже упоминали конкретизацию <code>Д = Д1</code>, <code>М = май</code>, <code>Y1 = 1983</code>, на которой достигается сопоставление. Существуют, однако, и другие конкретизации, делающие оба терма идентичными. Вот две из них:</p>
     <p><code>Д  = 1</code></p>
     <p><code>Д1 = 1</code></p>
     <p><code>М  = май</code></p>
     <p><code>Y1 = 1983</code></p>
     <empty-line/>
     <p><code>Д  = третий</code></p>
     <p><code>Д1 = третий</code></p>
     <p><code>М  = май</code></p>
     <p><code>Y1 = 1983</code></p>
     <p>Говорят, что эти конкретизации являются <emphasis>менее общими</emphasis> по сравнению с первой, поскольку они ограничивают значения переменных <code>Д</code> и <code>Д1</code> в большей степени, чем это необходимо. Для того, чтобы сделать оба терма нашего примера идентичными, важно лишь, чтобы <code>Д</code> и <code>Д1</code> имели одно и то же значение, однако само это значение может быть произвольным. Сопоставление в Прологе всегда дает <emphasis>наиболее общую конкретизацию</emphasis>. Таковой является конкретизация, которая ограничивает переменные в наименьшей степени, оставляя им, тем самым, наибольшую свободу для дальнейших конкретизаций, если потребуются новые сопоставления. В качестве примера рассмотрим следующий вопрос:</p>
     <p><code>?- дата( Д, М, 1983) =  дата( Д1, май, Y1),</code></p>
     <p><code>   дата( Д, М, 1983) = дата( 15, М, Y).</code></p>
     <p>Для достижения первой цели система припишет переменным такие значения:</p>
     <p><code>Д  = Д1</code></p>
     <p><code>М  = май</code></p>
     <p><code>Y1 = 1983</code></p>
     <p>После достижения второй цели, значения переменных станут более конкретными, а именно:</p>
     <p><code>Д  = 15</code></p>
     <p><code>Д1 = 15</code></p>
     <p><code>М  = май</code></p>
     <p><code>Y1 = 1983</code></p>
     <p><code>Y  = 1983</code></p>
     <p>Этот пример иллюстрирует также и тот факт, что переменным по мере вычисления последовательности целей приписываются обычно все более и более конкретные значения.</p>
     <p>Общие правила выяснения, сопоставимы ли два терма <code>S</code> и <code>T</code>, таковы:</p>
     <cite>
      <p>(1) Если S и T — константы, то S и T сопоставимы, только если они являются одним и тем же объектом.</p>
      <p>(2) Если S — переменная, а T — произвольный объект, то они сопоставимы, и S приписывается значение T. Наоборот, если T —переменная, а S — произвольный объект, то T приписывается значение S.</p>
      <p>(3) Если S и T — структуры, то они сопоставимы, только если</p>
      <p>  (а) S и T имеют одинаковый главный функтор</p>
      <p>       и</p>
      <p>  (б) все их соответствующие компоненты сопоставимы.</p>
      <p>       Результирующая конкретизация определяется сопоставлением компонент.</p>
     </cite>
     <p>Последнее из этих правил можно наглядно представить себе, рассмотрев древовидное изображение термов, такое, например, как на рис. 2.7. Процесс сопоставления начинается от корня (главных функторов). Поскольку оба функтора сопоставимы, процесс продолжается и сопоставляет соответствующие пары аргументов. Таким образом, можно представить себе, что весь процесс сопоставления состоит из следующей последовательности (более простых) операций сопоставления:</p>
     <p><code>треугольник = треугольник,</code></p>
     <p><code>точка( 1, 1) = X,</code></p>
     <p><code>А = точка( 4, Y),</code></p>
     <p><code>точка( 2, 3) = точка( 2, Z).</code></p>
     <p>Весь процесс сопоставления успешен, поскольку все сопоставления в этой последовательности успешны. Результирующая конкретизация такова:</p>
     <p><code>X = точка( 1, 1)</code></p>
     <p><code>A = точка( 4, Y)</code></p>
     <p><code>Z = 3</code></p>
     <p>В приведенном ниже примере показано, как сопоставление само по себе можно использовать для содержательных вычислений. Давайте вернемся к простым геометрическим объектам с рис. 2.4 и напишем фрагмент программы для распознавания горизонтальных и вертикальных отрезков. "Вертикальность" — это свойство отрезка, поэтому его можно формализовать в Прологе в виде унарного отношения. Рис. 2.8 помогает сформулировать это отношение. Отрезок является вертикальным, если <emphasis>x</emphasis>-координаты его точек-концов совпадают; никаких других ограничений на отрезок не накладывается. Свойство "горизонтальности" формулируется аналогично, нужно только в этой формулировке <emphasis>x</emphasis> и <emphasis>y</emphasis> поменять местами. Следующая программа, содержащая два факта, реализует эти формулировки:</p>
     <p><code>верт( отр( точка( X, Y), точка( X, Y1) ) ).</code></p>
     <p><code>гор( отр( точка( X, Y), точка( X1, Y) ) ).</code></p>
     <image l:href="#_22.png"/>
     <p><strong>Рис. 2.7.</strong> Сопоставление <code>треугольник(( точка( 1, 1), А, точка( 2, 3)) = треугольник( X, точка( 4, Y), точка( 2, Z))</code></p>
     <p>С этой программой возможен такой диалог:</p>
     <p><code>?- верт( отр( точка( 1, 1), точка( 1, 2) ) ).</code></p>
     <p><code>да</code></p>
     <empty-line/>
     <p><code>?- верт( отр( точка( 1, 1), точка( 2, Y) ) ).</code></p>
     <p><code>нет</code></p>
     <empty-line/>
     <p><code>?- гор( отр( точка( 1, 1), точка( 2, Y) ) ).</code></p>
     <p><code>Y = 1</code></p>
     <p>На первый вопрос система ответила "да", потому. что цель, поставленная в вопросе, сопоставима с одним из фактов программы. Для второго вопроса сопоставимых фактов не нашлось. Во время ответа на третий вопрос при сопоставлении с фактом о горизонтальных отрезках Y получил значение 1.</p>
     <image l:href="#_23.png"/>
     <p><strong>Рис. 2.8.</strong> Пример вертикальных и горизонтальных отрезков прямых.</p>
     <p>Сформулируем более общий вопрос к программе: "Существуют ли какие-либо вертикальные отрезки, начало которых лежит в точке (2,3)?"</p>
     <p><code>?- верт( отр( точка( 2, 3), P) ).</code></p>
     <p><code>P = точка( 2, Y)</code></p>
     <p>Такой ответ означает: "Да, это любой отрезок, с концом в точке (2,Y), т.е. в произвольной точке вертикальной прямой <emphasis>x</emphasis> = 2". Следует заметить, что ответ пролог-системы возможно будет выглядеть не так красиво, как только что описано, а (в зависимости от реализации) приблизительно следующим образом:</p>
     <p><code>P = точка( 2, _136)</code></p>
     <p>Впрочем, разница здесь чисто внешняя. В данном случае <code>_136</code> — это неинициализированная переменная. Имя <code>_136</code> — законное имя прологовской переменной, которое система построила сама во время вычислений. Ей приходится генерировать новые имена, для того чтобы переименовывать введенные пользователем переменные в программе. Это необходимо по двум причинам: первая — одинаковые имена обозначают в разных предложениях разные переменные; и вторая — при последовательном применении одного и того же предложения используется каждый раз его "копия" с новым набором переменных.</p>
     <p>Другим содержательным вопросом к нашей программe является следующий: "Существует ли отрезок, который одновременно и горизонтален в вертикален?"</p>
     <p><code>?- верт( S), гор( S).</code></p>
     <p><code>S = отр( точка( X, Y), точка( X, Y) )</code></p>
     <p>Такой ответ пролог-системы следует, понимать так: "да, любой отрезок, выродившийся в точку, обладает как свойством вертикальности, так и свойством горизонтальности одновременно". Этот ответ снова получен лишь из сопоставления. Как и раньше, в ответе вместо X и Y могут появиться некоторые имена, сгенерированные системой.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>2.3.</strong> Будут ли следующие операции сопоставления успешными или неуспешными? Если они будут успешными, то какова будет результирующая конкретизация переменных?</p>
     <p>(а) <code>точка( А, В) = точка( 1, 2)</code></p>
     <p>(b) <code>точка( А, В) = точка( X, Y, Z)</code></p>
     <p>(c) <code>плюс( 2, 2) = 4</code></p>
     <p>(d) <code>+( 2, D)= +( E, 2)</code></p>
     <p>(e) <code>треугольник( точка( -1, 0), Р2, Р3) =</code></p>
     <p>     <code>треугольник( P1, точка( 1, 0), точка( 0, Y)</code></p>
     <p>Результирующая конкретизация определяет семейство треугольников. Как бы Вы описали это семейство?</p>
     <p><strong>2.4.</strong> Используя представление отрезков, применявшееся в данной разделе, напишите терм, соответствующий любому отрезку на вертикальной прямой <emphasis>x = 5</emphasis>.</p>
     <p><strong>2.5.</strong> Предположим, что прямоугольник представлен термом <code>прямоугольник( P1, P2, P3, Р4)</code>, где <code>P</code> — вершины прямоугольника, положительно упорядоченные. Определите отношение</p>
     <p><code>регулярный( R)</code></p>
     <p>которое имеет место, если R — прямоугольник с вертикальными и горизонтальными сторонами.</p>
    </section>
    <section>
     <title>
      <p>2.3. Декларативный смысл пролог-программ</p>
     </title>
     <p>В главе 1 мы уже видели, что пролог-программу можно понимать по-разному: с декларативной и процедурной точек зрения. В этом и следующем разделах мы рассмотрим более формальное определение декларативного и процедурного смыслов программ базисного Пролога. Но сначала давайте еще раз взглянем на различия между этими двумя семантиками.</p>
     <p>Рассмотрим предложение</p>
     <p><code>P :- Q, R.</code></p>
     <p>где P, Q и R имеют синтаксис термов. Приведем некоторые способы декларативной интерпретации этого предложения:</p>
     <p> P — истинно, если Q и R истинны.</p>
     <p> Из Q и R следует  P.</p>
     <p>А вот два варианта его "процедурного" прочтения:</p>
     <p> Чтобы решить задачу P, <emphasis>сначала</emphasis> реши подзадачу Q, а <emphasis>затем</emphasis> — подзадачу R.</p>
     <p> Чтобы достичь P, <emphasis>сначала</emphasis> достигни Q, а <emphasis>затем</emphasis> R.</p>
     <p>Таким образом, различие между "декларативным" и "процедурным" прочтениями заключается в том, что последнее определяет не только логические связи между головой предложения и целями в его теле, но еще и <emphasis>порядок</emphasis>, в котором эти цели обрабатываются.</p>
     <p>Формализуем теперь декларативный смысл.</p>
     <p>Декларативный смысл программы определяет, является ли данная цель истинной (достижимой) и, если да, при каких значениях переменных она достигается. Для точного определения декларативного смысла нам потребуется понятие <emphasis>конкретизации</emphasis> предложения. Конкретизацией предложения С называется результат подстановки в него на место каждой переменной некоторого терма. <emphasis>Вариантом</emphasis> предложения С называется такая конкретизация С, при которой каждая переменная заменена на другую переменную. Например, рассмотрим предложение:</p>
     <p><code>имеетребенка( X) :- родитель( X, Y).</code></p>
     <p>Приведем два варианта этого предложения:</p>
     <p><code>имеетребенка( А) :- родитель( А, В).</code></p>
     <p><code>имеетребенка( X1) :- родитель( X1, Х2).</code></p>
     <p>Примеры конкретизаций этого же предложения:</p>
     <p><code>имеетребенка( питер) :- родитель( питер, Z).</code></p>
     <p><code>имеетребенка( барри) :- родитель( барри,</code></p>
     <p><code>                        маленькая( каролина) ).</code></p>
     <p>Пусть дана некоторая программа и цель G, тогда, в соответствии с декларативной семантикой, можно утверждать, что</p>
     <cite>
      <p>Цель G истинна (т.е. достижима или логически следует из программы) тогда и только тогда, когда</p>
      <p>(1) в программе существует предложение С, такое, что</p>
      <p>(2) существует такая его (С) конкретизация I, что</p>
      <p>  (a) голова I совпадает с G и</p>
      <p>  (б) все цели в теле I истинны.</p>
     </cite>
     <p>Это определение можно распространить на вопросы следующим образом. В общем случае вопрос к пролог-системе представляет собой <emphasis>список</emphasis> целей, разделенных запятыми. Список целей называется <emphasis>истинным</emphasis> (достижимым), если <emphasis>все</emphasis> цели в этом списке истинны (достижимы) при <emphasis>одинаковых</emphasis> конкретизациях переменных. Значения переменных получаются из наиболее общей конкретизации.</p>
     <p>Таким образом, запятая между целями обозначает <emphasis>конъюнкцию</emphasis> целей: они <emphasis>все</emphasis> должны быть истинными. Однако в Прологе возможна и <emphasis>дизъюнкция</emphasis> целей: должна быть истинной, <emphasis>по крайней мере одна</emphasis> из целей. Дизъюнкция обозначается точкой с запятой. Например:</p>
     <p><code>P :- Q; R.</code></p>
     <p>читается так: P — истинно, если истинно Q <emphasis>или</emphasis> истинно R. То есть смысл такого предложения тот же, что и смысл следующей пары предложений:</p>
     <p><code>P :- Q.</code></p>
     <p><code>P :- R.</code></p>
     <p>Запятая связывает (цели) сильнее, чем точка с запятой. Таким образом, предложение</p>
     <p><code>P :- Q, R; S, T, U.</code></p>
     <p>понимается как:</p>
     <p><code>P :- ( Q, R); (S, T, U).</code></p>
     <p>и имеет тот же смысл, что и два предложения</p>
     <p><code>P :- Q, R.</code></p>
     <p><code>P :- S, T, U.</code></p>
     <subtitle>Упражнения</subtitle>
     <p><strong>2.6.</strong> Рассмотрим следующую программу:</p>
     <p><code>f( 1, один).</code></p>
     <p><code>f( s(1), два).</code></p>
     <p><code>f( s(s(1)), три).</code></p>
     <p><code>f( s(s(s(X))), N) :-</code></p>
     <p><code> f(X, N).</code></p>
     <p>Как пролог-система ответит на следующие вопросы? Там, где возможны несколько ответов, приведите по крайней мере два.</p>
     <p>(a)<code> ?- f( s( 1), A).</code></p>
     <p>(b)<code> ?- f( s(s(1)), два).</code> </p>
     <p>(c)<code> ?- f( s(s(s(s(s(s(1)))))), С).</code> </p>
     <p>(d)<code> ?- f( D, три).</code></p>
     <p><strong>2.7.</strong> В следующей программе говорится, что два человека являются родственниками, если</p>
     <p>(a) один является предком другого, или</p>
     <p>(b) у них есть общий предок, или</p>
     <p>(c) у них есть общий потомок.</p>
     <p><code>родственники( X, Y) :-</code></p>
     <p><code> предок( X, Y).</code></p>
     <empty-line/>
     <p><code>родственники( X, Y) :-</code></p>
     <p><code> предок( Y, X).</code></p>
     <empty-line/>
     <p><code>родственники( X, Y) :-</code></p>
     <p><code> % X и Y имеют общего предка</code></p>
     <p><code> предок( Z, X),</code></p>
     <p><code> предок( Z, Y).</code></p>
     <empty-line/>
     <p><code>родственники( X, Y) :-</code></p>
     <p><code> % X и Y имеют общего потомка</code></p>
     <p><code> предок( X, Z),</code></p>
     <p><code> предок( Y, Z).</code></p>
     <p>Сможете ли вы сократить эту программу, используя запись с точками с запятой?</p>
     <p><strong>2.8.</strong> Перепишите следующую программу, не пользуясь точками с запятой.</p>
     <p><code>преобразовать( Число, Слово) :-</code></p>
     <p><code> Число = 1, Слово = один;</code></p>
     <p><code> Число = 2, Слово = два;</code></p>
     <p><code> Число = 3, Слово = три.</code></p>
    </section>
    <section>
     <title>
      <p>2.4. Процедурная семантика</p>
     </title>
     <p>Процедурная семантика определяет, <emphasis>как</emphasis> пролог-система отвечает на вопросы. Ответить на вопрос — это значит удовлетворить список целей. Этого можно добиться, приписав встречающимся переменным значения таким образом, чтобы цели логически следовали из программы. Можно сказать, что процедурная семантика Пролога — это процедура вычисления списка целей с учетом заданной программы. "Вычислить цели" это значит попытаться достичь их.</p>
     <p>Назовем эту процедуру <code>вычислить</code>. Как показано на рис. 2.9, входом и выходом этой процедуры являются:</p>
     <p> входом — программа и список целей,</p>
     <p> выходом — признак успех/неуспех и подстановка переменных.</p>
     <image l:href="#_24.png"/>
     <p><strong>Рис. 2.9.</strong> Входы и выходы процедуры вычисления списка целей.</p>
     <p>Смысл двух составляющих выхода такой:</p>
     <p>(1)  Признак успех/неуспех принимает значение "да", если цели достижимы, и "нет" — в противном случае. Будем говорить, что "да" сигнализирует об <emphasis>успешном</emphasis> завершении и "нет" — о <emphasis>неуспехе</emphasis>.</p>
     <p>(2)  Подстановка переменных порождается только в случае успешного завершения; в случае неуспеха подстановка отсутствует.</p>
     <subtitle>ПРОГРАММА</subtitle>
     <p><code>большой( медведь).     % Предложение 1</code></p>
     <p><code>большой( слон).        % Предложение 2</code></p>
     <p><code>маленький( кот).       % Предложение 3</code></p>
     <p><code>коричневый ( медведь). % Предложение 4</code></p>
     <p><code>черный ( кот).         % Предложение 5</code></p>
     <p><code>серый( слон).          % Предложение 6</code></p>
     <empty-line/>
     <p><code>темный( Z) :-          % Предложение 7:</code></p>
     <p><code> черный( Z).           % любой черный</code></p>
     <p><code>                       % объект является темным</code></p>
     <p><code>темный( Z) :-          % Предложение 8:</code></p>
     <p><code> коричневый( Z).       % Любой коричневый</code></p>
     <p><code>                       % объект является темным</code></p>
     <subtitle>ВОПРОС</subtitle>
     <p><code>?- темный( X), большой( X) % Кто одновременно темный</code></p>
     <p><code>                           % и большой?</code></p>
     <subtitle>ШАГИ  ВЫЧИСЛЕНИЯ</subtitle>
     <p>(1) Исходный список целевых утверждений:</p>
     <p><code>темный( X),  большой( X).</code></p>
     <p>(2) Просмотр всей программы от начала к концу и поиск предложения, у которого голова сопоставима с первым целевым утверждением</p>
     <p><code>темный( X).</code></p>
     <p>Найдена формула 7:</p>
     <p><code>темный( Z) :- черный( Z).</code></p>
     <p>Замена первого целевого утверждения конкретизированным телом предложения 7 — порождение нового списка целевых утверждений.</p>
     <p><code>черный( X),  большой( X)</code></p>
     <p>(3) Просмотр программы для нахождения предложения, сопоставимого с <code>черный( X)</code>. Найдено предложение 5: <code>черный ( кот)</code>. У этого предложения нет тела, поэтому список целей при соответствующей конкретизации сокращается до</p>
     <p><code>большой( кот)</code></p>
     <p>(4) Просмотр программы в поисках цели <code>большой( кот)</code>. Ни одно предложение не найдено. Поэтому происходит возврат к шагу (3) и отмена конкретизации <code>X = кот</code>. Список целей теперь снова</p>
     <p><code>черный( X),  большой( X)</code></p>
     <p>Продолжение просмотра программы ниже предложения 5. Ни одно предложение не найдено. Поэтому возврат к шагу (2) и продолжение просмотра ниже предложения 7. Найдено предложение (8):</p>
     <p><code>темный( Z) :- коричневый( Z).</code></p>
     <p>Замена первой цели в списке на <code>коричневый( X)</code>, что дает</p>
     <p><code>коричневый( X), большой( X)</code></p>
     <p>(5) Просмотр программы для обнаружения предложения, сопоставимого <code>коричневый( X)</code>. Найдено предложение <code>коричневый( медведь)</code>. У этого предложения нет тела, поэтому список целей уменьшается до</p>
     <p><code>большой( медведь)</code></p>
     <p>(6) Просмотр программы и обнаружение предложения <code>большой( медведь)</code>. У него нет тела, поэтому список целей становится пустым. Это указывает на успешное завершение, а соответствующая конкретизация переменных такова:</p>
     <p><strong>Рис. 2.10.</strong>  Пример, иллюстрирующий процедурную семантику Пролога: шаги вычислений, выполняемых процедурой <code>вычислить</code>.</p>
     <empty-line/>
     <p>В главе 1 в разд. "Как пролог-система отвечает на вопросы" мы уже фактически рассмотрели, что делает процедура <code>вычислить</code>. В оставшейся части данного раздела приводится несколько более формальное и систематическое описание этого процесса, которое можно пропустить без серьезного ущерба для понимания остального материала книги.</p>
     <p>Конкретные операции, выполняемые в процессе вычисления целевых утверждений, показаны на рис. 2.10. Возможно, следует изучить этот рисунок прежде, чем знакомиться с последующим общим описанием.</p>
     <p>Чтобы вычислить список целевых утверждений</p>
     <p> G1, G2, …, Gm</p>
     <p>процедура <code>вычислить</code> делает следующее:</p>
     <cite>
      <p>• Если список целей пуст - завершает работу <emphasis>успешно</emphasis>.</p>
      <p>• Если список целей не пуст, продолжает работу, выполняя (описанную далее) операцию 'ПРОСМОТР'.</p>
      <p>• <emphasis>ПРОСМОТР</emphasis>: Просматривает предложения программы от начала к концу до обнаружения первого предложения С, такого, что голова С сопоставима с первой целью G1. Если такого предложения обнаружить не удается, то работа заканчивается <emphasis>неуспехом</emphasis>.</p>
      <p>Если С найдено и имеет вид</p>
      <p><code>H :- B1, ..., Вn.</code></p>
      <p>то переменные в С переименовываются, чтобы получить такой вариант С' предложения С, в котором нет общих переменных со списком  G1, …, Gm. Пусть С' — это</p>
      <p><code>Н' :- B1', ..., Вn'.</code></p>
      <p>Сопоставляется G1 с H'; пусть S — результирующая конкретизация переменных. В списке целей G1, G2, …, Gm, цель G1 заменяется на список В1', …, Вn', что порождает новый список целей:</p>
      <p>В1', …, Вn', G2, …, Gm</p>
      <p>(Заметим, что, если С — факт, тогда n=0, и в этом случае новый список целей оказывается короче, нежели исходный; такое уменьшение списка целей может в определенных случаях превратить его в пустой, а следовательно, — привести к успешному завершению.)</p>
      <p>Переменные в новом списке целей заменяются новыми значениями, как это предписывает конкретизация S, что порождает еще один список целей</p>
      <p>В1'', …, Вn", G2', …, Gm'</p>
      <p>• Вычисляет (используя рекурсивно ту же самую процедуру) этот новый список целей. Если его вычисление завершается успешно, то и вычисление исходного списка целей тоже завершается успешно. Если же его вычисление порождает неуспех, тогда новый список целей отбрасывается и происходит возврат к просмотру программы. Этот просмотр продолжается, начиная с предложения, непосредственно следующего за предложением С (С — предложение, использовавшееся последним) и делается попытка достичь успешного завершения с помощью другого предложения.</p>
     </cite>
     <p>Более компактная запись этой процедуры в обозначениях, близких к Паскалю, приведена на рис. 2.11.</p>
     <p>Здесь следует сделать несколько дополнительных замечаний, касающихся процедуры <code>вычислить</code> в том виде, в котором она приводится. Во-первых, в ней явно не указано, как порождается окончательная результирующая конкретизация переменных. Речь идет о конкретизации S, которая приводит к успешному завершению и которая, возможно, уточнялась последующими конкретизациями во время вложенных рекурсивных вызовов <code>вычислить</code>.</p>
     <p><strong>procedure</strong> <emphasis>вычислить (Прогр, СписокЦелей, Успех)</emphasis> </p>
     <empty-line/>
     <p>Входные параметры: </p>
     <p> <emphasis>Прогр:</emphasis> список предложений </p>
     <p> <emphasis>СписокЦелей:</emphasis> список целей </p>
     <empty-line/>
     <p>Выходной параметр: </p>
     <p> <emphasis>Успех:</emphasis> истинностное значение; <emphasis>Успех</emphasis> принимает значение </p>
     <p>        истина, если список целевых утверждений </p>
     <p>        (их конъюнкция) истиннен с точки зрения <emphasis>Прогр</emphasis> </p>
     <empty-line/>
     <p>Локальные переменные: </p>
     <p> <emphasis>Цель:</emphasis> цель </p>
     <p> <emphasis>ДругиеЦели</emphasis>: список целей </p>
     <p> <emphasis>Достигнуты:</emphasis> истинностное значение </p>
     <p> <emphasis>Сопоставились:</emphasis> истинностное значение </p>
     <p> <emphasis>Конкрет:</emphasis> конкретизация переменных </p>
     <p>          <emphasis>H, Н', B1, B1', …, В<sub>n</sub>, В<sub>n</sub>':</emphasis> цели </p>
     <empty-line/>
     <p>Вспомогательные функции: </p>
     <p> <emphasis>пycтой( L):</emphasis> возвращает истину, если L — пустой список </p>
     <p> <emphasis>голoвa( L):</emphasis> возвращает первый элемент списка L </p>
     <p> <emphasis>хвост( L):</emphasis> возвращает остальную часть списка L </p>
     <p> <emphasis>конкат( L1, L2):</emphasis> создает конкатенацию списков — присоединяет </p>
     <p>  список L2 к концу списка L1 </p>
     <p> <emphasis>сопоставление( T1, T2, Сопоставились, Конкрет):</emphasis> пытается </p>
     <p>  сопоставить термы Т1 и T2; если они сопоставимы, то </p>
     <p>  <emphasis>Сопоставились</emphasis> — истина, а <emphasis>Конкрет</emphasis> представляет </p>
     <p>  собой конкретизацию переменных </p>
     <p> <emphasis>подставить( Конкрет, Цели):</emphasis> производит подстановку переменных </p>
     <p>  в <emphasis>Цели</emphasis> согласно <emphasis>Конкрет</emphasis> </p>
     <empty-line/>
     <p><strong>begin</strong> </p>
     <p> <strong>if</strong> <emphasis>пустой( СписокЦелей)</emphasis> <strong>then</strong> <emphasis>Успех </emphasis>: =<emphasis> истина</emphasis> </p>
     <p> <strong>else</strong> </p>
     <p><strong>  begin</strong> </p>
     <p>   <emphasis>Цель</emphasis> : = <emphasis>голова( СписокЦелей)</emphasis>; </p>
     <p>   <emphasis>ДругиеЦели</emphasis> : = <emphasis>хвост( СписокЦелей)</emphasis>; </p>
     <p>   <emphasis>Достигнута</emphasis> : = <emphasis>ложь;</emphasis> </p>
     <p>   <strong>while not</strong> <emphasis>Достигнута</emphasis> <strong>and</strong> </p>
     <p>    "в программе есть еще предложения" <strong>do</strong> </p>
     <p>    <strong>begin</strong> </p>
     <p>     <emphasis>Пусть следующее предложение в Прогр есть</emphasis> </p>
     <p><emphasis>      H :- B1, …, Вn.</emphasis> </p>
     <p><emphasis>     Создать вариант этого предложения</emphasis> </p>
     <p><emphasis>      Н' :- В1', …, Вn'.</emphasis> </p>
     <p><emphasis>     сопоставление( Цель, Н',</emphasis> </p>
     <p><emphasis>      Сопоставились, Конкрет)</emphasis> </p>
     <p>     <strong>if</strong> <emphasis>Сопоставились</emphasis> <strong>then</strong> </p>
     <p>      <strong>begin</strong> </p>
     <p>       <emphasis>НовыеЦели</emphasis> := </p>
     <p>        <emphasis>конкат( </emphasis>[<emphasis>В1', …, Вn'</emphasis> ]<emphasis>, Другие Цели</emphasis>); </p>
     <p>       <emphasis>НовыеЦели</emphasis> : = </p>
     <p>        <emphasis>подставить( Конкрет, НовыеЦели);</emphasis> </p>
     <p><emphasis>       вычислить( Прогр, НовыеЦели, Достигнуты)</emphasis> </p>
     <p>      <strong>end</strong> </p>
     <p><strong>    end;</strong> </p>
     <p>    <emphasis>Успех </emphasis>: =<emphasis> Достигнуты</emphasis> </p>
     <p>  <strong>end</strong> </p>
     <p><strong>end;</strong> </p>
     <p><strong>Рис. 2.11.</strong>  Вычисление целевых утверждений Пролога.</p>
     <empty-line/>
     <p>Всякий раз, как рекурсивный вызов процедуры <code>вычислить</code> приводят к неуспеху, процесс вычислений возвращается к <code>ПРОСМОТРУ</code> и продолжается с того предложения  С,  которое использовалось последним. Поскольку применение предложения  С  не привело к успешному завершению, пролог-система должна для продолжения вычислений попробовать альтернативное предложение. В действительности система аннулирует результаты части вычислений, приведших к неуспеху, и осуществляет возврат в ту точку (предложение  С),  в которой эта неуспешная ветвь начиналась. Когда процедура осуществляет возврат в некоторую точку, все конкретизации переменных, сделанные после этой точки, аннулируются. Такой порядок обеспечивает систематическую проверку пролог-системой всех возможных альтернативных путей вычисления до тех пор, пока не будет найден путь, ведущий к успеху, или же до тех пор, пока не окажется, что все пути приводят к неуспеху.</p>
     <p>Мы уже знаем, что даже после успешного завершения пользователь может заставить систему совершить возврат для поиска новых решений. В нашем описании процедуры вычислить эта деталь была опущена.</p>
     <p>Конечно, в настоящих реализациях Пролога в процедуру <code>вычислить</code> добавлены и еще некоторые усовершенствования. Одно из них — сокращение работы по просмотрам программы с целью повышения эффективности. Поэтому на практике пролог-система не просматривает все предложения программы, а вместо этого рассматривает только те из них, которые касаются текущего целевого утверждения.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>2.9.</strong> Рассмотрите программу на рис. 2.10 и по типу того, как это сделано на рис. 2.10, проследите процесс вычисления пролог-системой вопроса</p>
     <p><code>?- большой( X), темный( X).</code></p>
     <p>Сравните свое описание шагов вычисления с описанием на рис. 2.10, где вычислялся, по существу, тот же вопрос, но с другой последовательностью целей:</p>
     <p><code>?- темный( X), большой( X).</code></p>
     <p>В каком из этих двух случаев системе приходится производить б<emphasis>о</emphasis>льшую работу для нахождения ответа?</p>
    </section>
    <section>
     <title>
      <p>2.5. Пример: обезьяна и банан</p>
     </title>
     <p>Задача об обезьяне и банане часто используется в качестве простого примера задачи из области искусственного интеллекта. Наша пролог-программа, способная ее решить, показывает, как механизмы сопоставления и автоматических возвратов могут применяться для подобных целей. Мы сначала составим программу, не принимая во внимание процедурную семантику, а затем детально изучим ее процедурное поведение. Программа будет компактной и наглядной.</p>
     <p>Рассмотрим следующий вариант данной задачи. Возле двери комнаты стоит обезьяна. В середине этой комнаты к потолку подвешен банан. Обезьяна голодна и хочет съесть банан, однако она не может дотянуться до него, находясь на полу. Около окна этой же комнаты на полу лежит ящик, которым обезьяна может воспользоваться. Обезьяна может предпринимать следующие действия: ходить по полу, залезать на ящик, двигать ящик (если она уже находится около него) и схватить банан, если она стоит на ящике прямо под бананом. Может ли обезьяна добраться до банана?</p>
     <p>Одна из важных проблем при программировании состоит в выборе (адекватного) представления решаемой задачи в терминах понятий используемого языка программирования. В нашем случае мы можем считать, что "обезьяний мир" всегда находится в некотором <emphasis>состоянии</emphasis>, и оно может изменяться со временем. Текущее состояние определяется взаиморасположением объектов. Например, исходное состояние мира определяется так:</p>
     <p>(1) Обезьяна у двери.</p>
     <p>(2) Обезьяна на полу.</p>
     <p>(3) Ящик у окна.</p>
     <p>(4) Обезьяна не имеет банана.</p>
     <p>Удобно объединить все эти четыре информационных фрагмента в один структурный объект. Давайте в качестве такого объединяющего функтора выберем слово "состояние". На рис. 2.12 в виде структурного объекта изображено исходное состояние.</p>
     <p>Нашу задачу можно рассматривать как игру для одного игрока. Давайте, формализуем правила этой игры. Первое, целью игры является ситуация, в которой обезьяна имеет банан, т.е. любое состояние, у которого в качестве четвертой компоненты стоит "имеет":</p>
     <p><code>состояние( _, _, _, имеет)</code></p>
     <p>Второе, каковы разрешенные ходы, переводящие мир из одного состояния в другое? Существуют четыре типа ходов:</p>
     <p>(1) схватить банан,</p>
     <p>(2) залезть на ящик,</p>
     <p>(3) подвинуть ящик,</p>
     <p>(4) перейти в другое место.</p>
     <image l:href="#_25.png"/>
     <p><strong>Рис. 2.12.</strong> Исходное состояние обезьяньего мира, представленное в виде структурного объекта. Его четыре компоненты суть горизонтальная позиция обезьяны, вертикальная позиция обезьяны, позиция ящика, наличие или отсутствие у обезьяны банана.</p>
     <p>Не всякий ход допустим при всех возможных состояниях мира. Например, ход "схватить" допустим, только если обезьяна стоит на ящике прямо под бананом (т.е. в середине комнаты) и еще не имеет банана. Эти правила можно формализовать в Прологе в виде трехместного отношения <code>ход</code>:</p>
     <p><code>ход( Состояние1, М, Состояние2)</code></p>
     <p>Три аргумента этого отношения определяют ход, следующим образом:</p>
     <p><code>Состояние1 --------&gt; Состояние2</code></p>
     <p><code>                М</code></p>
     <p><code>Состояние1</code> это состояние до хода, <code>М</code> — выполняемый ход, и <code>Состояние2</code> — состояние после хода.</p>
     <p>Ход "схватить", вместе с необходимыми ограничениями на состояние перед этим ходом, можно выразить такой формулой:</p>
     <p><code>ход( состояние( середина, наящике, середина, неимеет),</code></p>
     <p><code>           % Перед ходом</code></p>
     <p><code> схватить, % Ход</code></p>
     <p><code> состояние( середина, наящике, середина, имеет) ).</code></p>
     <p><code>           % После хода</code></p>
     <p>В этом факте говорится о том, что после хода у обезьяны уже есть банан и что она осталась на ящике в середине комнаты.</p>
     <p>Таким же способом можно выразить и тот факт, что обезьяна, находясь на полу, может перейти из любой горизонтальной позиции P1 в любую позицию Р2. Обезьяна может это сделать независимо от позиции ящика, а также независимо от того, есть у нее банан или нет. Все это можно записать в виде следующего прологовского факта:</p>
     <p><code>ход( состояние( P1, наполу, В, H),</code></p>
     <p><code> перейти( P1, Р2), % Перейти из P1 в Р2</code></p>
     <p><code> состояние( Р2, наполу, В, H) ).</code></p>
     <p>Заметим, что в этом предложении делается много утверждений и, в частности:</p>
     <p>• выполненный ход состоял в том, чтобы "перейти из некоторой позиции P1 в некоторую позицию Р2";</p>
     <p>• обезьяна находится на полу, как до, так и после хода;</p>
     <p>• ящик находится в некоторой точке В, которая осталась неизменной после хода;</p>
     <p>• состояние "имеет банан" остается неизменным после хода.</p>
     <image l:href="#_26.png"/>
     <p><strong>Рис. 2.13.</strong> Рекурсивная формулировка отношения <code>можетзавладеть</code>.</p>
     <p>Данное предложение на самом деле определяет все множество возможных ходов указанного типа, так как оно применимо к любой ситуации, сопоставимой с состоянием, имеющим место перед входом. Поэтому такое предложение иногда называют <emphasis>схемой</emphasis> хода. Благодаря понятию переменной, имеющемуся в Прологе, такие схемы легко на нем запрограммировать.</p>
     <p>Два других типа ходов: "подвинуть" и "залезть" — легко определить аналогичным способом.</p>
     <p>Главный вопрос, на который должна ответить наша программа, это вопрос: "Может ли обезьяна, находясь в некотором начальном состоянии S, завладеть бананом?" Его можно сформулировать в виде предиката</p>
     <p><code>можетзавладеть( S)</code></p>
     <p>где аргумент S — состояние обезьяньего мира. Программа для <code>можетзавладеть</code> может основываться на двух наблюдениях:</p>
     <p>(1) Для любого состояния S, в которой обезьяна уже имеет банан, предикат <code>можетзавладеть</code> должен, конечно, быть истинным; в этом случае никаких ходов не требуется. Вот соответствующий прологовский факт:</p>
     <p><code>можетзавладеть( состояние( _, _, _, имеет) ).</code></p>
     <p>(2) В остальных случаях требуется один или более ходов. Обезьяна может завладеть бананом в любом состоянии S1, если для него существует ход из состояния P1 в некоторое состояние S2, такое, что, попав в него, обезьяна уже сможет завладеть бананом (за нуль или более ходов). Этот принцип показан на рис. 2.13. Прологовская формула, соответствующая этому правилу, такова:</p>
     <p><code>можетзавладеть( S1) :-</code></p>
     <p><code> ход( S1, М, S2),</code></p>
     <p><code> можетзавладеть( S2).</code></p>
     <p>Теперь мы полностью завершили нашу программу, показанную на рис. 2.14.</p>
     <p>Формулировка <code>можетзавладеть</code> рекурсивна и совершенно аналогична формулировке отношения <code>предок</code> из гл. 1 (ср. рис. 2.13 и 1.7). Этот принцип используется в Прологе повсеместно.</p>
     <p>Мы создали нашу программу "непроцедурным" способом. Давайте теперь изучим ее <emphasis>процедурное</emphasis> поведение, рассмотрев следующий вопрос к программе:</p>
     <p><code>?- можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).</code></p>
     <p>Ответом пролог-системы будет "да". Процесс, выполняемый ею при этом, обрабатывает, в соответствии с процедурной семантикой Пролога, последовательность списков целей. Для этого требуется некоторый перебор ходов, для отыскания верного из нескольких альтернативных. В некоторых точках при таком переборе будет сделан неверный ход, ведущий в тупиковую ветвь процесса вычислений. На этом этапе автоматический возврат позволит исправить положение. На рис. 2.15 изображен процесс перебора.</p>
     <p><code>% Разрешенные ходы</code></p>
     <p><code>ход( состояние( середина, на ящике, середина, неимеет),</code></p>
     <p><code> схватить,           % Схватить банан</code></p>
     <p><code> состояние( середина, наящике, середина, имеет)).</code></p>
     <empty-line/>
     <p><code>ход( состояние( P, наполу, P, H),</code></p>
     <p><code> залезть,            % Залезть на ящик</code></p>
     <p><code> состояние( P, наящике, P, H) ).</code></p>
     <empty-line/>
     <p><code>ход( состояние( P1, наполу, P1, H),</code></p>
     <p><code> подвинуть( P1, Р2), % Подвинуть ящик с P1 на Р2</code></p>
     <p><code> состояние( Р2, наполу, Р2, H) ).</code></p>
     <empty-line/>
     <p><code>ход( состояние( P1, наполу, В, H),</code></p>
     <p><code> перейти( P1, Р2),   % Перейти с P1 на Р2</code></p>
     <p><code> состояние( Р2, наполу, В, H) ).</code></p>
     <empty-line/>
     <p><code>% можетзавладеть(Состояние): обезьяна может завладеть</code></p>
     <p><code>% бананом, находясь в состоянии Состояние</code></p>
     <p><code>можетзавладеть( состояние( -, -, -, имеет) ).</code></p>
     <empty-line/>
     <p><code>% может 1:  обезьяна уже его имеет</code></p>
     <p><code>можетзавладеть( Состояние1) :-</code></p>
     <p><code> % может 2:  Сделать что-нибудь, чтобы завладеть им</code></p>
     <p><code> ход( Состояние1, Ход, Состояние2),</code></p>
     <p><code> % сделать что-нибудь</code></p>
     <p><code> можетзавладеть( Состояние2).</code></p>
     <p><code> % теперь может завладеть</code></p>
     <p><strong>Рис. 2.14.</strong>  Программа для задачи об обезьяне и банане.</p>
     <empty-line/>
     <p>Для ответа на наш вопрос системе пришлось сделать лишь один возврат. Верная последовательность ходов была найдена почти сразу. Причина такой эффективности программы кроется в том порядке, в котором в ней расположены предложения, касающиеся отношения <code>ход</code>. В нашем случае этот порядок (к счастью) оказался весьма подходящим. Однако возможен и менее удачный порядок. По правилам игры обезьяна могла бы с легкостью ходить туда-сюда, даже не касаясь ящика, или бесцельно двигать ящик в разные стороны. Как будет видно из следующего раздела, более тщательное исследование обнаруживает, что порядок предложений в нашей программе является, на самом деле, критическим моментом для успешного решения задачи.</p>
     <image l:href="#_27.png"/>
     <p><strong>Рис. 2.15.</strong>  Поиск банана обезьяной. Перебор начинается в верхнем узле и распространяется вниз, как показано. Альтернативные ходы перебираются слева направо. Возврат произошел только один раз.</p>
    </section>
    <section>
     <title>
      <p>2.6. Порядок предложений и целей </p>
     </title>
     <section>
      <title>
       <p>2.6.1. Опасность бесконечного цикла</p>
      </title>
      <p>Рассмотрим следующее предложение:</p>
      <p><code>p :- p.</code></p>
      <p>В нем говорится: "p истинно, если p истинно". С точки зрения декларативного смысла это совершенно корректно, однако в процедурном смысле оно бесполезно. Более того, для пролог-системы такое предложение может породить серьезную проблему. Рассмотрим вопрос:</p>
      <p><code>?-  p.</code></p>
      <p>При использовании вышеприведенного предложения цель p будет заменена на ту же самую цель p; она в свою очередь будет заменена снова на p и т.д. В этом случае система войдет в бесконечный цикл, не замечая, что никакого продвижения в вычислениях не происходит.</p>
      <p>Данный пример демонстрирует простой способ ввести пролог-систему в бесконечный цикл. Однако подобное зацикливание могло встретиться и в некоторых наших предыдущих программах, если бы мы изменили порядок предложений, или же порядок целей в них. Будет полезно рассмотреть несколько примеров.</p>
      <p>В программе об обезьяне и банане предложения, касающиеся отношения <code>ход</code>, были упорядочены следующим образом: схватить, залезть, подвинуть, перейти (возможно, для полноты следует добавить еще "слезть"). В этих предложениях говорится, что можно схватить, можно залезть и т.д. В соответствии с процедурной семантикой Пролога порядок предложений указывает на то, что обезьяна предпочитает схватывание залезанию, залезание — передвиганию и т.д. Такой порядок предпочтений на самом деле помогает обезьяне решить задачу. Но что могло случиться. если бы этот порядок был другим? Предположим, что предложение с "перейти" оказалось бы первым. Процесс вычисления нашей исходной цели из предыдущего раздела</p>
      <p><code>?- можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).</code></p>
      <p>протекал бы на этот раз так. Первые четыре списка целей (с соответствующим образом переименованными переменными) остались бы такими же, как и раньше:</p>
      <p>(1)<code> можетзавладеть( состояние( удвери, наполу, уокна, неимеет) ).</code></p>
      <p>Применение второго предложения из <code>можетзавладеть</code> ("может2") породило бы</p>
      <p>(2)<code> ход( состояние( удвери, наполу, уокна, неимеет), М', S2'),</code> </p>
      <p><code>  можетзавладеть( S2')</code></p>
      <p>С помощью хода <code>перейти( уокна, Р2')</code> получилось бы</p>
      <p>(3)<code> можетзавладеть( состояние( Р2', наполу, уокна, неимеет) )</code></p>
      <p>Повторное использование предложения "может2" превратило бы список целей в</p>
      <p>(4)<code> ход( состояние(Р2', наполу, уокна, неимеет), М'', S2''),</code></p>
      <p><code>  можетзавладеть( S2'')</code></p>
      <p>С этого момента начались бы отличия. Первым предложением, голова которого сопоставима с первой целью из этого списка, было бы теперь "перейти" (а не "залезть", как раньше). Конкретизация стала бы следующей:</p>
      <p><code>S2'' = состояние( Р2'', наполу, уокна, неимеет).</code></p>
      <p>Поэтому список целей стал бы таким:</p>
      <p>(5)<code> можетзавладеть( состояние( Р2'', наполу, уокна, неимеет) )</code></p>
      <p>Применение предложения "может2" дало бы</p>
      <p>(6)<code> ход( cocтояниe( P2'', наполу, yoкнa, неимeeт), M''', S2'''),</code></p>
      <p><code>                можетзавладеть( S2''')</code></p>
      <p>Снова первый было бы попробовано "перейти" и получилось бы</p>
      <p>(7)<code> можетзавладеть( состояние( Р2''', наполу, уокна, неимеет) )</code></p>
      <p>Сравним теперь цели (3), (5) и (7). Они похожи и отличаются лишь одной переменной, которая по очереди имела имена Р', Р''  и P'''.  Как мы знаем, успешность цели не зависит от конкретных имен переменных в ней. Это означает, что, начиная со списка целей (3), процесс вычислений никуда не продвинулся. Фактически мы замечаем, что по очереди многократно используются одни и те же два предложения: "может2" и "перейти". Обезьяна перемещается, даже не пытаясь воспользоваться ящиком. Поскольку продвижения нет, такая ситуация продолжалась бы (теоретически) бесконечно: пролог-система не сумела бы осознать, что работать в этой направлении нет смысла.</p>
      <p>Данный пример показывает, как пролог-система может пытаться решить задачу таким способом, при котором решение никогда не будет достигнуто, хотя оно существует. Такая ситуация не является редкостью при программировании на Прологе. Да и при программировании на других языках бесконечные циклы не такая уж редкость. Что <emphasis>действительно</emphasis> необычно при сравнении Пролога с другими языками, так это то, что декларативная семантика пролог-программы может быть правильной, но в то же самое время ее процедурная семантика может быть ошибочной в том смысле, что с помощью такой программы нельзя получить правильный ответ на вопрос. В таких случаях система не способна достичь цели потому, что она пытается добраться до ответа, но выбирает при этом неверный путь.</p>
      <p>Теперь уместно спросить: "Не можем ли мы внести какое-либо более существенное изменение в нашу программу, так чтобы полностью исключить опасность зацикливания? Или же нам всегда придется рассчитывать на удачный порядок предложений и целей?" Как оказывается, программы, в особенности большие, были бы чересчур ненадежными, если бы можно было рассчитывать лишь на некоторый удачный порядок. Существует несколько других методов, позволяющих избежать зацикливания и являющихся более общими и надежными, чем сам по себе метод упорядочивания. Такие методы будут систематически использоваться дальше в книге, в особенности в тех главах, в которых пойдет речь о нахождении путей (в графах), о решения интеллектуальных задач и о переборе.</p>
     </section>
     <section>
      <title>
       <p>2.6.2. Варианты программы, полученые путем переупорядочивания предложений и целей</p>
      </title>
      <p>Уже в примерах программ гл. 1 существовала скрытая опасность зацикливания. Определение отношения <code>предок</code> в этой главе было таким:</p>
      <p><code>предок( X, Z) :-</code></p>
      <p><code> родитель( X, Z).</code></p>
      <empty-line/>
      <p><code>предок( X, Z) :-</code></p>
      <p><code> родитель( X, Y),</code></p>
      <p><code> предок( Y, Z).</code></p>
      <p>Проанализируем некоторые варианты этой программы. Ясно, что все варианты будут иметь одинаковую декларативную семантику, но разные процедурные семантики.</p>
      <p>В соответствии с декларативной семантикой Пролога мы можем, не меняя декларативного смысла, изменить</p>
      <p>(1) порядок предложений в программе и</p>
      <p>(2) порядок целей в телах предложений.</p>
      <p>Процедура <code>предок</code> состоит из двух предложений, и одно из них содержит в своем теле две цели. Возможны, поэтому, четыре варианта данной программы, все с одинаковым декларативным смыслом. Эти четыре варианта можно получить, если</p>
      <p>(1) поменять местами оба предложения и</p>
      <p>(2) поменять местами цели в каждом из этих двух последовательностей предложений.</p>
      <p>Соответствующие процедуры, названные <code>пред1</code>, <code>пред2</code>, <code>пред3</code> и <code>пред4</code>, показаны на рис. 2.16.</p>
      <p>Есть существенная разница в поведении этих четырех декларативно эквивалентных процедур. Чтобы это продемонстрировать, будем считать, отношение <code>родитель</code> определенным так, как показано на рис. 1.1 гл. 1. и посмотрим, что произойдет, если мы спросим, является ли Том предком Пат, используя все четыре варианта отношения <code>предок</code>:</p>
      <p><code>?- пред1( том, пат).</code></p>
      <p><code>да</code></p>
      <empty-line/>
      <p><code>?- пред2( том, пат).</code></p>
      <p><code>да</code></p>
      <empty-line/>
      <p><code>?- пред3( том, пат).</code></p>
      <p><code>да</code></p>
      <empty-line/>
      <p><code>?- пред4( том, пат).</code></p>
      <empty-line/>
      <p><code>% Четыре версии программы предок</code></p>
      <empty-line/>
      <p><code>% Исходная версия</code></p>
      <p><code>пред1( X, Z) :-</code></p>
      <p><code> родитель( X, Z).</code></p>
      <p><code>пред1( X, Z) :-</code></p>
      <p><code> родитель( X, Y),</code></p>
      <p><code> пред1( Y, Z).</code></p>
      <empty-line/>
      <p><code>% Вариант  а:  изменение порядка предложений в исходной версии</code></p>
      <p><code>пред2( X, Z) :-</code></p>
      <p><code> родитель( X, Y),</code></p>
      <p><code> пред2( Y, Z).</code></p>
      <p><code>пред2( X, Z) :-</code></p>
      <p><code> родитель( X, Z).</code></p>
      <empty-line/>
      <p><code>% Вариант  b:  изменение порядка целей во втором предложении</code></p>
      <p><code>% исходной версии</code></p>
      <p><code>пред3( X, Z) :-</code></p>
      <p><code> родитель( X, Z).</code></p>
      <p><code>пред3( X, Z) :-</code></p>
      <p><code> пред3( X, Y),</code></p>
      <p><code> родитель( Y, Z).</code></p>
      <empty-line/>
      <p><code>% Вариант  с:  изменение порядка предложений и целей в исходной</code></p>
      <p><code>% версии</code></p>
      <p><code>пред4( X, Z) :-</code></p>
      <p><code> пред4( X, Y),</code></p>
      <p><code> родитель( Y, Z).</code></p>
      <p><code>пред4( X, Z):-</code></p>
      <p><code> родитель( X, Z).</code></p>
      <p><strong>Рис. 2.16.</strong>  Четыре версии программы <code>предок</code>.</p>
      <empty-line/>
      <p>В последнем случае пролог-система не сможет найти ответа. И выведет на терминал сообщение: "Не хватает памяти".</p>
      <p>На рис. 1.11 гл. 1 были показаны все шаги вычислений по <code>пред1</code> (в главе 1 она называлась <code>предок</code>), предпринятые для ответа на этот вопрос. На рис 2.17 показаны соответствующие вычисления по <code>пред2</code>, <code>пред3</code> и <code>пред4</code>. На рис. 2.17 (с) ясно видно, что работа <code>пред4</code> — бесперспективна, а рис. 2.17(а) показывает, что <code>пред2</code> довольно неэффективна по сравнению с <code>пред1</code>: <code>пред2</code> производит значительно больший перебор и делает больше возвратов по фамильному дереву.</p>
      <p>Такое сравнение должно напомнить нам об общем практическом правиле при решении задач: обычно бывает полезным прежде всего попробовать самое простое соображение. В нашем случае все версии отношения <code>предок</code> основаны на двух соображениях:</p>
      <p>• более простое — нужно проверить, не удовлетворяют ли два аргумента отношения <code>предок</code> отношению <code>родитель</code>;</p>
      <p>• более сложное — найти кого-либо "между" этими двумя людьми (кого-либо, кто связан с ними отношениями <code>родитель</code> и <code>предок</code>).</p>
      <p>Из всех четырех вариантов отношения <code>предок</code>, <code>пред1</code> использует наиболее простое соображение в первую очередь. В противоположность этому <code>пред4</code> всегда сначала пробует использовать самое сложное. <code>Пред2</code> и <code>пред3</code> находятся между этими двумя крайностями. Даже без детального изучения процессов вычислений ясно, что <code>пред1</code> следует предпочесть просто на основании правила "самое простое пробуй в первую очередь".</p>
      <p>Наши четыре варианта процедуры <code>предок</code> можно далее сравнить, рассмотрев вопрос: "На какие типы вопросов может отвечать тот или иной конкретный вариант и на какие не может?" Оказывается, <code>пред1</code> и <code>пред2</code> оба способны найти ответ на любой вид вопроса относительно предков; <code>пред4</code> никогда не находит ответа, а <code>пред3</code> иногда может найти, иногда нет. Вот пример вопроса, на который <code>пред4</code> ответить не может:</p>
      <p><code>?- пред3( лиз, джим).</code></p>
      <p>Такой вопрос тоже вводит систему в бесконечную рекурсию. Следовательно и <code>пред3</code> нельзя признать верным с точки зрения процедурного смысла.</p>
      <image l:href="#_281.png"/>
      <image l:href="#_282.png"/>
      <p><strong>Рис. 2.17.</strong> Поведение трех вариантов формулировки отношения <code>предок</code> при ответе на вопрос, является ли Том предком Пат?</p>
     </section>
     <section>
      <title>
       <p>2.6.3. Сочетание декларативного и процедурного подходов</p>
      </title>
      <p>В предыдущем разделе было показано, что порядок целей и предложений имеет существенное значение. Более того, существуют программы, которые верны в декларативном смысле, но на практике не работают. Такое противоречие между декларативным и процедурным смыслами может вызвать недовольство. Кто-нибудь спросит: "А почему вообще не забыть о декларативном смысле?" Такое пожелание становится особенно сильным, когда рассматриваются предложения типа:</p>
      <p><code>предок( X, Z) :- предок( X, Z).</code></p>
      <p>Это предложение верно в декларативном смысле, но совершенно бесполезно в качестве рабочей программы.</p>
      <p>Причина, по которой не следует забывать о декларативном смысле, кроется в том, что прогресс, достигнутый в технологии программирования, получен на пути продвижения от учета всех процедурных деталей к концентрации внимания на декларативных аспектах, которые обычно легче формулировать и понимать. Сама система, а не программист, должна нести бремя заботы о процедурных деталях. В этом Пролог оказывает некоторую помощь, хотя, как мы видели в данном разделе, помощь лишь частичную: иногда он правильно прорабатывает эти процедурные детали, иногда — нет. Многие придерживаются мнения, что лучше иметь хоть какую-то декларативную семантику, чем никакой (отсутствие декларативной семантики характерно для многих других языков программирования). Практическим следствием такого взгляда является тот факт, что часто довольно легко получить работающую программу, имея программу декларативно корректную. Поэтому практичным следует признать такой подход: сосредоточиться на декларативных аспектах задачи, затем пропустить на машине полученную программу и, если она окажется процедурно неправильной, попытаться изменить порядок следования предложений и целей. </p>
     </section>
    </section>
    <section>
     <title>
      <p>2.7. Замечания о взаимосвязи между Прологом и логикой</p>
     </title>
     <p>Пролог восходит к математической логике, поэтому его синтаксис и семантику можно наиболее точно описать при помощи логики. Так часто и поступают при обучении этому языку. Однако такой подход к ознакомлению с Прологом предполагает знание читателем определенных понятий математической логики. С другой стороны, знание этих понятий явно необязательно для того, чтобы понять и использовать Пролог в качестве инструмента для практического программирования, а цель данной книги — научить именно этому. Для тех же читателей, которые особенно заинтересуются взаимосвязями между Прологом и логикой, мы сейчас перечислим основные из них, а также приведем некоторые подходящие источники.</p>
     <p>Синтаксис Пролога — это синтаксис предложений <emphasis>логики предикатов первого порядка</emphasis>, записанных в так называемой <emphasis>форме предложений</emphasis> (форме, при которой кванторы не выписываются явно), а точнее, в виде частного случая таких предложений — в виде <emphasis>формул Хорна </emphasis>(предложений, имеющих самое большее один положительный литерал). Клоксин и Меллиш (1981 г.) приводят пролог-программу, которая преобразует предложения исчисления предикатов первого порядка в форму предложений. Процедурный смысл Пролога основывается на <emphasis>принципе резолюций</emphasis>, применяющемся для автоматического доказательства теорем, который был предложен Робинсоном в его классической статье (1965 г.). В Прологе используется особая стратегия доказательства теоремы методом резолюций, носящая название SLD. Введение в исчисление предикатов первого порядка и доказательство теорем, основанное на методе резолюций, можно найти у Нильсона (1981 г.). Математические вопросы, касающиеся свойств процедурной семантики Пролога в их связи с логикой, проанализированы Ллойдом (1984 г.).</p>
     <p>Сопоставление в Прологе соответствует некоторому действию в логике, называемому <emphasis>унификацией</emphasis>. Мы, однако, избегаем слова "унификация", так как по соображениям эффективности внести в большинстве пролог-систем сопоставление реализовано таким образом, что оно не полностью соответствует унификации (см. упражнение 2.10). Тем не менее, с практической точки зрения, такая приближенная унификация вполне допустима.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>2.10.</strong> Что будет, если пролог-системе задать такой вопрос:</p>
     <p><code>?- X = f( X).</code></p>
     <p>Успешным или неуспешным будет здесь сопоставление? По определению унификации в логике, сопоставление должно быть неуспешным, а что будет в соответствии с нашим определением сопоставления из раздела 2.2? Попробуйте объяснить, почему многие реализации Пролога отвечают на вышеприведенный вопрос так:</p>
     <p><code>X = f(f(f(f(f(f(f(f(f(f(f(f(f(f(f( ...</code></p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>К настоящему моменту мы изучили нечто вроде базового Пролога, который называют еще "чистый Пролог". Он "чист", потому что довольно точно соответствует формальной логике. Расширения, преследующие цель приспособить язык к некоторым практическим нуждам, будут изучены дальше (гл. 3, 5, 6. 7). Важными моментами данной главы являются следующие:</p>
     <p>• Простые объекты в Прологе — это <emphasis>атомы</emphasis>, <emphasis>переменные</emphasis> и <emphasis>числа</emphasis>. Структурные объекты, или <emphasis>структуры</emphasis>, используются для представления объектов, которые состоят из нескольких компонент.</p>
     <p>• Структуры строятся посредством <emphasis>функторов</emphasis>. Каждый функтор определяется своими именем и арностью.</p>
     <p>• Тип объекта распознается исключительно по его синтаксической форме.</p>
     <p>• <emphasis>Область известности (лексический диапазон)</emphasis> переменных — одно предложение. Поэтому одно и то же имя в двух предложениях обозначает две разные переменные.</p>
     <p>• Структуры могут быть естественным образом изображены в виде деревьев. Пролог можно рассматривать как язык обработки деревьев.</p>
     <p>• Операция <emphasis>сопоставление</emphasis> берет два терма и пытается сделать их идентичными, подбирая соответствующую конкретизацию переменных в обоих термах.</p>
     <p>• Сопоставление, если оно завершается успешно, в качестве результата выдает <emphasis>наиболее общую</emphasis> конкретизацию переменных.</p>
     <p>• <emphasis>Декларативная семантика</emphasis> Пролога определяет, является ли целевое утверждение истинным, исходя из данной программы, и если оно истинно, то для какой конкретизации переменных.</p>
     <p>• Запятая между целями означает их конъюнкцию. Точка с запятой между целями означает их дизъюнкцию.</p>
     <p>• <emphasis>Процедурная семантика</emphasis> Пролога — это процедура достижения списка целей в контексте данной программы. Процедура выдает истинность или ложность списка целей и соответствующую конкретизацию переменных. Процедура осуществляет автоматический возврат для перебора различных вариантов.</p>
     <p>• Декларативный смысл программ на "чистом Прологе" не зависит от порядка предложений и от порядка целей в предложениях.</p>
     <p>• Процедурный смысл существенно зависит от порядка целей и предложений. Поэтому порядок может повлиять на эффективность программы; неудачный порядок может даже привести к бесконечным рекурсивным вызовам.</p>
     <p>• Имея декларативно правильную программу, можно улучшить ее эффективность путем изменения порядка предложений и целей при сохранении ее декларативной правильности. Переупорядочивание — один из методов предотвращения зацикливания.</p>
     <p>• Кроме переупорядочивания существуют и другие, более общие методы предотвращения зацикливания, способствующие получению процедурно правильных программ.</p>
     <p>• В данной главе обсуждались следующие понятия:</p>
     <p>  объекты данных:</p>
     <p>     атом, число, переменная, структура</p>
     <p>  терм</p>
     <p>  функтор, арность функтора</p>
     <p>  главный функтор терма</p>
     <p>  сопоставление термов</p>
     <p>  наиболее общая конкретизация</p>
     <p>  декларативная семантика</p>
     <p>  конкретизация предложений,</p>
     <p>    вариант предложения</p>
     <p>  процедурная семантика</p>
     <p>  вычисление целевого утверждения</p>
     <subtitle>Литература</subtitle>
     <p>Clocksin W. F. and Mellish С. S. (1981). <emphasis>Programming in Prolog.</emphasis> Springer-Verlag. [Имеется перевод: Клоксин У., Меллиш К. Программирование на языке Пролог. — М.: Мир, 1987.]</p>
     <p>Lloyd J. W. (1984). <emphasis>Foundations of Logic Programming.</emphasis> Springer-Verlag.</p>
     <p>Nilsson N. J. (1981). <emphasis>Principies of Artificial Intelligence.</emphasis> Tioga; Springer-Verlag.</p>
     <p>Robinson A. J. (1965). <emphasis>A machine-oriented logic based on the resolution principle. JACM </emphasis><strong>12:</strong> 23-41. [Имеется перевод: Робинсон Дж. Машинно-ориентированная логика, основанная на принципе резолюции. — В кн. Кибернетический сборник, вып. 7, 1970, с. 194–218.] </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 3</p>
     <p>Списки, операторы, арифметика</p>
    </title>
    <section>
     <p>В этой главе мы будем изучать специальные способы представления списков. Список - один из самых простых и полезных типов структур. Мы рассмотрим также некоторые программы для выполнения типовых операций над списками и, кроме того, покажем, как можно просто записывать арифметические выражения и операторы, что во многих случаях позволит улучшить "читабельность" программ. Базовый Пролог (глава 2), расширенный этими тремя добавлениями, станет удобной основой для составления интересных программ.</p>
    </section>
    <section>
     <title>
      <p>3.1. Представление списков</p>
     </title>
     <p><emphasis>Список</emphasis> — это простая структура данных, широко используемая в нечисловом программировании. Список — это последовательность, составленная из произвольного числа элементов, например <code>энн</code><strong>, </strong><code>теннис</code><strong>, </strong><code>том</code><strong>, </strong><code>лыжи</code>. На Прологе это записывается так:</p>
     <p><code>[ энн, теннис, том, лыжи ]</code></p>
     <p>Однако таково лишь внешнее представление списков. Как мы уже видели в гл. 2, все структурные объекты Пролога — это деревья. Списки не являются исключением из этого правила.</p>
     <p>Каким образом можно представить список в виде стандартного прологовского объекта? Мы должны рассмотреть два случая: пустой список и не пустой список. В первом случае список записывается как атом  <code>[]</code>.  Во втором случае список следует рассматривать как структуру состоящую из двух частей:</p>
     <p>(1) первый элемент, называемый <emphasis>головой</emphasis> списка;</p>
     <p>(2) остальная часть списка, называемая <emphasis>хвостом</emphasis>.</p>
     <p>Например, для списка</p>
     <p><code>[ энн, теннис, том, лыжи ]</code></p>
     <p><code>энн</code> — это голова, а хвостом является список</p>
     <p><code>[ теннис, том, лыжи ]</code></p>
     <p>В общем случае, головой может быть что угодно (любой прологовский объект, например, дерево или переменная); хвост же должен быть списком. Голова соединяется с хвостом при помощи специального функтора. Выбор этого функтора зависит от конкретной реализации Пролога; мы будем считать, что это точка:</p>
     <p><code>.( Голова, Хвост)</code></p>
     <p>Поскольку <code>Хвост</code> — это список, он либо пуст, либо имеет свои собственную голову и хвост. Таким образом, выбранного способа представления списков достаточно для представления списков любой длины. Наш список представляется следующим образом:</p>
     <p><code>.( энн, .( теннис, .( том, .( лыжи, [] ) ) ) )</code></p>
     <p>На рис. 3.1 изображена соответствующая древовидная структура. Заметим, что показанный выше пример содержит пустой список <code>[]</code>. Дело в том, что самый последний хвост является одноэлементным списком:</p>
     <p><code>[ лыжи ]</code></p>
     <p>Хвост этого списка пуст</p>
     <p><code>[ лыжи ] = .( лыжи, [] )</code></p>
     <p>Рассмотренный пример показывает, как общий принцип структуризации объектов данных можно применить к спискам любой длины. Из нашего примера также видно, что такой примитивный способ представления в случае большой глубины вложенности подэлементов в хвостовой части списка может привести к довольно запутанным выражениям. Вот почему в Прологе предусматривается более лаконичный способ изображения списков, при котором они записываются как последовательности элементов, заключенные в квадратные скобки. Программист может использовать оба способа, но представление с квадратными скобками, конечно, в большинстве случаев пользуется предпочтением. Мы, однако, всегда будем помнить, что это всего лишь косметическое улучшение и что во внутреннем представлении наши списки выглядят как деревья. При выводе же они автоматически преобразуются в более лаконичную форму представления. Так, например, возможен следующий диалог:</p>
     <p><code>?- Список1 = [а, b, с],</code></p>
     <p><code> Список2 = (a, .(b, .(c,[]) ) ).</code></p>
     <empty-line/>
     <p><code>Список1 = [а, b, с]</code></p>
     <p><code>Список2 = [а, b, с]</code></p>
     <empty-line/>
     <p><code>?- Увлечения1 = .( теннис, .(музыка, [] ) ),</code></p>
     <p><code> Увлечения2 = [лыжи, еда],</code></p>
     <p><code> L = [энн, Увлечения1, том, Увлечения2].</code></p>
     <empty-line/>
     <p><code>Увлечения1 = [теннис, музыка]</code></p>
     <p><code>Увлечения2 = [лыжи, еда]</code></p>
     <p><code>L = [энн, [теннис, музыка], том, [лыжи, еда]]</code></p>
     <image l:href="#_29.png"/>
     <p><strong>Рис. 3.1.</strong> Представление списка <code>[энн, теннис, том, лыжи]</code> в виде дерева.</p>
     <p>Приведенный пример также напоминает вам о том, что элементами списка могут быть любые объекты, в частности тоже списки.</p>
     <p>На практике часто бывает удобным трактовать хвост списка как самостоятельный объект. Например, пусть</p>
     <p><code>L = [а, b, с]</code></p>
     <p>Тогда можно написать:</p>
     <p><code>Хвост = [b, с]</code> и <code>L = .(а, Хвост)</code></p>
     <p>Для того, чтобы выразить это при помощи квадратных скобок, в Прологе предусмотрено еще одно расширение нотации для представления списка, а именно вертикальная черта, отделяющая голову от хвоста:</p>
     <p><code>L = [а | Хвост]</code></p>
     <p>На самом деле вертикальная черта имеет более общий смысл: мы можем перечислить любое количество элементов списка, затем поставить символ "<code>|</code>", а после этого — список остальных элементов. Так, только что рассмотренный пример можно представить следующими различными способами:</p>
     <p><code>[а, b, с] = [а | [b, с]] = [a, b | [c]] = [a, b, c | [ ]]</code></p>
     <p>Подытожим:</p>
     <p>• Список — это структура данных, которая либо пуста, либо состоит из двух частей: <emphasis>головы</emphasis> и <emphasis>хвоста</emphasis>. Хвост в свою очередь сам является списком.</p>
     <p>• Список рассматривается в Прологе как специальный частный случай двоичного дерева. Для повышения наглядности программ в Прологе предусматриваются специальные средства для списковой нотации, позволяющие представлять списки в виде</p>
     <p><code>[ Элемент1, Элемент2, ... ]</code></p>
     <p>или</p>
     <p><code>[ Голова | Хвост ]</code></p>
     <p>или</p>
     <p><code>[ Элемент1, Элемент2, ... | Остальные]</code></p>
    </section>
    <section>
     <title>
      <p>3.2. Некоторые операции над списками</p>
     </title>
     <section>
      <p>Списки можно применять для представления множеств, хотя и существует некоторое различие между этими понятиями: порядок элементов множества не существенен, в то время как для списка этот порядок имеет значение; кроме того, один н тот же объект может встретиться в списке несколько раз. Однако наиболее часто используемые операции над списками аналогичны операциям над множествами. Среди них</p>
      <p>• проверка, является ли некоторый объект элементом списка, что соответствует проверке объекта на принадлежность множеству;</p>
      <p>• конкатенация (сцепление) двух списков, что соответствует объединению множеств;</p>
      <p>• добавление нового объекта в список или удаление некоторого объекта из него.</p>
      <p>В оставшейся части раздела мы покажем программы, реализующие эти и некоторые другие операции над списками.</p>
     </section>
     <section>
      <title>
       <p>3.2.1. Принадлежность к списку</p>
      </title>
      <p>Мы представим отношение принадлежности как</p>
      <p><code>принадлежит( X, L)</code></p>
      <p>где X — объект, а L — список. Цель <code>принадлежит( X, L)</code> истинна, если элемент X встречается в L. Например, верно что</p>
      <p><code>принадлежит( b, [а, b, с] )</code></p>
      <p>и, наоборот, не верно, что</p>
      <p><code>принадлежит b, [а, [b, с] ] )</code></p>
      <p>но</p>
      <p><code>принадлежит [b, с], [а, [b, с]] )</code></p>
      <p>истинно. Составление программы для отношения принадлежности может быть основано на следующих соображениях:</p>
      <p>(1) X есть голова L, либо</p>
      <p>(2) X принадлежит хвосту L.</p>
      <p>Это можно записать в виде двух предложений, первое из которых есть простой факт, а второе — правило:</p>
      <p><code>принадлежит( X, [X | Хвост ] ).</code></p>
      <empty-line/>
      <p><code>принадлежит ( X, [Голова | Хвост ] ) :-</code></p>
      <p><code> принадлежит( X, Хвост).</code></p>
     </section>
     <section>
      <title>
       <p>3.2.2. Сцепление (конкатенация)</p>
      </title>
      <p>Для сцепления списков мы определим отношение</p>
      <p><code>конк( L1, L2, L3)</code></p>
      <p>Здесь L1 и L2 — два списка, a L3 — список, получаемый при их сцеплении. Например,</p>
      <p><code>конк( [а, b], [c, d], [a, b, c, d] )</code></p>
      <p>истинно, а</p>
      <p><code>конк( [а, b], [c, d], [a, b, a, c, d] )</code></p>
      <p>ложно. Определение отношения <code>конк</code>, как и раньше, содержит два случая в зависимости от вида первого аргумента L1:</p>
      <p>(1) Если первый аргумент пуст, тогда второй и третий аргументы представляют собой один и тот же список (назовем его L), что выражается в виде следующего прологовского факта:</p>
      <p><code>конк( [], L, L ).</code></p>
      <p>(2) Если первый аргумент отношения <code>конк</code> не пуст, то он имеет голову и хвост в выглядит так:</p>
      <p><code>[X | L1]</code></p>
      <p>На рис. 3.2 показано, как производится сцепление списка <code>[X | L1]</code> с произвольным списком L2. Результат сцепления — список <code>[X | L3]</code>, где L3 получен после сцепления списков L1 и L2. На прологе это можно записать следующим образом:</p>
      <p><code>конк( [X | L1, L2, [X | L3]):-</code></p>
      <p><code> конк( L1, L2, L3).</code></p>
      <image l:href="#_30.png"/>
      <p><strong>Рис. 3.2.</strong> Конкатенация списков.</p>
      <p>Составленную программу можно теперь использовать для сцепления заданных списков, например:</p>
      <p><code>?- конк( [a, b, с], [1, 2, 3], L ).</code></p>
      <p><code>L = [a, b, c, 1, 2, 3]</code></p>
      <empty-line/>
      <p><code>?- конк( [а, [b, с], d], [а, [], b], L ).</code></p>
      <p><code>L = [a, [b, c], d, а, [], b]</code></p>
      <p>Хотя программа для <code>конк</code> выглядит довольно просто, она обладает большой гибкостью и ее можно использовать многими другими способами. Например, ее можно применять как бы в обратном направлении для <emphasis>разбиения</emphasis> заданного списка на две части:</p>
      <p><code>?- конк( L1, L2, [а, b, с] ).</code></p>
      <empty-line/>
      <p><code>L1 = []</code></p>
      <p><code>L2 = [а, b, c];</code></p>
      <empty-line/>
      <p><code>L1 = [а]</code></p>
      <p><code>L2 = [b, с];</code></p>
      <empty-line/>
      <p><code>L1 = [а, b]</code></p>
      <p><code>L2 = [c];</code></p>
      <empty-line/>
      <p><code>L1 = [а, b, с]</code></p>
      <p><code>L2 = [];</code></p>
      <p><code>no            </code>(нет)</p>
      <p>Список <code>[а, b, с]</code> разбивается на два списка четырьмя способами, и все они были обнаружены нашей программой при помощи механизма автоматического перебора.</p>
      <p>Нашу программу можно также применить для поиска в списке комбинации элементов, отвечающей некоторому условию, задаваемому в виде шаблона или образца. Например, можно найти все месяцы, предшествующие данному, и все месяцы, следующие за ним, сформулировав такую цель:</p>
      <p><code>?- конк( До, [май | После ],</code></p>
      <p><code> [янв, фев, март, апр, май, июнь,</code></p>
      <p><code>  июль, авг, сент, окт, ноябрь, дек]).</code></p>
      <empty-line/>
      <p><code>До = [янв, фев, март, апр]</code></p>
      <p><code>После = [июнь, июль, авг, сент, окт, ноябрь, дек].</code></p>
      <p>Далее мы сможем найти месяц, непосредственно предшествующий маю, и месяц, непосредственно следующий за ним, задав вопрос:</p>
      <p><code>?- конк( _, [Месяц1, май, Месяц2 | _ ],</code></p>
      <p><code> [янв, февр, март, апр, май, июнь,</code></p>
      <p><code>  июль, авг, сент, окт, ноябрь, дек]).</code></p>
      <empty-line/>
      <p><code>Месяц1 = апр</code></p>
      <p><code>Месяц2 = июнь</code></p>
      <p>Более того, мы сможем, например, удалить из некоторого списка L1 все, что следует за тремя последовательными вхождениями элемента z в L1 вместе с этими тремя z. Например, это можно сделать так:</p>
      <p><code>?- L1 = [a, b, z, z, c, z, z, z, d, e],</code></p>
      <p><code> конк( L2, [z, z, z | _ ], L1).</code></p>
      <empty-line/>
      <p><code>L1 = [a, b, z, z, c, z, z, z, d, e]</code></p>
      <p><code>L2 = [a, b, z, z, c]</code></p>
      <p>Мы уже запрограммировали отношение принадлежности. Однако, используя <code>конк</code>, можно было бы определить это отношение следующим эквивалентным способом:</p>
      <p><code>принадлежит1( X, L) :-</code></p>
      <p><code> конк( L1, [X | L2], L).</code></p>
      <image l:href="#_31.png"/>
      <p><strong>Рис. 3.3.</strong> Процедура <code>принадлежит1</code> находит элемент в заданном списке, производя по нему последовательный поиск.</p>
      <p>В этом предложении сказано: "X принадлежит L, если список L можно разбить на два списка таким образом, чтобы элемент X являлся головой второго из них. Разумеется, <code>принадлежит1</code> определяет то же самое отношение, что и <code>принадлежит</code>. Мы использовали другое имя только для того, чтобы различать таким образом две разные реализации этого отношения, Заметим, что, используя анонимную переменную, можно записать вышеприведенное предложение так:</p>
      <p><code>принадлежит1( X, L) :-</code></p>
      <p><code> конк( _, [X | _ ], L).</code></p>
      <p>Интересно сравнить между собой эти две реализации отношения принадлежности. <code>Принадлежит</code> имеет довольно очевидный процедурный смысл:</p>
      <p> Для проверки, является ли X элементом списка L, нужно</p>
      <p> (1) сначала проверить, не совпадает ли голова списка L с X, а затем</p>
      <p> (2) проверить, не принадлежит ли X хвосту списка L.</p>
      <p>С другой стороны, <code>принадлежит1</code>, наоборот, имеет очевидный декларативный смысл, но его процедурный смысл не столь очевиден.</p>
      <p>Интересным упражнением было бы следующее: выяснить, как в действительности <code>принадлежит1</code> что-либо вычисляет. Некоторое представление об этом мы получим, рассмотрев запись всех шагов вычисления ответа на вопрос:</p>
      <p><code>?-  принадлежит1( b, [а, b, с] ).</code></p>
      <p>На рис. 3.3 приведена эта запись. Из нее можно заключить, что <code>принадлежит1</code> ведет себя точно так же, как и <code>принадлежит</code>. Он просматривает список элемент за элементом до тех пор, пока не найдет нужный или пока не кончится список.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>3.1.</strong> (а) Используя отношение <code>конк</code>, напишите цель, соответствующую вычеркиванию трех последних элементов списка L, результат — новый список L1. Указание: L — конкатенация L1 и трехэлементного списка.</p>
      <p>(b) Напишите последовательность целей для порождения списка L2, получающегося из списка L вычеркиванием его трех первых и трех последних элементов.</p>
      <p><strong>3.2.</strong> Определите отношение</p>
      <p><code>последний( Элемент, Список)</code></p>
      <p>так, чтобы <code>Элемент</code> являлся последним элементом списка <code>Список</code>. Напишите два варианта определения: (а) с использованием отношения <code>конк</code>, (b) без использования этого отношения.</p>
     </section>
     <section>
      <title>
       <p>3.2.3. Добавление элемента</p>
      </title>
      <p>Наиболее простой способ добавить элемент в список — это вставить его в самое начало так, чтобы он стал его новой головой. Если X — это новый элемент, а список, в который X добавляется — L, тогда результирующий список — это просто</p>
      <p><code>[X | L]</code></p>
      <p>Таким образом, для того, чтобы добавить новый элемент в начало списка, не надо использовать никакой процедуры. Тем не менее, если мы хотим определить такую процедуру в явном виде, то ее можно представить в форме такого факта:</p>
      <p><code>добавить( X, L, [X | L] ).</code></p>
     </section>
     <section>
      <title>
       <p>3.2.4. Удаление элемента</p>
      </title>
      <p>Удаление элемента X из списка L можно запрограммировать в виде отношения</p>
      <p><code>удалить( X, L, L1)</code></p>
      <p>где L1 совпадает со списком L, у которого удален элемент X. Отношение <code>удалить</code> можно определить аналогично отношению принадлежности. Имеем снова два случая:</p>
      <p>(1) Если X является головой списка, тогда результатом удаления будет хвост этого списка.</p>
      <p>(2) Если X находится в хвосте списка, тогда его нужно удалить оттуда.</p>
      <p><code>удалить( X, [X | Хвост], Хвост).</code></p>
      <p><code>удалить( X, [Y | Хвост], [Y | Хвост1] ) :-</code></p>
      <p><code> удалить( X, Хвост, Хвост1).</code></p>
      <p>как и <code>принадлежит</code>, отношение <code>удалить</code> по природе своей недетерминировано. Если в списке встречается несколько вхождений элемента X, то <code>удалить</code> сможет исключить их все при помощи возвратов. Конечно, вычисление по каждой альтернативе будет удалять лишь одно вхождение X, оставляя остальные в неприкосновенности. Например:</p>
      <p><code>?- удалить( а, [а, b, а, а], L].</code></p>
      <empty-line/>
      <p><code>L = [b, а, а];</code></p>
      <p><code>L = [а, b, а];</code></p>
      <p><code>L = [а, b, а];</code></p>
      <p><code>no            </code>(нет)</p>
      <p>При попытке исключить элемент, не содержащийся в списке, отношение <code>удалить</code> потерпит неудачу.</p>
      <p>Отношение <code>удалить</code> можно использовать в обратном направлении для того, чтобы добавлять элементы в список, вставляя их в произвольные места. Например, если мы хотим во все возможные места списка <code>[1, 2, 3]</code> вставить атом <code>а</code>, то мы можем это сделать, задав вопрос: "Каким должен быть список L, чтобы после удаления из него элемента <code>а</code> получился список <code>[1, 2, 3]</code>?"</p>
      <p><code>?- удалить( а, L, [1, 2, 3] ).</code></p>
      <empty-line/>
      <p><code>L = [а, 1, 2, 3];</code></p>
      <p><code>L = [1, а, 2, 3];</code></p>
      <p><code>L = [1, 2, а, 3];</code></p>
      <p><code>L = [1, 2, 3, а];</code></p>
      <p><code>nо               </code>(нет)</p>
      <p>Вообще операция по внесению X в произвольное место некоторого списка <code>Список</code>, дающее в результате <code>БольшийСписок</code>, может быть определена предложением:</p>
      <p><code>внести( X, Список, БольшийСписок) :-</code></p>
      <p><code> удалить( X, БольшийСписок, Список).</code></p>
      <p>В <code>принадлежит1</code> мы изящно реализовали отношение принадлежности через <code>конк</code>. Для проверки на принадлежность можно также использовать и <code>удалить</code>. Идея простая: некоторый X принадлежит списку <code>Список</code>, если X можно из него удалить:</p>
      <p><code>принадлежит2( X, Список) :-</code></p>
      <p><code> удалить( X, Список, _ ).</code></p>
     </section>
     <section>
      <title>
       <p>3.2.5. Подсписок</p>
      </title>
      <p>Рассмотрим теперь отношение <code>подсписок</code>. Это отношение имеет два аргумента — список L и список S, такой, что S содержится в L в качестве подсписка. Так отношение</p>
      <p><code>подсписок( [c, d, e], [a, b, c, d, e, f] )</code></p>
      <p>имеет место, а отношение</p>
      <p><code>подсписок( [c, e], [a, b, c, d, e, f] )</code></p>
      <p>нет. Пролог-программа для отношения <code>подсписок</code> может основываться на той же идее, что и <code>принадлежит1</code>, только на этот раз отношение более общо (см. рис. 3.4).</p>
      <image l:href="#_32.png"/>
      <p><strong>Рис. 3.4.</strong> Отношения <code>принадлежит</code> и <code>подсписок</code>.</p>
      <p>Его можно сформулировать так:</p>
      <p> S является подсписком L, если</p>
      <p>  (1) L можно разбить на два списка L1 и L2 и</p>
      <p>  (2) L2 можно разбить на два списка S и L3.</p>
      <p>Как мы видели раньше, отношение <code>конк</code> можно использовать для разбиения списков. Поэтому вышеприведенную формулировку можно выразить на Прологе так:</p>
      <p><code>подсписок( S, L) :-</code></p>
      <p><code> конк( L1, L2, L),</code></p>
      <p><code> конк( S, L3, L2).</code></p>
      <p>Ясно, что процедуру <code>подсписок</code> можно гибко использовать различными способами. Хотя она предназначалась для проверки, является ли какой-либо список подсписком другого, ее можно использовать, например, для нахождения всех подсписков данного списка:</p>
      <p><code>?-  подсписок( S, [а, b, с] ).</code></p>
      <empty-line/>
      <p><code>S = [];</code></p>
      <p><code>S = [a];</code></p>
      <p><code>S = [а, b];</code></p>
      <p><code>S = [а, b, с];</code></p>
      <p><code>S = [b];</code></p>
      <p><code>...</code></p>
     </section>
     <section>
      <title>
       <p>3.2.6. Перестановки</p>
      </title>
      <p>Иногда бывает полезно построить все перестановки некоторого заданного списка. Для этого мы определим отношение <code>перестановка</code> с двумя аргументами. Аргументы — это два списка, один из которых является перестановкой другого. Мы намереваемся порождать перестановки списка с помощью механизма автоматического перебора, используя процедуру <code>перестановка</code>, подобно тому, как это делается в следующем примере:</p>
      <p><code>?- перестановка( [а, b, с], P).</code></p>
      <empty-line/>
      <p><code>P = [а, b, с];</code></p>
      <p><code>P = [а, с, b];</code></p>
      <p><code>P = [b, а, с];</code></p>
      <p><code>...</code></p>
      <image l:href="#_33.png"/>
      <p><strong>Рис. 3.5.</strong> Один из способов построения перестановки списка <code>[X | L]</code>.</p>
      <p>Программа для отношения <code>перестановка</code> в свою очередь опять может основываться на рассмотрении двух случаев в зависимости от вида первого списка:</p>
      <p>(1) Если первый список пуст, то и второй список должен быть пустым.</p>
      <p>(2) Если первый список не пуст, тогда он имеет вид <code>[X | L]</code>, и перестановку такого списка можно построить так, как это показано на рис. 3.5: вначале получить список L1 — перестановку L, а затем внести X в произвольную позицию L1.</p>
      <p>Два прологовских предложения, соответствующих этим двум случаям, таковы:</p>
      <p><code>перестановка( [], []).</code></p>
      <p><code>перестановка( [X | L ], P) :-</code></p>
      <p><code> перестановка( L, L1),</code></p>
      <p><code> внести( X, L1, P).</code></p>
      <p>Другой вариант этой программы мог бы предусматривать удаление элемента X из первого списка, перестановку оставшейся его части — получение списка P, а затем добавление X в начало списка P. Соответствующая программа такова:</p>
      <p><code>перестановка2( [], []).</code></p>
      <p><code>перестановка2( L, [X | P] ) :-</code></p>
      <p><code> удалить( X, L, L1),</code></p>
      <p><code> перестановка2( L1, P).</code></p>
      <p>Поучительно проделать несколько экспериментов с нашей программой перестановки. Ее нормальное использование могло бы быть примерно таким:</p>
      <p><code>?-  перестановка( [красный, голубой, зеленый], P).</code></p>
      <p>Как и предполагалось, будут построены все шесть перестановок:</p>
      <p><code>P = [ красный, голубой, зеленый];</code></p>
      <p><code>P = [ красный, зеленый, голубой];</code></p>
      <p><code>P = [ голубой, красный, зеленый];</code></p>
      <p><code>P = [ голубой, зеленый, красный];</code></p>
      <p><code>P = [ зеленый, красный, голубой];</code></p>
      <p><code>P = [ зеленый, голубой, красный];</code></p>
      <p><code>no                               </code>(нет)</p>
      <p>Приведем другой вариант использования процедуры <code>перестановка</code>:</p>
      <p><code>?-  перестановка( L, [а, b, с] ).</code></p>
      <p>Наша первая версия, <code>перестановка</code>, произведет успешную конкретизацию L всеми шестью перестановками. Если пользователь потребует новых решений, он никогда не получит ответ "нет", поскольку программа войдет в бесконечный цикл, пытаясь отыскать новые несуществующие перестановки. Вторая версия, <code>перестановка2</code>, в этой ситуации найдет только первую (идентичную) перестановку, а затем сразу зациклится. Следовательно, при использовании этих отношений требуется соблюдать осторожность.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>3.3.</strong> Определите два предиката</p>
      <p><code>четнаядлина( Список)</code> и <code>нечетнаядлина( Список)</code></p>
      <p>таким образом, чтобы они были истинными, если их аргументом является список четной или нечетной длины соответственно. Например, список <code>[а, b, с, d]</code> имеет четную длину, a <code>[a, b, c]</code> — нечетную.</p>
      <p><strong>3.4.</strong> Определите отношение</p>
      <p><code>обращение( Список, ОбращенныйСписок)</code>,</p>
      <p>которое обращает списки. Например,</p>
      <p><code>обращение( [a, b, c, d], [d, c, b, a] ).</code></p>
      <p><strong>3.5.</strong> Определите предикат</p>
      <p><code>палиндром( Список).</code></p>
      <p>Список называется палиндромом, если он читается одинаково, как слева направо, так и справа налево. Например, <code>[м, а, д, а, м]</code>.</p>
      <p><strong>3.6.</strong> Определите отношение</p>
      <p><code>сдвиг( Список1, Список2)</code></p>
      <p>таким образом, чтобы <code>Список2</code> представлял собой <code>Список1</code>, "циклически сдвинутый" влево на один символ. Например,</p>
      <p><code>?- сдвиг( [1, 2, 3, 4, 5], L1),</code></p>
      <p><code> сдвиг1( LI, L2)</code></p>
      <p>дает</p>
      <p><code>L1 = [2, 3, 4, 5, 1]</code></p>
      <p><code>L2 = [3, 4, 5, 1, 2]</code></p>
      <p><strong>3.7.</strong> Определите отношение</p>
      <p><code>перевод( Список1, Список2)</code></p>
      <p>для перевода списка чисел от 0 до 9 в список соответствующих слов. Например,</p>
      <p><code>перевод( [3, 5, 1, 3], [три, пять, один, три] )</code></p>
      <p>Используйте в качестве вспомогательных следующие отношения:</p>
      <p><code>означает( 0, нуль).</code></p>
      <p><code>означает( 1, один).</code></p>
      <p><code>означает( 2, два).</code></p>
      <p><code>...</code></p>
      <p><strong>3.8.</strong> Определите отношение</p>
      <p><code>подмножество( Множество, Подмножество)</code></p>
      <p>где <code>Множество</code> и <code>Подмножество</code> — два списка представляющие два множества. Желательно иметь возможность использовать это отношение не только для проверки включения одного множества в другое, но и для порождения всех возможных подмножеств заданного множества. Например:</p>
      <p><code>?-  подмножество( [а, b, с], S ).</code></p>
      <empty-line/>
      <p><code>S = [a, b, c];</code></p>
      <p><code>S = [b, c];</code></p>
      <p><code>S = [c];</code></p>
      <p><code>S = [];</code></p>
      <p><code>S = [a, c];</code></p>
      <p><code>S = [a];</code></p>
      <p><code>...</code></p>
      <p><strong>3.9.</strong> Определите отношение</p>
      <p><code>разбиениесписка( Список, Список1, Список2)</code></p>
      <p>так, чтобы оно распределяло элементы списка между двумя списками <code>Список1</code> и <code>Список2</code> и чтобы эти списки были примерно одинаковой длины. Например:</p>
      <p><code>разбиениесписка( [а, b, с, d, e], [a, с, e], [b, d]).</code></p>
      <p><strong>3.10.</strong> Перепишите программу об обезьяне и бананах из главы 2 таким образом, чтобы отношение</p>
      <p><code>можетзавладеть( Состояние, Действия)</code></p>
      <p>давало не только положительный или отрицательный ответ, но и порождало последовательность действий обезьяны, приводящую ее к успеху. Пусть <code>Действия</code> будет такой последовательностью, представленной в виде списка ходов:</p>
      <p><code>Действия = [ перейти( дверь, окно),</code></p>
      <p><code>             передвинуть( окно, середина),</code></p>
      <p><code>             залезть, схватить ]</code></p>
      <p><strong>3.11.</strong> Определите отношение</p>
      <p><code>линеаризация( Список, ЛинейныйСписок)</code></p>
      <p>где <code>Список</code> может быть списком списков, а <code>ЛинейныйСписок</code> — это тот же список, но "выровненный" таким образом, что элементы его подсписков составляют один линейный список. Например:</p>
      <p><code>?- линеаризация( [а, d, [с, d], [], [[[e]]], f, L).</code></p>
      <p><code>L = [a, b, c, d, e, f]</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>3.3. Операторная запись (нотация)</p>
     </title>
     <p>В математике мы привыкли записывать выражения в таком виде:</p>
     <p><emphasis>2*a + b*с</emphasis></p>
     <p>где + и * — это операторы, а <emphasis>2</emphasis>, <emphasis>а</emphasis>, <emphasis>b</emphasis>,<emphasis> с</emphasis> — аргументы. В частности, + и * называют <emphasis>инфиксными</emphasis> операторами, поскольку они появляются <emphasis>между</emphasis> своими аргументами. Такие выражения могут быть представлены в виде деревьев, как это сделано на рис. 3.6, и записаны как прологовские термы с + и * в качестве функторов:</p>
     <p><code>+( *( 2, а), *( b, с) )</code></p>
     <empty-line/>
     <image l:href="#_34.png"/>
     <p><strong>Рис. 3.6.</strong> Представление выражения <emphasis>2*а+b*с</emphasis> в виде дерева.</p>
     <p>Поскольку мы обычно предпочитаем записывать такие выражения в привычной инфиксной форме операторов, Пролог обеспечивает такое удобство. Поэтому наше выражение, записанное просто как</p>
     <p><code>2*а + b*с</code></p>
     <p>будет воспринято правильно. Однако это лишь внешнее представление объекта, которое будет автоматически преобразовано в обычную форму прологовских термов. Такой терм выводится пользователю снова в своей внешней инфиксной форме.</p>
     <p>Выражения рассматриваются Прологом просто как дополнительный способ записи, при котором не вводятся какие-либо новые принципы структуризации объектов данных. Если мы напишем <code>а + b</code>,  Пролог поймет эту запись, как если бы написали <code>+(а, b)</code>. Для того, чтобы Пролог правильно воспринимал выражения типа <code>а + b*с</code>, он должен знать, что <code>*</code> связывает сильнее, чем <code>+</code>. Будем говорить, что <code>+</code> имеет более низкий приоритет, чем <code>*</code>. Поэтому верная интерпретация выражений зависит от приоритетов операторов. Например, выражение <code>а + b*с</code>, в принципе можно понимать и как</p>
     <p><code>+( а, *( b, с) )</code></p>
     <p>и как</p>
     <p><code>*( +( а, b), с)</code></p>
     <p>Общее правило состоит в том, что оператор с самым низким приоритетом расценивается как главный функтор терма. Если мы хотим, чтобы выражения, содержащие <code>+</code> и <code>*</code>, понимались в соответствии с обычными соглашениями, то <code>+</code> должен иметь более низкий приоритет, чем <code>*</code>. Тогда выражение <code>а + b*с</code> означает то же, что и <code>а + (b*с)</code>. Если имеется в виду другая интерпретация, то это надо указать явно с помощью скобок, например <code>(а+b)*с</code>.</p>
     <p>Программист может вводить свои собственные операторы. Так, например, можно определить атомы <code>имеет</code> и <code>поддерживает</code> в качестве инфиксных операторов, а затем записывать в программе факты вида:</p>
     <p><code>питер имеет информацию.</code></p>
     <p><code>пол поддерживает стол.</code></p>
     <p>Эти факты в точности эквивалентны следующим:</p>
     <p><code>имеет( питер, информацию).</code></p>
     <p><code>поддерживает( пол, стол).</code></p>
     <p>Программист определяет новые операторы, вводя в программу особый вид предложений, которые иногда называют <emphasis>директивами</emphasis>. Такие предложения играют роль определений новых операторов. Определение оператора должно появиться в программе раньше, чем любое выражение, использующее этот оператор. Например, оператор имеет можно определить директивой</p>
     <p><code>:- op( 600, xfx, имеет).</code></p>
     <p>Такая запись сообщит Прологу, что мы хотим использовать "имеет" в качестве оператора с приоритетом 600 и типом '<code>xfx</code>', обозначающий одну из разновидностей инфиксного оператора. Форма спецификатора '<code>xfx</code>' указывает на то, что оператор, обозначенный через '<code>f</code>', располагается между аргументами, обозначенными через '<code>х</code>'.</p>
     <p>Обратите внимание на то, что определения операторов не содержат описания каких-либо операций или действий. В соответствии с принципами языка <emphasis>ни</emphasis> с <emphasis>одним оператором не связывается каких-либо операций над данными</emphasis> (за исключением особых, редких случаев). Операторы обычно используются так же, как и функторы, только для объединения объектов в структуры и не вызывают действия над данными, хотя само слово "оператор", казалось бы, должно подразумевать какое-то действие.</p>
     <p>Имена операторов это атомы, а их приоритеты — точнее, номера их приоритетов — должны находиться в некотором диапазоне, зависящем от реализации. Мы будем считать, что этот диапазон располагается в пределах от 1 до 1200.<a l:href="#n_1" type="note">[1]</a></p>
     <p>Существуют три группы типов операторов, обозначаемые спецификаторами, похожими на <code>xfx</code>:</p>
     <p>(1) инфиксные операторы трех типов:</p>
     <p><code>xfx xfy yfx</code></p>
     <p>(2) префиксные операторы двух типов:</p>
     <p><code>fx fy</code></p>
     <p>(3) постфиксные операторы двух типов:</p>
     <p><code>хf yf</code></p>
     <p>Спецификаторы выбраны с таким расчетом, чтобы нагляднее отразить структуру выражения, в котором '<code>f</code>' соответствует оператору, а 'x' и '<code>y</code>' представляют его аргументы. Расположение '<code>f</code>' между аргументами указывает на то, что оператор инфиксный. Префиксные и постфиксные спецификаторы содержат только один аргумент, который, соответственно, либо следует за оператором, либо предшествует ему.</p>
     <image l:href="#_35.png"/>
     <p><strong>Рис. op3.7.</strong>  Две интерпретации выражения <code>а-b-с</code> в предположении, что '<code>-</code>' имеет приоритет 500. Если тип '<code>-</code>' есть <code>yfx</code>, то интерпретация 2 неверна, так как приоритет <code>b-с</code> не выше, чем приоритет '<code>-</code>'.</p>
     <p>Между '<code>x</code>' и '<code>y</code>' есть разница. Для ее объяснения нам потребуется ввести понятие <emphasis>приоритета аргумента</emphasis>. Если аргумент заключен в скобки или не имеет структуры (является простым объектом), тогда его приоритет равен 0; если же он структурный, тогда его приоритет равен приоритету его главного функтора. С помощью '<code>x</code>' обозначается аргумент, чей приоритет должен быть строго выше приоритета оператора (т e. его номер строго меньше номера приоритета оператора); с помощью '<code>y</code>' обозначается аргумент, чей приоритет выше или равен приоритету оператора.</p>
     <p>Такие правила помогают избежать неоднозначности при обработке выражений, в которых встречаются операторы с одинаковым приоритетом. Например, выражение</p>
     <p><code>а-b-с</code></p>
     <p>обычно понимается как <code>(а-b)-с</code>, а не как <code>а-(b-с)</code>. Чтобы обеспечить такую обычную интерпретацию, оператор '<code>-</code>' следует определять как <code>yfx</code>. На рис. 3.7 показано, каким образом исключается вторая интерпретация.</p>
     <p>В качестве еще одного примера рассмотрим оператор <code>not</code> (логическое отрицание "не"). Если <code>not</code> oпределён как <code>fy</code>, тогда выражение</p>
     <p> <code>not not p</code></p>
     <p>записано верно; однако, если <code>not</code> определен как <code>fx</code>, оно некорректно, потому что аргументом первого <code>not</code> является структура <code>not p</code>, которая имеет тот же приоритет, что и <code>not</code>. В этом случае выражение следует писать со скобками:</p>
     <p><code>not (not p)</code></p>
     <empty-line/>
     <p><code>:- op( 1200, xfx, ':-').</code></p>
     <p><code>:- op( 1200, fx, [:-, ?-] ).</code></p>
     <p><code>:- op( 1100, xfy, ';').</code></p>
     <p><code>:- op( 1000, xfy, ',').</code></p>
     <p><code>:- op( 700, xfx, [=, is, &lt;, &gt;, =&lt;, &gt;=, ==, =\=, \==, =:=]).</code></p>
     <p><code>:- op( 500, yfx, [+, -] ).</code></p>
     <p><code>:- op( 500, fx, [+, -, not] ).</code></p>
     <p><code>:- op( 400, yfx, [*, /, div] ).</code></p>
     <p><code>:- op( 300, xfx, mod).</code></p>
     <p><strong>Рис. 3.8.</strong> Множество предопределенных операторов.</p>
     <empty-line/>
     <p>Для удобства некоторые операторы в пролог-системах определены заранее, чтобы ими можно было пользоваться сразу, без какого-либо определения их в программе. Набор таких операторов и их приоритеты зависят от реализации. Мы будем предполагать, что множество этих "стандартных" операторов ведет себя так, как если бы оно было определено с помощью предложений, приведенных на рис. 3.8. Как видно из того же рисунка, несколько операторов могут быть определены в одном предложении, если только они все имеют одинаковый приоритет и тип. В этом случае имена операторов записываются в виде списка. Использование операторов может значительно повысить наглядность, "читабельность" программы. Для примера предположим, что мы пишем программу для обработки булевских выражений. В такой программе мы, возможно, захотим записать утверждение одной из теорем де Моргана, которое в математических обозначениях записывается так:</p>
     <p><code>~ (А &amp; В) &lt;===&gt; ~А v ~В</code></p>
     <p>Приведем один из способов записи этого утверждения в виде прологовского предложения:</p>
     <p><code>эквивалентно( not( и( А, В)), или( not( A, not( B))).</code></p>
     <p>Однако хорошим стилем программирования было бы попытаться сохранить по возможности больше сходства между видом записи исходной задачи и видом, используемом в программе ее решения. В нашем примере этого можно достичь почти в полной мере, применив операторы. Подходящее множество операторов для наших целей можно определить так:</p>
     <p><code>:- op( 800, xfx, &lt;===&gt;).</code></p>
     <p><code>:- op( 700, xfy, v).</code></p>
     <p><code>:- op( 600, хfу, &amp;).</code></p>
     <p><code>:- op( 500, fy, ~).</code></p>
     <p>Теперь правило де Моргана можно записать в виде следующего факта:</p>
     <p><code>~(А &amp; В) &lt;===&gt; ~А v ~В.</code></p>
     <p>В соответствии с нашими определениями операторов этот терм понимается так, как это показано на рис. 3.9.</p>
     <image l:href="#_36.png"/>
     <p><strong>Рис. 3.9.</strong> Интерпретация терма <code>~(А &amp; В) &lt;===&gt; ~A v ~В</code></p>
     <p>Подытожим:</p>
     <p>• Наглядность программы часто можно улучшить, использовав операторную нотацию. Операторы бывают инфиксные, префиксные и постфиксные.</p>
     <p>• В принципе, с оператором не связываются никакие действия над данными, за исключением особых случаев. Определение оператора не содержит описания каких-либо действий, оно лишь вводит новый способ записи. Операторы, как и функторы, лишь связывают компоненты в единую структуру.</p>
     <p>• Программист может вводить свои собственные операторы. Каждый оператор определяется своим именем, приоритетом и типом.</p>
     <p>• Номер приоритета — это целое число из некоторого диапазона, скажем, между 1 и 1200. Оператор с самым больший номером приоритета соответствует главному функтору выражения, в котором этот оператор встретился. Операторы с меньшими номерами приоритетов связывают свои аргументы сильнее других операторов.</p>
     <p>• Тип оператора зависит от двух условий: (1) его расположения относительно своих аргументов, (2) приоритета его аргументов по сравнению с его собственным. В спецификаторах, таких, как <code>xfy</code>, <code>x</code> обозначает аргумент, чей номер приоритета строго меньше номера приоритета оператора; <code>y</code> — аргумент с номером приоритета, меньшим или равным номеру приоритета оператора.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>3.12.</strong> Если принять такие определения</p>
     <p><code>:- op( 300, xfy, играет_в).</code></p>
     <p><code>:- op( 200, xfy, и).</code></p>
     <p>то два следующих терма представляют собой синтаксически правильные объекты:</p>
     <p><code>Tepм1 = джимми играет_в футбол и сквош</code></p>
     <p><code>Терм1 = сьюзан играет_в теннис и баскетбол и волейбол</code></p>
     <p>Как эти термы интерпретируются пролог-системой? Каковы их главные функторы и какова их структура?</p>
     <p><strong>3.13.</strong> Предложите подходящее определение операторов ("<code>работает</code>", "<code>в</code>", "<code>нашем</code>"), чтобы можно было писать предложения типа:</p>
     <p><code>диана работает секретарем в нашем отделе.</code></p>
     <p>а затем спрашивать:</p>
     <p><code>?- Кто работает секретарем в нашем отделе.</code></p>
     <p><code>Кто = диана</code></p>
     <empty-line/>
     <p><code>?- диана работает Кем.</code></p>
     <p><code>Кем = секретарем в нашем отдела</code></p>
     <p><strong>3.14.</strong> Рассмотрим программу:</p>
     <p><code>t( 0+1, 1+0).</code></p>
     <empty-line/>
     <p><code>t( X+0+1, X+1+0).</code></p>
     <empty-line/>
     <p><code>t( X+1+1, Z) :-</code></p>
     <p><code> t( X+1, X1),</code></p>
     <p><code> t( X1+1, Z).</code></p>
     <p>Как данная программа будет отвечать на ниже перечисленные вопросы, если '<code>+</code>' — это (как обычно) инфиксный оператор типа <code>yfx</code>?</p>
     <p>(a) <code>?- t( 0+1, А).</code></p>
     <p>(b) <code>?- t( 0+1+1, В).</code></p>
     <p>(с) <code>?- t( 1+0+1+1+1, С).</code></p>
     <p>(d) <code>?- t( D, 1+1+1+0).</code></p>
     <p><strong>3.15.</strong> В предыдущем разделе отношения между списка ми мы записывали так:</p>
     <p><code>принадлежит( Элемент, Список),</code></p>
     <p><code> конк( Список1, Список2, Список3),</code></p>
     <p><code> удалить( Элемент, Список, НовыйСписок), ...</code></p>
     <p>Предположим, что более предпочтительной для нас является следующая форма записи:</p>
     <p><code>Элемент входит_в Список,</code></p>
     <p><code> конкатенация_списков Список1 и Список2</code></p>
     <p><code>  дает Список3,</code></p>
     <p><code> удаление_элемента Элемент из_списка Список</code></p>
     <p><code>  дает НовыйСписок, ...</code></p>
     <p>Определите операторы "<code>входит_в</code>", "<code>конкатенация_списков</code>", "<code>и</code>" и т.д. таким образом, чтобы обеспечить эту возможность. Переопределите также и соответствующие процедуры.</p>
    </section>
    <section>
     <title>
      <p>3.4. Арифметические действия</p>
     </title>
     <p>Пролог рассчитан главным образом на обработку символьной информации, при которой потребность в арифметических вычислениях относительно мала. Поэтому и средства для таких вычислений довольно просты. Для осуществления основных арифметических действий можно воспользоваться несколькими предопределенными операторами.</p>
     <p><code>+  </code> сложение</p>
     <p><code>-  </code> вычитание</p>
     <p><code>*  </code> умножение</p>
     <p><code>/  </code> деление</p>
     <p><code>mod</code> модуль, остаток от целочисленного деления</p>
     <p>Заметьте, что это как раз тот исключительный случай. когда оператор может и в самом деле произвести некоторую операцию. Но даже и в этом случае требуется дополнительное указание на выполнение действия. Пролог-система знает, как выполнять вычисления, предписываемые такими операторами, но этого недостаточно для их непосредственного использования. Следующий вопрос - наивная попытка произвести арифметическое действие:</p>
     <p><code>?- X = 1 + 2.</code></p>
     <p>Пролог-система "спокойно" ответит</p>
     <p><code>X = 1 + 2</code></p>
     <p>а не <code>X = 3</code>, как, возможно, ожидалось. Причина этого проста: выражение <code>1 + 2</code> обозначает лишь прологовский терм, в котором <code>+</code> является функтором, а 1 и 2 — его аргументами. В вышеприведенной цели нет ничего, что могло бы заставить систему выполнить операцию сложения. Для этого в Прологе существует специальный оператор <code>is</code> (есть). Этот оператор заставит систему выполнить вычисление. Таким образом, чтобы правильно активизировать арифметическую операцию, надо написать:</p>
     <p><code>?- X is 1 + 2.</code></p>
     <p>Вот теперь ответ будет</p>
     <p><code>X = 3</code></p>
     <p>Сложение здесь выполняется специальной процедурой, связанной с оператором <code>+</code>. Мы будем называть такие процедуры <emphasis>встроенными</emphasis>.</p>
     <p>В Прологе не существует общепринятой нотации для записи арифметических действий, поэтому в разных реализациях она может слегка различаться. Например, оператор '<code>/</code>' может в одних реализациях обозначать целочисленное деление, а в других — вещественное. В данной книге под '<code>/</code>' мы подразумеваем вещественное деление, для целочисленного же будем использовать оператор <code>div</code>. В соответствии с этим, на вопрос</p>
     <p><code>?- X is 3/2,</code></p>
     <p><code> Y is 3 div 2.</code></p>
     <p>ответ должен быть такой:</p>
     <p><code>X = 1.5</code></p>
     <p><code>Y = 1</code></p>
     <p>Левым аргументом оператора <code>is</code> является простой объект. Правый аргумент — арифметическое выражение, составленное с помощью арифметических операторов, чисел и переменных. Поскольку оператор <code>is</code> запускает арифметические вычисления, к моменту начала вычисления этой цели все ее переменные должны быть уже конкретизированы какими-либо числами. Приоритеты этих предопределенных арифметических операторов (см. рис. 3.8) выбраны с таким расчетом, чтобы операторы применялись к аргументам в том порядке, который принят в математике. Чтобы изменить обычный порядок вычислений, применяются скобки (тоже, как в математике). Заметьте, что <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> и <code>div</code> определены, как <code>yfx</code>, что определяет порядок их выполнения слева направо. Например,</p>
     <p><code>X is 5 - 2 - 1</code></p>
     <p>понимается как</p>
     <p><code>X is (5 - 2) - 1</code></p>
     <p>Арифметические операции используются также и при <emphasis>сравнении</emphasis> числовых величин. Мы можем, например, проверить, что больше — 10000 или результат умножения 277 на 37, с помощью цели</p>
     <p><code>?- 277 * 37 &gt; 10000.</code></p>
     <p><code>yes            </code>(да)</p>
     <p>Заметьте, что точно так же, как и <code>is</code>, оператор '<code>&gt;</code>' вызывает выполнение вычислений.</p>
     <p>Предположим, у нас есть программа, в которую входит отношение <code>рожд</code>, связывающее имя человека с годом его рождения. Тогда имена людей, родившихся между 1950 и 1960 годами включительно, можно получить при помощи такого вопроса:</p>
     <p><code>?- рожд( Имя, Год),</code></p>
     <p><code> Год &gt;= 1950,</code></p>
     <p><code> Год &lt;= 1960.</code></p>
     <p>Ниже перечислены операторы сравнения:</p>
     <p><code>X &gt; Y  </code> X больше Y</p>
     <p><code>X &lt; Y  </code> X меньше Y</p>
     <p><code>X &gt;= Y </code> X больше или равен Y</p>
     <p><code>X =&lt; Y </code> X меньше или равен Y</p>
     <p><code>X =:= Y</code> величины X и Y совпадают (равны)</p>
     <p><code>X =\= Y</code> величины X и Y не равны</p>
     <p>Обратите внимание на разницу между операторами сравнения '<code>=</code>' и '<code>=:=</code>', например, в таких целях как <code>X = Y</code> и <code>X =:= Y</code>. Первая цель вызовет сопоставление объектов <code>X</code> и <code>Y</code>, и, если <code>X</code> и <code>Y</code> сопоставимы, возможно, приведет к конкретизации каких-либо переменных в этих объектах. Никаких вычислений при этом производиться не будет. С другой стороны, <code>X =:= Y</code> вызовет арифметическое вычисление и не может привести к конкретизации переменных. Это различие можно проиллюстрировать следующими примерами:</p>
     <p><code>?- 1 + 2 =:= 2 + 1.</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- 1 + 2 = 2 + 1.</code></p>
     <p><code>no</code></p>
     <empty-line/>
     <p><code>?- 1 + А = В + 2.</code></p>
     <p><code>А = 2</code></p>
     <p><code>В = 1</code></p>
     <p>Давайте рассмотрим использование арифметических операций на двух простых примерах. В первом примере ищется наибольший общий делитель; во втором — определяется количество элементов в некотором списке.</p>
     <p>Если заданы два целых числа X и Y, то их наибольший общий делитель Д можно найти, руководствуясь следующими тремя правилами:</p>
     <p>(1) Если X и Y равны, то Д равен X.</p>
     <p>(2) Если X &gt; Y, то Д равен наибольшему общему делителю X разности Y – X.</p>
     <p>(3) Если Y &lt; X, то формулировка аналогична правилу (2), если X и Y поменять в нем местами.</p>
     <p>На примере легко убедиться, что эти правила действительно позволяют найти наибольший общий делитель. Выбрав, скажем, X = 20 и Y = 25, мы, руководствуясь приведенными выше правилами, после серии вычитаний получим Д = 5.</p>
     <p>Эти правила легко сформулировать в виде прологовской программы, определив трехаргументное отношение, скажем</p>
     <p><code>нод( X , Y, Д)</code></p>
     <p>Тогда наши три правила можно выразить тремя предложениями так:</p>
     <p><code>нод( X, X, X).</code></p>
     <empty-line/>
     <p><code>нод( X, Y, Д) :-</code></p>
     <p><code> X &lt; Y,</code></p>
     <p><code> Y1 is Y - X,</code></p>
     <p><code> нод( X, Y1, Д).</code></p>
     <empty-line/>
     <p><code>нод( X, Y, Д) :-</code></p>
     <p><code> Y &lt; X,</code></p>
     <p><code> нод( Y, X, Д).</code></p>
     <p>Разумеется, с таким же успехом можно последнюю цель в третьем предложении заменить двумя:</p>
     <p><code>X1 is X - Y,</code></p>
     <p><code>нод( X1, Y, Д)</code></p>
     <p>В нашем следующем примере требуется произвести некоторый подсчет, для чего, как правило, необходимы арифметические действия. Примером такой задачи может служить вычисление длины какого-либо списка; иначе говоря, подсчет числа его элементов. Определим процедуру</p>
     <p><code>длина( Список, N)</code></p>
     <p>которая будет подсчитывать элементы списка <code>Список</code> и конкретизировать <code>N</code> полученным числом. Как и раньше, когда речь шла о списках, полезно рассмотреть два случая:</p>
     <p>(1) Если список пуст, то его длина равна 0.</p>
     <p>(2) Если он не пуст, то <code>Список = [Голова1 | Хвост]</code> и его длина равна 1 плюс длина хвоста <code>Хвост</code>.</p>
     <p>Эти два случая соответствуют следующей программе:</p>
     <p><code>длина( [], 0).</code></p>
     <empty-line/>
     <p><code>длина( [ _ | Хвост], N) :-</code></p>
     <p><code> длина( Хвост, N1),</code></p>
     <p><code> N is 1 + N1.</code></p>
     <p>Применить процедуру <code>длина</code> можно так:</p>
     <p><code>?- длина( [a, b, [c, d], e], N).</code></p>
     <p><code>N = 4</code></p>
     <p>Заметим, что во втором предложении этой процедуры две цели его тела нельзя поменять местами. Причина этого состоит в том, что переменная N1 должна быть конкретизирована до того, как начнет вычисляться цель</p>
     <p><code>N is 1 + N1</code></p>
     <p>Таким образом мы видим, что введение встроенной процедуры <code>is</code> привело нас к примеру отношения, чувствительного к порядку обработки предложений и целей. Очевидно, что процедурные соображения для подобных отношений играют жизненно важную роль.</p>
     <p>Интересно посмотреть, что произойдет, если мы попытаемся запрограммировать отношение <code>длина</code> без использования <code>is</code>. Попытка может быть такой:</p>
     <p><code>длина1( [ ], 0).</code></p>
     <empty-line/>
     <p><code>длина1( [ _ | Хвост], N) :-</code></p>
     <p><code> длина1( Хвост, N1),</code></p>
     <p><code> N = 1 + N1.</code></p>
     <p>Теперь уже цель</p>
     <p><code>?- длина1( [a, b, [c, d], e], N).</code></p>
     <p>породит ответ:</p>
     <p><code>N = 1+(1+(1+(1+0)))</code></p>
     <p>Сложение ни разу в действительности не запускалось и поэтому ни разу не было выполнено. Но в процедуре <code>длина1</code>, в отличие от процедуры <code>длина</code>, мы можем поменять местами цели во втором предложении:</p>
     <p><code>длина1( _ | Хвост], N) :-</code></p>
     <p><code> N = 1 + N1,</code></p>
     <p><code> длина1( Хвост, N1).</code></p>
     <p>Такая версия <code>длина1</code> будет давать те же результаты, что и исходная. Ее можно записать короче:</p>
     <p><code>длина1( [ _ | Хвост], 1 + N) :-</code></p>
     <p><code> длина1( Хвост, N).</code></p>
     <p>и она и в этом случае будет давать те же результаты. С помощью <code>длина1</code>, впрочем, тоже можно вычислять количество элементов списка:</p>
     <p><code>?- длина( [а, b, с], N), Длина is N.</code></p>
     <empty-line/>
     <p><code>N = 1+(1+(l+0))</code></p>
     <p><code>Длина = 3</code></p>
     <p>Итак:</p>
     <p>• Для выполнения арифметических действий используются встроенные процедуры.</p>
     <p>• Арифметические операции необходимо явно запускать при помощи встроенной процедуры <code>is</code>. Встроенные процедуры связаны также с предопределенными операторами <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>div</code> и <code>mod</code>.</p>
     <p>• К моменту выполнения операций все их аргументы должны быть конкретизированы числами.</p>
     <p>• Значения арифметических выражений можно сравнивать с помощью таких операторов, как <code>&lt;</code>, <code>=&lt;</code> и т.д. Эти операторы вычисляют значения своих аргументов.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>3.16.</strong> Определите отношение</p>
     <p><code>mах( X, Y, Мах)</code></p>
     <p>так, чтобы <code>Мах</code> равнялось наибольшому из двух чисел X и Y.</p>
     <p><strong>3.17.</strong> Определите предикат</p>
     <p><code>максспис( Список, Мах)</code></p>
     <p>так, чтобы <code>Мах</code> равнялось наибольшему из чисел, входящих в <code>Список</code>.</p>
     <p><strong>3.18.</strong> Определите предикат</p>
     <p><code>сумспис( Список, Сумма)</code></p>
     <p>так, чтобы <code>Сумма</code> равнялось сумме чисел, входящих в <code>Список</code>.</p>
     <p><strong>3.19.</strong> Определите предикат</p>
     <p><code>упорядоченный( Список)</code></p>
     <p>который принимает значение истина, если <code>Список</code> представляет собой упорядоченный список чисел. Например: <code>упорядоченный [1, 5, 6, 6, 9, 12] )</code>.</p>
     <p><strong>3.20.</strong> Определите предикат</p>
     <p><code>подсумма( Множ, Сумма, ПодМнож)</code></p>
     <p>где <code>Множ</code> это список чисел, <code>Подмнож</code> подмножество этих чисел, а сумма чисел из <code>ПодМнож</code> равна <code>Сумма</code>. Например:</p>
     <p><code>?- подсумма( [1, 2, 5, 3, 2], 5, ПМ).</code></p>
     <p><code>ПМ = [1, 2, 2];</code></p>
     <p><code>ПМ = [2, 3];</code></p>
     <p><code>ПМ = [5];</code></p>
     <p><code>...</code></p>
     <p><strong>3.21.</strong> Определите процедуру</p>
     <p><code>между( N1, N2, X)</code></p>
     <p>которая, с помощью перебора, порождает все целые числа X, отвечающие условию N1&#8804;X&#8804;N2.</p>
     <p><strong>3.22.</strong>    Определите операторы 'если', 'то', 'иначе' и ':=" таким образом, чтобы следующее выражение стало правильным термом:</p>
     <p><code>если X &gt; Y то Z := X иначе Z := Y</code></p>
     <p>Выберите приоритеты так, чтобы  'если' стал главным функтором. Затем определите отношение 'если' так, чтобы оно стало как бы маленьким интерпретатором выражений типа 'если-то-иначе'. Например, такого</p>
     <p><code>если Вел1 &gt; Вел2 то Перем := Вел3</code></p>
     <p><code>иначе Перем := Вел4</code></p>
     <p>где <code>Вел1</code>, <code>Вел2</code>, <code>Вел3</code> и <code>Вел4</code> — числовые величины (или переменные, конкретизированные числами), а <code>Перем</code> — переменная. Смысл отношения 'если' таков: если значение <code>Вел1</code> больше значения <code>Вел2</code>, тогда <code>Перем</code> конкретизируется значением <code>Вел3</code>, в противном случае — значением <code>Вел4</code>. Приведем пример использования такого интерпретатора:</p>
     <p><code>?- X = 2, Y = 3,</code></p>
     <p><code> Вел2 is 2*X,</code></p>
     <p><code> Вел4 is 4*X,</code></p>
     <p><code> Если Y &gt; Вел2 то Z := Y иначе Z := Вел4.</code></p>
     <p><code> Если Z &gt; 5 то W := 1 иначе W :=0.</code></p>
     <empty-line/>
     <p><code>X = 2</code></p>
     <p><code>Y = 3</code></p>
     <p><code>Z = 8</code></p>
     <p><code>W = 1</code></p>
     <empty-line/>
     <p><code>Вел2 = 4</code></p>
     <p><code>Вел4 = 8</code></p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Список — часто используемая структура. Он либо пуст, либо состоит из <emphasis>головы</emphasis> и <emphasis>хвоста</emphasis>, который в свою очередь также является списком. Для списков в Прологе имеется специальная нотация.</p>
     <p>• В данной главе рассмотрены следующие операции над списками: принадлежность к списку, конкатенация, добавление элемента, удаление элемента, удаление подсписка.</p>
     <p>• <emphasis>Операторная запись</emphasis> позволяет программисту приспособить синтаксис программ к своим конкретным нуждам. С помощью операторов можно значительно повысить наглядность программ.</p>
     <p>• Новые операторы определяются с помощью директивы <code>op</code>, в которой указываются его имя, тип и приоритет.</p>
     <p>• Как правило, с оператором не связывается никакой операции; оператор это просто синтаксическое удобство, обеспечивающее альтернативный способ записи термов.</p>
     <p>• Арифметические операции выполняются с помощью встроенных процедур. Вычисление арифметических выражений запускается процедурой <code>is</code>, а также предикатами сравнения <code>&lt;</code>, <code>=&lt;</code> и т.д.</p>
     <p>• Понятия, введенные в данной главе:</p>
     <p> список, голова списка, хвост списка</p>
     <p> списковая нотация</p>
     <p> операторы, операторная нотация</p>
     <p> инфиксные, префиксные и постфиксные операторы</p>
     <p> приоритет операторов</p>
     <p> арифметические встроенные процедуры </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 4</p>
     <p>Использование структур: примеры</p>
    </title>
    <section>
     <p>Структуры данных вместе с сопоставлением, автоматическими возвратами и арифметикой представляют собой мощный инструмент программирования. В этой главе мы расширим навыки использования этого инструмента при помощи следующих учебных программных примеров: получение структурированной информации из базы данных, моделирование недетерминированного автомата, планирование маршрута поездки и решение задачи о расстановке восьми ферзей на шахматной доске. Мы увидим также, как в Прологе реализуется принцип абстракции данных.</p>
    </section>
    <section>
     <title>
      <p>4.1. Получение структурированной информации из базы данных</p>
     </title>
     <p>Это упражнение развивает навыки представления структурных объектов данных и управления ими. Оно показывает также, что Пролог является естественным языком запросов к базе данных.</p>
     <p>База данных может быть представлена на Прологе в виде множества фактов. Например, в базе данных о семьях каждая семья может описываться одним предложением. На рис. 4.1 показано, как информацию о каждой семье можно представить в виде структуры. Каждая семья состоит из трех компонент: мужа, жены и детей. Поскольку количество детей в разных семьях может быть разным, то их целесообразно представить в виде списка, состоящего из произвольного числа элементов. Каждого члена семьи в свою очередь можно представить структурой, состоящей из четырех компонент: имени, фамилии, даты рождения и работы. Информация о работе — это либо "не работает", либо указание места работа и оклада (дохода). Информацию о семье, изображенной на рис. 4.1, можно занести в базу данных с помощью предложения:</p>
     <p><code>семья( членсемьи( том, фокс, дата( 7, май, 1950),</code></p>
     <p><code> работает( bbс, 15200) ),</code></p>
     <p><code> членсемьи( энн, фокс, дата( 9, май, 1951), неработает),</code></p>
     <p><code> [членсемьи( пат, фокс, дата( 5, май, 1973), неработает),</code></p>
     <p><code> членсемьи( джим, фокс, дата( 5, май, 1973), неработает) ] ).</code></p>
     <image l:href="#_37.png"/>
     <p><strong>Рис. 4.1.</strong> Структурированная информация о семье.</p>
     <p>Тогда база данных будет состоять из последовательности фактов, подобных этому, и описывать все семьи, представляющие интерес для нашей программы.</p>
     <p>В действительности Пролог очень удобен для извлечения необходимой информации из такой базы данных. Здесь хорошо то, что можно ссылаться на объекты, не указывая в деталях всех их компонент. Можно задавать только <emphasis>структуру</emphasis> интересующих нас объектов и оставлять конкретные компоненты без точного описания или лишь с частичным описанием. На рис. 4.2 приведено несколько примеров. Так, а запросах к базе данных можно ссылаться на всех Армстронгов с помощью терма</p>
     <p><code>семья( членсемьи( _, армстронг, _, _ ), _, _ )</code></p>
     <p>Символы подчеркивания обозначают различные анонимные переменные, значения которых нас не заботят. Далее можно сослаться на все семьи с тремя детьми при помощи терма:</p>
     <p><code>семья( _, _, [ _, _, _ ])</code></p>
     <p>Чтобы найти всех замужних женщин, имеющих по крайней мере троих детей, можно задать вопрос:</p>
     <p> <code>?-  семья( _, членсемьи( Имя, Фамилия, _, _ ), [ _, _, _ | _ ]).</code></p>
     <p>Главным моментом в этих примерах является то, что указывать интересующие нас объекты можно не только по их содержимому, но и по их структуре. Мы задаем одну структуру и оставляем ее аргументы в виде слотов (пропусков).</p>
     <image l:href="#_38.png"/>
     <p><strong>Рис. 4.2.</strong> Описания объектов по их структурным свойствам: (а) любая семья Армстронгов; (b) любая семья, имеющая ровно трех детей; (с) любая семья, имеющая по крайней мере три ребенка. Структура (с) дает возможность получить имя и фамилию жены конкретизацией переменных <code>Имя</code> и <code>Фамилия</code>.</p>
     <p>Можно создать набор процедур, который служил бы утилитой, делающей взаимодействие с нашей базой данных более удобным. Такие процедуры являлись бы частью пользовательского интерфейса. Вот некоторые полезные процедуры для нашей базы данных:</p>
     <p><code>муж( X) :-     % X - муж</code></p>
     <p><code> семья( X, _, _ ).</code></p>
     <empty-line/>
     <p><code>жена( X) :-    % X - жена</code></p>
     <p><code> семья( _, X, _ ).</code></p>
     <empty-line/>
     <p><code>ребенок( X) :- % X - ребенок</code></p>
     <p><code> семья( _, _, Дети),</code></p>
     <p><code> принадлежит( X, Дети).</code></p>
     <empty-line/>
     <p><code>принадлежит( X, [X | L ]).</code></p>
     <p><code>принадлежит( X, [Y | L ]) :-</code></p>
     <p><code> принадлежит( X, L).</code></p>
     <empty-line/>
     <p><code>существует( Членсемьи) :-</code></p>
     <p><code> % Любой член семьи в базе данных</code></p>
     <p><code> муж( Членсемьи);</code></p>
     <p><code> жена( Членсемьи);</code></p>
     <p><code> ребенок( Членсемьи).</code></p>
     <empty-line/>
     <p><code>дата рождения( Членсемьи( _, _, Дата, _ ), Дата).</code></p>
     <empty-line/>
     <p><code>доход( Членсемьи( _, _, _, работает( _, S) ), S).</code></p>
     <p><code> % Доход работающего</code></p>
     <p><code>доход( Членсемьи( _, _, _, неработает), 0).</code></p>
     <p><code> % Доход неработающего</code></p>
     <p>Этими процедурами можно воспользоваться, например, в следующих запросах к базе данных:</p>
     <p>• Найти имена всех людей из базы данных:</p>
     <p>  <code>?-  существует( членсемьи( Имя,Фамилия, _, _ )).</code></p>
     <p>• Найти всех детей, родившихся в 1981 году:</p>
     <p>  <code>?-  ребенок( X), датарождения( X, дата( _, _, 1981) ).</code></p>
     <p>• Найти всех работающих жен:</p>
     <p>  <code>?-  жена( членсемьи( Имя, Фамилия, _, работает( _, _ ))).</code></p>
     <p>• Найти имена и фамилии людей, которые не работают и родились до 1963 года:</p>
     <p>  <code>?- существует членсемьи( Имя, Фамилия, дата( _, _, Год), неработает) ),</code></p>
     <p><code>  Год &lt; 1963.</code></p>
     <p>• Найти людей, родившихся до 1950 года, чей доход меньше, чем 8000:</p>
     <p>  <code>?- существует( Членсемьи),</code></p>
     <p><code>  датарождения( Членсемьи, дата( _, _, Год) ),</code></p>
     <p><code>  Год &lt; 1950,</code></p>
     <p><code>  доход( Членсемьи, Доход),</code></p>
     <p><code>  Доход &lt; 8000.</code></p>
     <p>• Найти фамилии людей, имеющих по крайней мере трех детей:</p>
     <p>  <code>?-  семья( членсемьи( _, Фамилия, _, _ ), _, [ _, _, _ | _ ]).</code></p>
     <p>Для подсчета общего дохода семья полезно определить сумму доходов людей из некоторого списка в виде двухаргументного отношения:</p>
     <p><code>общий( Список_Людей, Сумма_их_доходов)</code></p>
     <p>Это отношение можно запрограммировать так:</p>
     <p><code>общий( [], 0). % Пустой список людей</code></p>
     <p><code>общий( [ Человек | Список], Сумма) :-</code></p>
     <p><code> доход( Человек, S),</code></p>
     <p><code>  % S - доход первого человека</code></p>
     <p><code> общий( Список, Остальные),</code></p>
     <p><code>  % Остальные - сумма доходов остальных</code></p>
     <p><code> Сумма is S + Остальные.</code></p>
     <p>Теперь общие доходы всех семей могут быть найдены с помощью вопроса:</p>
     <p><code>?- семья( Муж, Жена, Дети),</code></p>
     <p><code> общий( [Муж, Жена | Дети], Доход).</code></p>
     <p>Пусть отношение длина подсчитывает количество элементов списка, как это было определено в разд. 3.4. Тогда мы можем найти все семьи, которые имеют доход на члена семьи, меньший, чем 2000, при помощи вопроса:</p>
     <p><code>?- семья( Муж, Жена, Дети),</code></p>
     <p><code> общий( [ Муж, Жена | Дети], Доход),</code></p>
     <p><code> длина( [ Муж, Жена | Дети], N),</code></p>
     <p><code> Доход/N &lt; 2000.</code></p>
     <subtitle>Упражнения</subtitle>
     <p><strong>4.1.</strong> Напишите вопросы для поиска в базе данных о семьях.</p>
     <p>(а) семей без детей;</p>
     <p>(b) всех работающих детей;</p>
     <p>(с) семей, где жена работает, а муж нет,</p>
     <p>(d) всех детей, разница в возрасте родителей которых составляет не менее 15 лет.</p>
     <p><strong>4.2.</strong> Определите отношение</p>
     <p><code>близнецы( Ребенок1, Ребенок2)</code></p>
     <p>для поиска всех близнецов в базе данных о семьях.</p>
    </section>
    <section>
     <title>
      <p>4.2. Абстракция данных</p>
     </title>
     <p><emphasis>Абстракцию данных</emphasis> можно рассматривать как процесс организации различных фрагментов информации в единые логические единицы (возможно, иерархически), придавая ей при этом некоторую концептуально осмысленную форму. Каждая информационная единица должна быть легко доступна в программе. В идеальном случае все детали реализации такой структуры должны быть невидимы пользователю этой структуры. Самое главное в этом процессе - дать программисту возможность использовать информацию, не думая о деталях ее действительного представления.</p>
     <p>Обсудим один из способов реализации этого принципа на Прологе. Рассмотрим снова пример с семьей из предыдущего раздела. Каждая семья — это набор некоторых фрагментов информации. Все эти фрагменты объединены в естественные информационные единицы, такие, как "член семьи" или "семья", и с ними можно обращаться как с едиными объектами. Предположим опять, что информация о семье структурирована так же, как на рис. 4.1. Определим теперь некоторые отношения, с помощью которых пользователь может получать доступ к конкретным компонентам семьи, не зная деталей рис. 4.1. Такие отношения можно назвать <emphasis>селекторами</emphasis>, поскольку они позволяют выбирать конкретные компоненты. Имя такого отношения-селектора будет совпадать с именем компоненты, которую нужно выбрать. Отношение будет иметь два аргумента: первый — объект, который содержит компоненту, и второй — саму компоненту:</p>
     <p><code>отношение_селектор(Объект, Выбранная_компонента)</code></p>
     <p>Вот несколько селекторов для структуры семья:</p>
     <p><code>муж( семья( Муж, _, _ ), Муж).</code></p>
     <p><code>жена( семья( _, Жена, _ ), Жена).</code></p>
     <p><code>дети( семья( _, _, СписокДетей ), СписокДетей).</code></p>
     <p>Можно также создать селекторы для отдельных детей семьи:</p>
     <p><code>первыйребенок( Семья, Первый) :-</code></p>
     <p><code> дети( Семья, [Первый | _ ]).</code></p>
     <empty-line/>
     <p><code>второйребенок( Семья, Второй) :-</code></p>
     <p><code> дети( Семья, [ _, Второй | _ ]).</code></p>
     <empty-line/>
     <p><code>...</code></p>
     <p>Можно обобщить этот селектор для выбора N-го ребенка:</p>
     <p><code><emphasis>n</emphasis>ребенок( N, Семья, Ребенок) :-</code></p>
     <p><code> дети( Семья, СписокДетей),</code></p>
     <p><code> <emphasis>n</emphasis>_элемент( N, СписокДетей, Ребенок)</code></p>
     <p><code>  % N-й элемент списка</code></p>
     <p>Другим интересным объектом является "член семьи". Вот некоторые связанные с ним селекторы, соответствующие рис. 4.1:</p>
     <p><code>имя( членсемьи( Имя, _, _, _ ), Имя).</code></p>
     <p><code>фамилия( членсемьи( _, Фамилия, _, _ ), Фамилия).</code></p>
     <p><code>датарождения( членсемьи( _, _, Дата), Дата).</code></p>
     <p>Какие преимущества мы можем получить от использования отношений-селекторов? Определив их, мы можем теперь забыть о конкретном виде структуры представления информации. Для пополнения и обработки этой информации нужно знать только имена отношений-селекторов и в оставшейся части программы пользоваться только ими. В случае, если информация представлена сложной структурой, это легче, чем каждый раз обращаться к ней в явном виде. В частности, в нашем примере с семьей пользователь не обязан знать, что дети представлены в виде списка. Например, предположим, мы хотим сказать, что Том Фокс и Джим Фокс принадлежат к одной семье и что Джим — второй ребенок Тома. Используя приведенные выше отношения-селекторы, мы можем определить двух человек, назовем их <code>Человек1</code> и <code>Человек2</code>, и семью. Следующий список целей приводит к желаемому результату:</p>
     <p><code>имя( Человек1, том), фамилия( Человек1, фокс),</code></p>
     <p><code>  % Человек1 - Том Фокс</code></p>
     <p><code> имя( Человек2, джим), фамилия( Человек1, фокс),</code></p>
     <p><code>  % Человек2 - Джим Фокс</code></p>
     <p><code> муж( Семья, Человек1),</code></p>
     <p><code> второйребенок( Семья, Человек2)</code></p>
     <p>Использование отношений-селекторов облегчает также и последующую модификацию программ. Представьте себе, что мы захотели повысить эффективность программы, изменив представление информации. Все, что нужно сделать для этого, — изменить определения отношений-селекторов, и вся остальная программа без изменений будет работать с этим новым представлением.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>4.3.</strong> Завершите определение отношения <emphasis><code><emphasis>n</emphasis>ребенок</code></emphasis>, определив отношение</p>
     <p><code><emphasis>n</emphasis>_элемент( N, Список, X)</code></p>
     <p>которое выполняется, если X является N-м элементом списка <code>Список</code>.</p>
    </section>
    <section>
     <title>
      <p>4.3. Моделирование недетерминированного автомата</p>
     </title>
     <p>Данное упражнение показывает, как абстрактную математическую конструкцию можно представить на Прологе. Кроме того, программа, которая получится, окажется значительно более гибкой, чем предполагалось вначале.</p>
     <p><emphasis>Недетерминированный конечный автомат</emphasis> — это абстрактная машина, которая читает символы из входной цепочки и решает, <emphasis>допустить</emphasis> или <emphasis>отвергнуть</emphasis> эту цепочку. Автомат имеет несколько <emphasis>состояний</emphasis> и всегда находится в одном из них. Он может изменить состояние, перейдя из одного состояния в другое. Внутреннюю структуру такого автомата можно представить графом переходов, как показано на рис. 4.3. В этом примере <emphasis>S<sub>1</sub></emphasis>, <emphasis>S<sub>2</sub></emphasis>, <emphasis>S<sub>3</sub></emphasis> и <emphasis>S<sub>4</sub></emphasis> — <emphasis>состояния</emphasis> автомата. Стартовав из начального состояния (в нашем примере это <emphasis>S<sub>1</sub></emphasis>), автомат переходит из состояния в состояние по мере чтения входной цепочки. Переход зависит от текущего входного символа, как указывают метки на дугах графа переходов.</p>
     <image l:href="#_39.png"/>
     <p><strong>Рис. 4.3.</strong> Пример недетерминированного конечного автомата.</p>
     <p>Переход выполняется всякий раз при чтении входного символа. Заметим, что переходы могут быть недетерминированными. На рис. 4.3 видно, что если автомат находится в состоянии <emphasis>S<sub>1</sub></emphasis>, и текущий входной символ равен  <emphasis>а</emphasis>,  то переход может осуществиться как в <emphasis>S<sub>1</sub></emphasis>, так и в <emphasis>S<sub>2</sub></emphasis>. Некоторые дуги помечены меткой пусто, обозначающей "пустой символ". Эти дуги соответствуют "спонтанным переходам" автомата. Такой переход называется <emphasis>спонтанным</emphasis>, потому что он выполняется без чтения входной цепочки. Наблюдатель, рассматривающий автомат как черный ящик, не сможет обнаружить, что произошел какой-либо переход.</p>
     <p>Состояние <emphasis>S<sub>3</sub></emphasis> обведено двойной линией, это означает, что <emphasis>S<sub>3</sub></emphasis> — <emphasis>конечное состояние</emphasis>. Про автомат говорят, что он <emphasis>допускает</emphasis> входную цепочку, если в графе переходов существует путь, такой, что:</p>
     <p>(1) он начинается в начальном состоянии,</p>
     <p>(2) он оканчивается в конечном состоянии, и</p>
     <p>(3) метки дуг, образующих этот путь, соответствуют полной входной цепочке.</p>
     <p>Решать, какой из возможных переходов делать в каждый момент времени — исключительно внутреннее дело автомата. В частности, автомат сам решает, делать ли спонтанный переход, если он возможен в текущем состоянии. Однако абстрактные недетерминированные машины такого типа обладают волшебным свойством: если существует выбор, они всегда избирают "правильный" переход, т.е. переход, ведущий к допущению входной цепочки при наличии такого перехода. Автомат на рис. 4.3, например, допускает цепочки <emphasis>аb </emphasis>и <emphasis>aabaab</emphasis>, но отвергает цепочки <emphasis>abb</emphasis> и <emphasis>abba</emphasis>. Легко видеть, что этот автомат допускает любые цепочки, оканчивающиеся на <emphasis>аb</emphasis> и отвергает все остальные.</p>
     <image l:href="#_40.png"/>
     <p><strong>Рис. 4.4.</strong> Допущение цепочки: (a) при чтении первого символа X; (b) при совершении спонтанного перехода.</p>
     <p>Некоторый автомат можно описать на Прологе при помощи трех отношений:</p>
     <p>(1) Унарного отношения <code>конечное</code>, которое определяет конечное состояние автомата.</p>
     <p>(2) Трехаргументного отношения <code>переход</code>, которое определяет переход из состояния в состояние, при этом</p>
     <p><code>переход( S1, X, S2)</code></p>
     <p>означает переход из состояния S1 в S2, если считан входной символ X.</p>
     <p>(3) Бинарного отношения</p>
     <p><code>спонтанный( S1, S2)</code></p>
     <p>означающего, что возможен спонтанный переход из S1 в S2.</p>
     <p>Для автомата, изображенного на рис. 4.3, эти отношения будут такими:</p>
     <p><code>конечное( S3).</code></p>
     <empty-line/>
     <p><code>переход( S1, а, S1).</code></p>
     <p><code>переход( S1, а, S2).</code></p>
     <p><code>переход( S1, b, S1).</code></p>
     <p><code>переход( S2, b, S3).</code></p>
     <p><code>переход( S3, b, S4).</code></p>
     <empty-line/>
     <p><code>спонтанный( S2, S4).</code></p>
     <p><code>спонтанный( S3, S1).</code></p>
     <p>Представим входные цепочки в виде списков Пролога. Цепочка <emphasis>ааb</emphasis> будет представлена как <code>[а, а, b]</code>. Модель автомата, получив его описание, будет обрабатывать заданную входную цепочку, и решать, допускать ее или нет. По определению, недетерминированный автомат допускает заданную цепочку, если (начав из начального состояния) после ее прочтения он способен оказаться в конечном состоянии. Модель программируется в виде бинарного отношения <code>допускается</code>, которое определяет принятие цепочки из данного состояния. Так</p>
     <p><code>допускается( Состояние, Цепочка)</code></p>
     <p>истинно, если автомат, начав из состояния <code>Состояние</code> как из начального, допускает цепочку <code>Цепочка</code>. Отношение <code>допускается</code> можно определить при помощи трех предложений. Они соответствуют следующим трем случаям:</p>
     <p>(1) Пустая цепочка <code>[]</code> допускается из состояния S, если S — конечное состояние.</p>
     <p>(2) Непустая цепочка допускается из состояния S, если после чтения первого ее символа автомат может перейти в состояние S1, и оставшаяся часть цепочки допускается из S1. Этот случай иллюстрируется на рис. 4.4(а).</p>
     <p>(3) Цепочка допускается из состояния S, если автомат может сделать спонтанный переход из S в S1, а затем допустить (всю) входную цепочку из S1. Такой случай иллюстрируется на рис. 4.4(b).</p>
     <p>Эти правила можно перевести на Пролог следующим образом:</p>
     <p><code>допускается( S, []) :-</code></p>
     <p><code>  % Допуск пустой цепочки</code></p>
     <p><code> конечное( S).</code></p>
     <empty-line/>
     <p><code>допускается( S, [X | Остальные]) :-</code></p>
     <p><code>  % Допуск чтением первого символа</code></p>
     <p><code> переход( S, X, S1),</code></p>
     <p><code> допускается( S1, Остальные).</code></p>
     <empty-line/>
     <p><code>допускается( S, Цепочка) :-</code></p>
     <p><code>  % Допуск выполнением спонтанного перехода</code></p>
     <p><code> спонтанный( S, S1),</code></p>
     <p><code> допускается( S1, Цепочка).</code></p>
     <p>Спросить о том, допускается ли цепочка <emphasis>аааb</emphasis>, можно так:</p>
     <p><code>?- допускается( S1, [a, a, a, b]).</code></p>
     <p><code>yes            </code>(да)</p>
     <p>Как мы уже видели, программы на Прологе часто оказываются способными решать более общие задачи, чем те, для которых они первоначально предназначались. В нашем случае мы можем спросить модель также о том, в каком состоянии должен находиться автомат в начале работы, чтобы он допустил цепочку <emphasis>аb</emphasis>:</p>
     <p><code>?- допускается( S, [a, b]).</code></p>
     <empty-line/>
     <p><code>S = s1;</code></p>
     <p><code>S = s3</code></p>
     <p>Как ни странно, мы можем спросить также "Каковы все цепочки длины 3, допустимые из состояния s1?"</p>
     <p><code>?- допускается( s1, [X1, Х2, X3]).</code></p>
     <empty-line/>
     <p><code>X1 = а</code></p>
     <p><code>X2 = а</code></p>
     <p><code>X3 = b;</code></p>
     <empty-line/>
     <p><code>X1 = b</code></p>
     <p><code>X2 = а</code></p>
     <p><code>X3 = b;</code></p>
     <empty-line/>
     <p><code>nо     </code>(нет)</p>
     <p>Если мы предпочитаем, чтобы допустимые цепочки выдавались в виде списков, тогда наш вопрос следует сформулировать так:</p>
     <p><code>?- Цепочка = [ _, _, _ ], допускается( s1, Цепочка).</code></p>
     <empty-line/>
     <p><code>Цепочка = [а, а, b];</code></p>
     <p><code>Цепочка = [b, а, b];</code></p>
     <p><code>nо     </code>(нет)</p>
     <p>Можно проделать и еще некоторые эксперименты, например спросить: "Из какого состояния автомат допустит цепочку длиной 7?"</p>
     <p>Эксперименты могут включать в себя переделки структуры автомата, вносящие изменения в отношения <code>конечное</code>, <code>переход</code> и <code>спонтанный</code>. В автомате, изображенном на рис. 4.3, отсутствуют циклические "спонтанные пути" (пути, состоящие только из спонтанных переходов). Если на рис. 4.3 добавить новый переход</p>
     <p><code>спонтанный( s1, s3)</code></p>
     <p>то получится "спонтанный цикл". Теперь наша модель может столкнуться с неприятностями. Например, вопрос</p>
     <p><code>?- допускается( s1, [а]).</code></p>
     <p>приведет к тому, что модель будет бесконечно переходить в состояние s1, все время надеясь отыскать какой-либо путь в конечное состояние.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>4.4.</strong> Почему не могло возникнуть зацикливание модели исходного автомата на рис. 4.3, когда в его графе переходов не было "спонтанного цикла"?</p>
     <p><strong>4.5.</strong> Зацикливание при вычислении <code>допускается</code> можно предотвратить, например, таким способом: подсчитывать число переходов, сделанных к настоящему моменту. При этом модель должна будет искать пути только некоторой ограниченной длины. Модифицируйте так отношение <code>допускается</code>. Указание: добавьте третий аргумент — максимально допустимое число переходов:</p>
     <p><code>допускается( Состояние, Цепочка, Макс_переходов)</code></p>
    </section>
    <section>
     <title>
      <p>4.4. Планирование поездки</p>
     </title>
     <p>В данном разделе мы создадим программу, которая дает советы по планированию воздушного путешествия. Эта программа будет довольно примитивным советчиком, тем не менее она сможет отвечать на некоторые полезные вопросы, такие как:</p>
     <p>• По каким дням недели есть прямые рейсы из Лондона в Любляну?</p>
     <p>• Как в четверг можно добраться из Любляны в Эдинбург?</p>
     <p>• Мне нужно посетить Милан, Любляну и Цюрих; вылетать нужно из Лондона во вторник и вернуться обратно в Лондон в пятницу. В какой последовательности мне следует посещать эти города, чтобы ни разу на протяжении поездки не пришлось совершать более одного перелета в день.</p>
     <p>Центральной частью программы будет база данных, содержащая информацию о рейсах. Эта информация будет представлена в виде трехаргументного отношения:</p>
     <p><code>расписание( Пункт1, Пункт2, Список_рейсов)</code></p>
     <p>где <code>Список_рейсов</code> — это список, состоящий из структурированных объектов вида:</p>
     <p><code>Время_отправления / Время_прибытия / Номер_рейса</code></p>
     <p><code> / Список_дней_вылета</code></p>
     <p><code>Список_дней_вылета</code> — это либо список дней недели, либо атом "ежедневно". Одно из предложений, входящих в <code>расписание</code> могло бы быть, например, таким:</p>
     <p><code>расписание( лондон, эдинбург,</code></p>
     <p><code> [ 9:40 / 10:50 / bа4733/ ежедневно,</code></p>
     <p><code>   19:40 / 20:50 / bа4833 / [пн, вт, ср, чт, пт, сб]] ).</code></p>
     <p>Время представлено в виде структурированных объектов, состоящих из двух компонент — часов и минут, объединенных оператором "<code>:</code>".</p>
     <p>Главная задача состоит в отыскании точных маршрутов между двумя заданными городами в определенные дни недели. Ее решение мы будем программировать в виде четырехаргументного отношения:</p>
     <p><code>маршрут( Пункт1, Пункт2, День, Маршрут)</code></p>
     <p>Здесь <code>Маршрут</code> — это последовательность перелетов, удовлетворяющих следующим критериям:</p>
     <p>(1) начальная точка маршрута находится в <code>Пункт1</code>;</p>
     <p>(2) конечная точка — в <code>Пункт2</code>;</p>
     <p>(3) все перелеты совершаются в один и тот же день недели — <code>День</code>;</p>
     <p>(4) все перелеты, входящие в <code>Маршрут</code>, содержатся в определении отношения <code>расписание</code>;</p>
     <p>(5) остается достаточно времени для пересадки с рейса на рейс.</p>
     <p>Маршрут представляется в виде списка структурированных объектов вида</p>
     <p><code>Откуда - Куда : Номер_рейса : Время_отправления</code></p>
     <p>Мы еще будем пользоваться следующими вспомогательными предикатами:</p>
     <p>(1) <code>рейс( Пункт1, Пункт2, День, N_рейса, Вр_отпр, Вр_приб)</code></p>
     <p>Здесь сказано, что существует рейс <code>N_рейса</code> между <code>Пункт1</code> и <code>Пункт2</code> в день недели <code>День</code> с указанными временами отправления и прибытия.</p>
     <p>(2) <code>вр_отпр( Маршрут, Время)</code></p>
     <p><code>Время</code> — это время отправления по маршруту <code>Маршрут</code>.</p>
     <p>(3) <code>пересадка( Время1, Время2)</code></p>
     <p>Между <code>Время1</code> и <code>Время2</code> должен существовать промежуток не менее 40 минут для пересадки с одного рейса на другой.</p>
     <p>Задача нахождения маршрута напоминает моделирование недетерминированного автомата из предыдущего раздела:</p>
     <p>• Состояния автомата соответствуют городам.</p>
     <p>• Переход из состояния в состояние соответствует перелету из одного города в другой.</p>
     <p>• Отношение <code>переход</code> автомата соответствует отношению <code>расписание</code>.</p>
     <p>• Модель автомата находит путь в графе переходов между исходным и конечным состояниями; планировщик поездки находит маршрут между начальным н конечным пунктами поездки.</p>
     <p>Неудивительно поэтому, что отношение <code>маршрут</code> можно определить аналогично отношению <code>допускает</code>, с той разницей, что теперь нет "спонтанных переходов". Существуют два случая:</p>
     <p>(1) Прямой рейс: если существует прямой рейс между пунктами <code>Пункт1</code> и <code>Пункт2</code>, то весь маршрут состоит только из одного перелета:</p>
     <p><code>маршрут( Пункт1, Пункт2, День, [Пункт1-Пункт2 : Nр : Отпр]) :-</code></p>
     <p><code> рейс( Пункт1, Пункт2, День, Np, Отпр, Приб).</code></p>
     <p>(2) Маршрут с пересадками: маршрут между пунктами <code>P1</code> и <code>Р2</code> состоит из первого перелета из <code>P1</code> в некоторый промежуточный пункт <code>Р3</code> и маршрута между <code>Р3</code> и <code>Р2</code>. Кроме того, между окончанием первого перелета и отправлением во второй необходимо оставить достаточно времени для пересадки.</p>
     <p><code>маршрут( P1, Р2, День, [P1-Р3 : Nр1 : Отпр1 | Маршрут]) :-</code></p>
     <p><code> маршрут( Р3, Р2, День, Маршрут ),</code></p>
     <p><code> рейс( P1, Р3, День, Npl, Oтпpl, Приб1),</code></p>
     <p><code> вр_отпр( Маршрут, Отпр2),</code></p>
     <p><code> пересадка( Приб1, Отпр2).</code></p>
     <p>Вспомогательные отношения <code>рейс</code>, <code>пересадка</code> и <code>вр_отпр</code> запрограммировать легко; мы включили их в полный текст программы планировщика поездки на рис. 4.5. Там же приводится и пример базы данных расписания.</p>
     <p>Наш планировщик исключительно прост и может рассматривать пути, очевидно ведущие в никуда. Тем не менее его оказывается вполне достаточно, если база данных о рейсах самолетов невелика. Для больших баз данных потребовалось бы разработать более интеллектуальный планировщик, который мог бы справиться с большим количеством путей, участвующих в перебора при нахождении нужного пути.</p>
     <p><code>% ПЛАНИРОВЩИК ВОЗДУШНЫХ МАРШРУТОВ</code></p>
     <empty-line/>
     <p><code>:- op( 50, xfy, :).</code></p>
     <empty-line/>
     <p><code>рейс( Пункт1, Пункт2, День, Np, ВрОтпр, ВрПриб) :-</code></p>
     <p><code> расписание( Пункт1, Пункт2, СписРейсов),</code></p>
     <p><code> принадлежит( ВрОтпр / ВрПриб / Nр / СписДней, СписРейсов),</code></p>
     <p><code> день_выл( День, СписДней).</code></p>
     <empty-line/>
     <p><code>принадлежит( X, [X | L] ).</code></p>
     <p><code>принадлежит( X, [Y | L] ) :-</code></p>
     <p><code> принадлежит( X, L ).</code></p>
     <empty-line/>
     <p><code>день_выл( День, СписДней) :-</code></p>
     <p><code> принадлежит( День, СписДней).</code></p>
     <p><code>день_выл( День, ежедневно) :-</code></p>
     <p><code> принадлежит( День, [пн, вт, ср, чт, пт, сб, вс] ).</code></p>
     <empty-line/>
     <p><code>маршрут( P1, P2, День, [P1-Р2 : Np : ВрОтпр] ) :-</code></p>
     <p><code>  % прямой рейс</code></p>
     <p><code> рейс( P1, P2, День, Np, ВрОтпр, _ ).</code></p>
     <p><code>маршрут( P1, Р2, День, [Pl-P3 : Np1 : Oтпp1 | Маршрут]) :-</code></p>
     <p><code>  % маршрут с пересадками</code></p>
     <p><code> маршрут( Р3, P2, День, Маршрут ),</code></p>
     <p><code> рейс( P1, Р3, День, Npl, Oтпp1, Приб1),</code></p>
     <p><code> вр_отпр( Маршрут, Отпр2),</code></p>
     <p><code> пересадка( Приб1, Отпр2).</code></p>
     <empty-line/>
     <p><code>вр_отпр( [P1-Р2 : Np : Отпр | _ ], Отпр).</code></p>
     <empty-line/>
     <p><code>пересадка( Часы1 : Минуты1, Часы2 : Минуты2) :-</code></p>
     <p><code> 60 * (Часы2-Часы1) + Минуты2 - Минуты1 &gt;= 40</code></p>
     <empty-line/>
     <p><code>% БАЗА ДАННЫХ О РЕЙСАХ САМОЛЕТОВ</code></p>
     <empty-line/>
     <p><code>расписание( эдинбург, лондон,</code></p>
     <p><code> [ 9:40 / 10:50 / bа4733 / ежедневно,</code></p>
     <p><code>   13:40 / 14:50 / ba4773 / ежедневно,</code></p>
     <p><code>   19:40 / 20:50 / bа4833 / [пн, вт, ср, чт, пт, вс] ] ).</code></p>
     <empty-line/>
     <p><code>расписание( лондон, эдинбург,</code></p>
     <p><code> [ 9:40 / 10:50 / bа4732 / ежедневно,</code></p>
     <p><code>   11:40 / 12:50 / bа4752 / ежедневно,</code></p>
     <p><code>   18:40 / 19:50 / bа4822 / [пн, вт, ср, чт, пт] ] ),</code></p>
     <empty-line/>
     <p><code>расписание( лондон, любляна,</code></p>
     <p><code> [13:20 / 16:20 / ju201 / [пт],</code></p>
     <p><code>  13:20 / 16:20 / ju213 / [вс] ] ).</code></p>
     <empty-line/>
     <p><code>расписание( лондон, цюрих,</code></p>
     <p><code> [ 9:10 / 11:45 / bа614 / ежедневно,</code></p>
     <p><code>   14:45 / 17:20 / sr805 / ежедневно ] ).</code></p>
     <empty-line/>
     <p><code>расписание( лондон, милан,</code></p>
     <p><code> [ 8:30 / 11:20 / bа510 / ежедневно,</code></p>
     <p><code>   11:00 / 13:50 / az459 / ежедневно ] ).</code></p>
     <empty-line/>
     <p><code>расписание( любляна, цюрих,</code></p>
     <p><code> [11:30 / 12:40 / ju322 / [вт,чт] ] ).</code></p>
     <empty-line/>
     <p><code>расписание( любляна, лондон,</code></p>
     <p><code> [11:10 / 12:20 / yu200 / [пт],</code></p>
     <p><code>  11:25 / 12:20 / yu212 / [вс] ] ).</code></p>
     <empty-line/>
     <p><code>расписание( милан, лондон,</code></p>
     <p><code> [ 9:10 / 10:00 / az458 / ежедневно,</code></p>
     <p><code>   12:20 / 13:10 / bа511 / ежедневно ] ).</code></p>
     <empty-line/>
     <p><code>расписание( милан, цюрих,</code></p>
     <p><code> [ 9:25 / 10:15 / sr621 / ежедневно,</code></p>
     <p><code>   12:45 / 13:35 / sr623 / ежедневно ] ).</code></p>
     <empty-line/>
     <p><code>расписание( цюрих, любляна,</code></p>
     <p><code> [13:30 / 14:40 / yu323 / [вт, чт] ] ).</code></p>
     <empty-line/>
     <p><code>расписание( цюрих, лондон,</code></p>
     <p><code> 9:00 / 9:40 / bа613 /</code></p>
     <p><code> [ пн, вт, ср, чт, пт, сб],</code></p>
     <p><code>   16:10 / 16:55 / sr806 / [пн, вт, ср, чт, пт, сб] ] ).</code></p>
     <empty-line/>
     <p><code>расписание( цюрих, милан,</code></p>
     <p><code> [ 7:55 / 8:45 / sr620 / ежедневно ] ).</code></p>
     <p><strong>Рис. 4.5.</strong>  Планировщик воздушных маршрутов и база данных о рейсах самолетов.</p>
     <empty-line/>
     <p>Вот некоторые примеры вопросов к планировщику:</p>
     <p>• По каким дням недели существуют прямые рейсы из Лондона в Люблину?</p>
     <p><code>?- рейс( лондон, любляна, День, _, _, _ ).</code></p>
     <empty-line/>
     <p><code>День = пт;</code></p>
     <p><code>День = сб;</code></p>
     <empty-line/>
     <p><code>no        </code>(нет)</p>
     <p>• Как мне добраться из Любляны в Эдинбург в четверг?</p>
     <p><code>?- маршрут( любляна, эдинбург, чт, R).</code></p>
     <empty-line/>
     <p><code>R = [любляна-цюрих : уu322 : 11:30, цюрих-лондон:</code></p>
     <p><code>     sr806 : 16:10,</code></p>
     <p><code>     лондон-эдинбург : bа4822 : 18:40 ]</code></p>
     <p>• Как мне посетить Милан, Любляну и Цюрих, вылетев из Лондона во вторник и вернувшись в него в пятницу, совершая в день не более одного перелета? Этот вопрос сложнее, чем предыдущие. Его можно сформулировать, использовав отношение <code>перестановка</code>, запрограммированное в гл. 3. Мы попросим найти такую перестановку городов Милан, Любляна и Цюрих, чтобы соответствующие перелеты можно было осуществить в несколько последовательных дней недели:</p>
     <p><code>?- перестановка( [милан, любляна, цюрих],</code></p>
     <p><code> [Город1, Город2, Город3] ),</code></p>
     <p><code> рейс( лондон, Город1, вт, Np1, Oтпp1, Пpиб1),</code></p>
     <p><code> peйc( Город1, Город2, ср, Np2, Отпр2, Приб2),</code></p>
     <p><code> рейс( Город2, Город3, чт, Np3, Отпp3, Приб3),</code></p>
     <p><code> рейс( Город3, лондон, пт, Np4, Отпр4, Приб4).</code></p>
     <empty-line/>
     <p><code>Город1 = милан</code></p>
     <p><code>Город2 = цюрих</code></p>
     <p><code>Город3 = любляна</code></p>
     <empty-line/>
     <p><code>Np1 = ba510</code></p>
     <p><code>Отпр1 = 8:30</code></p>
     <p><code>Приб1 = 11:20</code></p>
     <empty-line/>
     <p><code>Np2 =sr621</code></p>
     <p><code>Отпр2 = 9:25</code></p>
     <p><code>Приб2 = 10:15</code></p>
     <empty-line/>
     <p><code>Np3 = yu323</code></p>
     <p><code>Отпр3 = 13:30</code></p>
     <p><code>Приб3 = 14:40</code></p>
     <empty-line/>
     <p><code>Np4 = yu200</code></p>
     <p><code>Отпр4 = 11:10</code></p>
     <p><code>Приб4 = 12:20</code></p>
    </section>
    <section>
     <title>
      <p>4.5. Задача о восьми ферзях</p>
     </title>
     <section>
      <p>Эта задача состоит в отыскании такой расстановки восьми ферзей на пустой шахматной доске, в которой ни один из ферзей не находится под боем другого. Решение мы запрограммируем в виде унарного отношения:</p>
      <p><code>решение( Поз)</code></p>
      <p>которое истинно тогда и только тогда, когда <code>Поз</code> изображает позицию, в которой восемь ферзей не бьют друг друга. Будет интересно сравнить различные идеи, лежащие в основе программирования этой задачи. Поэтому мы приведем три программы, основанные на слегка различающихся ее представлениях.</p>
     </section>
     <section>
      <title>
       <p>4.5.1. Программа 1</p>
      </title>
      <p>Вначале нужно выбрать способ представления позиции на доске. Один из наиболее естественных способов — представить позицию в виде списка из восьми элементов, каждый из которых соответствует одному из ферзей. Каждый такой элемент будет описывать то поле доски, на которой стоит соответствующий ферзь. Далее, каждое поле доски можно описать с помощью пары координат (X и Y), где каждая координата - целое число от 1 до 8. В программе мы будем записывать такую пару в виде</p>
      <p><code>X / Y</code></p>
      <p>где оператор "<code>/</code>" обозначает, конечно, не деление, а служит лишь для объединения координат поля в один элемент списка. На рис. 4.6 показано одно из решений задачи о восьми ферзях и его запись в виде списка.</p>
      <p>После того, как мы выбрали такое представление, задача свелась к нахождению списка вида:</p>
      <p><code>[X1/Y1, X2/Y2, X3/Y3, X4/Y4, X5/Y5, X6/Y6, X7/Y7, X8/Y8]</code></p>
      <p>удовлетворяющего требованию отсутствия нападений. Наша процедура <code>решение</code> должна будет найти подходящую конкретизацию переменных <code>X1</code>, <code>Y1</code>, <code>Х2</code>, <code>Y2</code>, <strong>…</strong>, <code>Х8</code>, <code>Y8</code>. Поскольку мы знаем, что все ферзи должны находиться на разных вертикалях во избежание нападений по вертикальным линиям, мы можем сразу же ограничить перебор, чтобы облегчать поиск решения. Можно поэтому сразу зафиксировать X-координаты так, чтобы список, изображающий решение, удовлетворял следующему, более конкретному шаблону:</p>
      <p><code>[1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]</code></p>
      <image l:href="#_41.png"/>
      <p><strong>Рис. 4.6.</strong> Решение задачи о восьми ферзях. Эта позиция может быть представлена в виде списка <code>[1/4, 2/2, 3/7, 4/3, 5/6, 6/8, 7/5, 8/1]</code>.</p>
      <p>Нас интересует решение для доске размером 8&#215;8. Однако, как это часто бывает в программировании, ключ к решению легче найти, рассмотрев более общую постановку задачи. Как это ни парадоксально, но часто оказывается, что решение более общей задачи легче сформулировать, чем решение более частной, исходной задачи; после этого исходная задача решается просто как частный случай общей задачи.</p>
      <p>Основная часть работы при таком подходе ложится на нахождение правильного обобщения исходной задачи. В нашем случае хорошей является идея обобщать задачу в отношении количества ферзей (количества вертикалей в списке), разрешив количеству ферзей принимать любое значение, включая нуль. Тогда отношение решение можно сформулировать, рассмотрев два случая:</p>
      <p><emphasis>Случай 1</emphasis>. Список ферзей пуст. Пустой список без сомнения является решением, поскольку нападений в этом случае нет.</p>
      <p><emphasis>Случай 2</emphasis>. Список ферзей не пуст. Тогда он выглядит так:</p>
      <p><code>[ X/Y | Остальные ]</code></p>
      <p>В случае 2 первый ферзь находится на поле <code>X / Y</code>, а остальные — на полях, указанных в списке <code>Остальные</code>. Если мы хотим, чтобы это было решением, то должны выполняться следующие условия:</p>
      <p>(1) Ферзи, перечисленные в списке <code>Остальные</code>, не должны бить друг друга; т.е. список <code>Остальные</code> сам должен быть решением.</p>
      <p>(2) X и Y должны быть целыми числами от 1 до 8.</p>
      <p>(3) Ферзь, стоящий на поле <code>X / Y</code>, не должен бить ни одного ферзя из списка <code>Остальные</code>.</p>
      <p>Чтобы запрограммировать первое условие, можно воспользоваться самим отношением <code>решение</code>. Второе условие можно сформулировать так: Y должен принадлежать списку целых чисел от 1 до 8. т.е. <code>[1, 2, 3, 4, 5, 6, 7, 8]</code>. С другой стороны, о координате X можно не беспокоиться, поскольку список-решение должен соответствовать шаблону, у которого X-координаты уже определены. Поэтому X гарантированно получит правильное значение от 1 до 8. Третье условие можно обеспечить с помощью нового отношения <code>небьет</code>. Все это можно записать на Прологе так:</p>
      <p><code>решение( [X/Y | Остальные] ) :-</code></p>
      <p><code> решение( Остальные),</code></p>
      <p><code> принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] ),</code></p>
      <p><code> небьет( X/Y, Остальные).</code></p>
      <p>Осталось определить отношение <code>небьет</code>:</p>
      <p><code>небьет( Ф, Фспис)</code></p>
      <p>И снова его описание можно разбить на два случая:</p>
      <p>(1) Если список <code>Фспис</code> пуст, то отношение, конечно, выполнено, потому что некого бить (нет ферзя, на которого можно было бы напасть).</p>
      <p>(2) Если <code>Фспис</code> не пуст, то он имеет форму</p>
      <p><code>[Ф1 | Фспис1]</code></p>
      <p>и должны выполняться два условия:</p>
      <p> (а) ферзь на поле Ф не должен бить ферзя на поле Ф1 и</p>
      <p> (b) ферзь на поле Ф не должен бить ни одного ферзя из списка <code>Фспис1</code>.</p>
      <p>Выразить требование, чтобы ферзь, находящийся на некотором поле, не бил другое поле, довольно просто: эти поля не должны находиться на одной и той же горизонтали, вертикали или диагонали: Наш шаблон решения гарантирует, что все ферзи находятся на разных вертикалях, поэтому остается только обеспечить, чтобы</p>
      <p>• Y-координаты ферзей были различны и</p>
      <p>• ферзи не находились на одной диагонали, т.е. расстояние между полями по направлению X не должно равняться расстоянию между ними по Y.</p>
      <p>На рис. 4.7 приведен полный текст программы. Чтобы облегчить ее использование, необходимо добавить список-шаблон. Это можно сделать в запросе на генерацию решений. Итак:</p>
      <p><code>?-  шаблон( S), решение( S).</code></p>
      <empty-line/>
      <p><code>решение( [] ).</code></p>
      <p><code>решение( [X/Y | Остальные ] ) :-</code></p>
      <p><code>  % Первый ферзь на поле X/Y,</code></p>
      <p><code>  % остальные ферзи на полях из списка Остальные</code></p>
      <p><code> решение( Остальные),</code></p>
      <p><code> принадлежит Y, [1, 2, 3, 4, 5, 6, 7, 8] ),</code></p>
      <p><code> небьет( X/Y | Остальные).</code></p>
      <p><code>  % Первый ферзь не бьет остальных</code></p>
      <empty-line/>
      <p><code>небьет( _, [ ]). % Некого бить</code></p>
      <p><code>небьет( X/Y, [X1/Y1 | Остальные] ) :-</code></p>
      <p><code> Y =\= Y1,       % Разные Y-координаты</code></p>
      <p><code> Y1-Y =\= X1-X   % Разные диагонали</code></p>
      <p><code> Y1-Y =\= X-X1,</code></p>
      <p><code> небьет( X/Y, Остальные).</code></p>
      <empty-line/>
      <p><code>принадлежит( X, [X | L] ).</code></p>
      <p><code>принадлежит( X, [Y | L] ) :-</code></p>
      <p><code> принадлежит( X, L).</code></p>
      <empty-line/>
      <p><code>% Шаблон решения</code></p>
      <p><code>шаблон( [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]).</code></p>
      <p><strong>Рис. 4.7.</strong>  Программа 1 для задачи о восьми ферзях.</p>
      <empty-line/>
      <p>Система будет генерировать решения в таком виде:</p>
      <p><code>S = [1/4, 2/2, 3/7, 4/3, 5/6, 6/8, 7/5, 8/1];</code></p>
      <p><code>S = [1/5, 2/2, 3/4, 4/7, 5/3, 6/8, 7/6, 8/1];</code></p>
      <p><code>S = [1/3, 2/5, 3/2, 4/8, 5/6, 6/4, 7/7, 8/1].</code></p>
      <p><code>...</code></p>
      <subtitle>Упражнение</subtitle>
      <p><strong>4.6.</strong> При поиске решения программа, приведенная на рис. 4.7, проверяет различные значения Y-координат ферзей. В каком месте программы задается порядок перебора альтернативных вариантов? Как можно без труда модифицировать программу, чтобы этот порядок изменился? Поэкспериментируйте с разными порядками, имея в виду выяснить, как порядок перебора альтернатив влияет на эффективность программы.</p>
     </section>
     <section>
      <title>
       <p>4.5.2. Программа 2</p>
      </title>
      <p>В соответствии с принятым в программе 1 представлением доски каждое решение имело вид</p>
      <p><code>[1/Y1, 2/Y2, 3/Y3, ..., 8/Y8]</code></p>
      <p>так как ферзи расставлялись попросту в последовательных вертикалях. Никакая информация не была бы потеряна, если бы X-координаты были пропущены. Поэтому можно применить более экономное представление позиции на доске, оставив в нем только Y-координаты ферзей:</p>
      <p><code>[Y1, Y2, Y3, ..., Y8]</code></p>
      <p>Чтобы не было нападений по горизонтали, никакие два ферзя не должны занимать одну и ту же горизонталь. Это требование накладывает ограничение на Y-координаты: ферзи должны занимать все горизонтали с 1-й по 8-ю. Остается только выбрать <emphasis>порядок</emphasis> следования этих восьми номеров. Каждое решение представляет собой поэтому одну из перестановок списка:</p>
      <p><code>[1, 2, 3, 4, 5, 6, 7, 8]</code></p>
      <p>Такая перестановка S является решением, если каждый ферзь в ней не находится под боем (список S — "безопасный"). Поэтому мы можем написать:</p>
      <p><code>решение( S) :-</code></p>
      <p><code> перестановка( [1, 2, 3, 4, 5, 6, 7, 8], S),</code></p>
      <p><code> безопасный( S).</code></p>
      <image l:href="#_42.png"/>
      <p><strong>Рис. 4.8.</strong> (а) Расстояние по X между <code>Ферзь</code> и <code>Остальные</code> равно 1. (b) Расстояние по X между <code>Ферзь</code> и <code>Остальные</code> равно 3</p>
      <p>Отношение <code>перестановка</code> мы уже определила в гл. 3, а вот отношение <code>безопасный</code> нужно еще определить. Это определение можно разбить на два случая:</p>
      <p>(1) S — пустой список. Тогда он, конечно, безопасный, ведь нападать не на кого.</p>
      <p>(2) S — непустой список вида <code>[Ферзь | Остальные]</code>. Он безопасный, если список <code>Остальные</code> — безопасный и <code>Ферзь</code> не бьет ни одного ферзя из списка <code>Остальные</code>.</p>
      <p>На Прологе это выглядит так:</p>
      <p><code>безопасный( []).</code></p>
      <p><code>безопасный( [Ферзь | Остальные ] :-</code></p>
      <p><code> безопасный( Остальные),</code></p>
      <p><code> небьет(Ферзь | Остальные).</code></p>
      <p>В этой программе отношение <code>небьет</code> более хитрое.</p>
      <empty-line/>
      <p><code>решение( Ферзи) :-</code></p>
      <p><code> перестановка( [1, 2, 3, 4, 5, 6, 7, 8], Ферзи),</code></p>
      <p><code> безопасный( Ферзи).</code></p>
      <empty-line/>
      <p><code>перестановка( [], []).</code></p>
      <p><code>перестановка( [Голова | Хвост], СписПер) :-</code></p>
      <p><code> перестановка( Хвост, ХвостПер),</code></p>
      <p><code> удалить( Голова, СписПер, ХвостПер).</code></p>
      <p><code>  % Вставка головы в переставленный хвост</code></p>
      <empty-line/>
      <p><code>удалить( А, [А | Список).</code></p>
      <p><code>удалять( А, [В | Список], [В, Список1] ) :-</code></p>
      <p><code> удалить( А, Список, Список1).</code></p>
      <empty-line/>
      <p><code>безопасный( []).</code></p>
      <p><code>безопасный( [Ферзь | Остальные]) :-</code></p>
      <p><code> безопасный( Остальные),</code></p>
      <p><code> небьет( Ферзь, Остальные, 1).</code></p>
      <empty-line/>
      <p><code>небьет( _, [], _ ).</code></p>
      <p><code>небьет( Y, [Y1 | СписY], РасстХ) :-</code></p>
      <p><code> Y1-Y =\= РасстХ,</code></p>
      <p><code> Y-Y1 =\= РасстХ,</code></p>
      <p><code> Расст1 is РасстХ + 1,</code></p>
      <p><code> небьет( Y, СписY, Расст1).</code></p>
      <p><strong>Рис. 4.9.</strong> Программа 2 для задачи о восьми ферзях.</p>
      <empty-line/>
      <p>Трудность состоит в том, что расположение ферзей определяется только их Y-координатами, а X-координаты в представлении позиции не присутствуют в явном виде. Этой трудности можно избежать путем небольшого обобщения отношения <code>небьет</code>, как это показано на рис. 4.8. Предполагается, что цель</p>
      <p><code>небьет( Ферзь, Остальные)</code></p>
      <p>обеспечивает отсутствие нападении ферзя <code>Ферзь</code> на поля списка <code>Остальные</code> в случае, когда расстояние по X между <code>Ферзь</code> и <code>Остальные</code> равно 1. Остается рассмотреть более общий случай произвольного расстояния. Для этого мы добавим его в отношение <code>небьет</code> в качестве третьего аргумента:</p>
      <p><code>небьет( Ферзь, Остальные, РасстХ)</code></p>
      <p>Соответственно и цель <code>небьет</code> в отношении <code>безопасный</code> должна быть изменена на</p>
      <p><code>небьет( Ферзь, Остальные, 1)</code></p>
      <p>Теперь отношение <code>небьет</code> может быть сформулировано в соответствии с двумя случаями, в зависимости от списка <code>Остальные</code>: если он пуст, то бить некого и, естественно, нет нападений; если же он не пуст, то <code>Ферзь</code> не должен бить первого ферзя из списка <code>Остальные</code> (который находится от ферзя <code>Ферзь</code> на расстоянии <code>РасстХ</code> вертикалей), а также ферзей из хвоста списка <code>Остальные</code>, находящихся от него на расстоянии <code>РасстХ + 1</code>. Эти соображения приводят к программе, изображенной на рис. 4.9.</p>
     </section>
     <section>
      <title>
       <p>4.5.3. Программа 3</p>
      </title>
      <p>Наша третья программа для задачи о восьми ферзях опирается на следующие соображения. Каждый ферзь должен быть размещен на некотором поле, т.е. на некоторой вертикали, некоторой горизонтали, а также на пересечении каких-нибудь двух диагоналей. Для того, чтобы была обеспечена безопасность каждого ферзя, все они должны располагаться в разных вертикалях, разных горизонталях и в разных диагоналях (как идущих сверху вниз, так и идущих снизу вверх). Естественно поэтому рассмотреть более богатую систему представления с четырьмя координатами:</p>
      <p> <emphasis>x</emphasis> вертикали</p>
      <p> <emphasis>у</emphasis> горизонтали</p>
      <p> <emphasis>u</emphasis> диагонали, идущие снизу вверх</p>
      <p> <emphasis>v</emphasis> диагонали, идущие сверху вниз</p>
      <p>Эти координаты не являются независимыми: при заданных <emphasis>x</emphasis> и <emphasis>у</emphasis>, <emphasis>u</emphasis> и <emphasis>v</emphasis> определяются однозначно (пример на рис. 4.10). Например,</p>
      <p><emphasis>u = x - у</emphasis></p>
      <p><emphasis>v = x + у</emphasis></p>
      <image l:href="#_43.png"/>
      <p><strong>Рис. 4.10.</strong> Связь между вертикалями, горизонталями и диагоналями. Помеченное поле имеет следующие координаты: <emphasis>x</emphasis> = 2,  <emphasis>у</emphasis> = 4, <emphasis>u</emphasis> = 2 - 4 = -2, <emphasis>v</emphasis> = 2 + 4 = 6.</p>
      <p>Области изменения всех четырех координат таковы:</p>
      <p><code>Dx = [1, 2, 3, 4, 5, 6, 7, 8]</code></p>
      <p><code>Dy = [1, 2, 3, 4, 5, 6, 7, 8]</code></p>
      <empty-line/>
      <p><code>Du = [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]</code></p>
      <p><code>Dv = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]</code></p>
      <p>Задачу о восьми ферзях теперь можно сформулировать следующим образом: выбрать восемь четверок (X, Y, U, V), входящих в области изменения (X в Dx, Y в Dy и т.д.), так, чтобы ни один их элемент не выбирался дважды из одной области. Разумеется, выбор X и Y определяет выбор U и V. Решение при такой постановке задачи может быть вкратце таким: при заданных 4-x областях изменения выбрать позицию для первого ферзя, вычеркнуть соответствующие элементы из 4-x областей изменения, а затем использовать оставшиеся элементы этих областей для размещения остальных ферзей. Программа, основанная на таком подходе, показана на рис. 4.11. Позиция на доске снова представляется списком Y-координат. Ключевым отношением в этой программе является отношение</p>
      <p><code>peш( СписY, Dx, Dy, Du, Dv)</code></p>
      <p>которое конкретизирует Y-координаты (в <code>СписY</code>) ферзей, считая, что они размещены в последовательных вертикалях, взятых из Dx. Все Y-координаты и соответствующие координаты U и V берутся из списков Dy, Du и Dv. Главную процедуру <code>решение</code> можно запустить вопросом</p>
      <p><code>?-  решение( S)</code></p>
      <p>Это вызовет запуск <code>реш</code> с полными областями изменения координат, что соответствует пространству задачи о восьми ферзях.</p>
      <empty-line/>
      <p><code>решение( СписY) :-</code></p>
      <p><code> реш( СписY, % Y-координаты ферзей</code></p>
      <p><code> [1, 2, 3, 4, 5, 6, 7, 8],</code></p>
      <p><code>  % Область изменения Y-координат</code></p>
      <p><code> [1, 2, 3, 4, 5, 6, 7, 8],</code></p>
      <p><code>  % Область изменения X-координат</code></p>
      <p><code> [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7],</code></p>
      <p><code>  % Диагонали, идущие снизу вверх</code></p>
      <p><code> [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 14, 15, 16] ).</code></p>
      <p><code>  % Диагонали, идущие сверху вниз</code></p>
      <empty-line/>
      <p><code>реш([], [], Dy, Du, Dv).</code></p>
      <p><code>реш( [Y | СписY], [X | Dx1], Dy, Du, Dv) :-</code></p>
      <p><code> удалить( Y, Dy, Dy1), % Выбор Y-координаты</code></p>
      <p><code> U is X-Y,             % Соответствующая диагональ вверх</code></p>
      <p><code> удалить( U, Du, Du1), % Ее удаление</code></p>
      <p><code> V is X+Y,             % Соответствующая диагональ вниз</code></p>
      <p><code> удалить( V, Dv, Dv1), % Ее удаление</code></p>
      <p><code> реш( СписY, Dх1, Dy1, Du1, Dv1).</code></p>
      <p><code>  % Выбор из оставшихся значений</code></p>
      <empty-line/>
      <p><code>удалить( А, [А | Список], Список).</code></p>
      <p><code>удалить(A, [В | Список ], [В | Список1 ] ) :-</code></p>
      <p><code> удалить( А, Список, Список1).</code></p>
      <p><strong>Рис. 4.11.</strong> Программа 3 для задачи о восьми ферзях.</p>
      <empty-line/>
      <p>Процедура реш универсальна в том смысле, что ее можно использовать для решения задачи об N ферзях (на доске размером N&#215;N). Нужно только правильно задеть области Dx, Dy и т.д.</p>
      <p>Удобно автоматизировать получение этих областей. Для этого нам потребуется процедура</p>
      <p><code>генератор( N1, N2, Список)</code></p>
      <p>которая для двух заданных целых чисел N1 и N2 порождает список</p>
      <p><code>Список = [N1, N1 + 1, N1 + 2, ..., N2 - 1, N2]</code></p>
      <p>Вот она:</p>
      <p><code>генератор( N, N, [N]).</code></p>
      <p><code>генератор( Nl, N2, [Nl | Список]) :-</code></p>
      <p><code> N1 &lt; N2,</code></p>
      <p><code> М is N1 + 1,</code></p>
      <p><code> генератор( М, N2, Список).</code></p>
      <p>Главную процедуру решение нужно соответствующим образом обобщить:</p>
      <p><code>решение( N, S)</code></p>
      <p>где N — это размер доски, а S — решение, представляемое в виде списка Y-координат N ферзей. Вот обобщенное отношение <code>решение</code>:</p>
      <p><code>решение( N, S) :-</code></p>
      <p><code> генератор( 1, N, Dxy),</code></p>
      <p><code> Nu1 is 1 - N, Nu2 is N - 1,</code></p>
      <p><code> генератор( Nu1, Nu2, Du),</code></p>
      <p><code> Nv2 is N + N,</code></p>
      <p><code> генератор( 2, Nv2, Dv),</code></p>
      <p><code> реш( S, Dxy, Dxy, Du, Dv).</code></p>
      <p>Например, решение задачи о 12 ферзях будет получено с помощью:</p>
      <p><code>?-  решение( 12, S).</code></p>
      <empty-line/>
      <p><code>S = [1, 3, 5, 8, 10, 12, 6, 11, 2, 7, 9, 4]</code></p>
     </section>
     <section>
      <title>
       <p>4.5.4. Заключительные замечания</p>
      </title>
      <p>Три решения задачи о восьми ферзях показывают, как к одной и той же задаче можно применять различные подходы. Мы варьировали также и представление данных. В одних случаях это представление было более экономным, в других — более наглядным и, до некоторой степени, избыточным. К недостаткам более экономного представления можно отнести то, что какая-то информация всякий раз, когда она требовалась, должна была перевычисляться.</p>
      <p>В некоторых случаях основным шагом к решению было обобщение задачи. Как ни парадоксально, но при рассмотрении более общей задачи решение оказывалось проще сформулировать. Принцип такого обобщения — стандартный прием программирования, и его можно часто применять.</p>
      <p>Из всех трех программ третья лучше всего показывает, как подходить к общей задаче построения структуры из заданного множества элементов при наличии ограничений.</p>
      <p>Возникает естественный вопрос: " Какая из трех программ наиболее эффективна?" В этом отношение программа 2 значительно хуже двух других, а эти последние — одинаковы. Причина в том, что основанная на перестановках программа 2 строит все перестановки, тогда как две другие программы способны отбросить плохую перестановку не дожидаясь, пока она будет полностью построена. Программа 3 наиболее эффективна. Она избегает некоторых арифметических вычислений, результаты которых уже сразу заложены в избыточное представление доски, используемое этой программой.</p>
      <subtitle>Упражнение</subtitle>
      <p><strong>4.7.</strong> Пусть поля доски представлены парами своих координат в виде <code>X/Y</code>, где как X, так и Y принимают значения от 1 до 8.</p>
      <p>(а) Определите отношение <code>ходконя( Поле1, Поле2)</code>, соответствующее ходу коня на шахматной доске. Считайте, что <code>Поле1</code> имеет всегда конкретизированные координаты, в то время, как координаты поля <code>Поле2</code> могут и не быть конкретизированы. Например:</p>
      <p><code>?- ходконя( 1/1, S).</code></p>
      <empty-line/>
      <p><code>S = 3/2;</code></p>
      <p><code>S = 2/3;</code></p>
      <empty-line/>
      <p><code>no      </code>(нет)</p>
      <p>(b) Определите отношение <code>путьконя( Путь)</code>, где <code>Путь</code> — список полей, представляющих соответствующую правилам игры последовательность ходов коня по пустой доске.</p>
      <p>(с) Используя отношение <code>путьконя</code>, напишите вопрос для нахождения любого пути, состоящего из 4-x ходов, и начинающегося с поля 2/1, а заканчивающегося на противоположном крае доски (Y = 8). Этот путь должен еще проходить после второго хода через поле 5/4.</p>
     </section>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>Примеры, рассмотренные в данном разделе, иллюстрируют некоторые достоинства и характерные черты программирования на Прологе:</p>
     <p>• Базу данных можно естественным образом представить в виде множества прологовских фактов.</p>
     <p>• Такие механизмы Пролога, как вопросы и сопоставление, можно гибко использовать для получения информации из базы данных. Кроме этого можно использовать вспомогательные процедуры-утилиты, еще больше облегчающие взаимодействие с конкретной базой данных.</p>
     <p>• <emphasis>Абстракцию данных</emphasis> можно рассматривать как метод программирования, который облегчает работу со сложными структурами данных и вносит большую ясность и наглядность в программы. В Прологе легко соблюдать основные принципы абстракции данных.</p>
     <p>• Часто легко можно осуществить перевод абстрактных математических конструкций, таких как автоматы, на язык определений Пролога, готовых к выполнению.</p>
     <p>• Как это было в случае восьми ферзей, многие задачи допускают различные подходы, связанные с разными представлениями этих задач. Часто внесение избыточности в представление экономит вычисления. Происходит как бы проигрыш в рабочем пространстве, но выигрыш во времени.</p>
     <p>• Часто основным шагом на пути к решению оказывается обобщение задачи. Парадоксально, но рассмотрение более общей задачи позволяет облегчить формулировку решения.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 5</p>
     <p>Управление перебором</p>
    </title>
    <section>
     <p>Мы уже видели, что программист может управлять процессом вычислений по программе, располагая ее предложения и цели в том или ином порядке. В данной главе мы рассмотрим еще одно средство управления, получившее название "отсечение" (cut) и предназначенное для ограничения автоматического перебора.</p>
    </section>
    <section>
     <title>
      <p>5.1. Ограничение перебора</p>
     </title>
     <section>
      <p>В процессе достижения цели пролог-система осуществляет автоматический перебор вариантов, делая возврат при неуспехе какого-либо из них. Такой перебор — полезный программный механизм, поскольку он освобождает пользователя от необходимости программировать его самому. С другой стороны, ничем не ограниченный перебор может стать источником неэффективности программы. Поэтому иногда требуется его ограничить или исключить вовсе. Для этого в Прологе предусмотрена конструкция "отсечение".</p>
      <image l:href="#_44.png"/>
      <p><strong>Рис. 5.1.</strong> Двухступенчатая функция</p>
      <p>Давайте сначала рассмотрим простую программу, процесс вычислений, по которой содержит ненужный перебор. Мы выделим те точки этого процесса, где перебор бесполезен и ведет к неэффективности.</p>
      <p>Рассмотрим двухступенчатую функцию, изображенную на рис. 5.1. Связь между X и Y можно определить с помощью следующих трех правил:</p>
      <p><emphasis>Правило 1</emphasis>: если X &lt; 3, то Y = 0</p>
      <p><emphasis>Правило 2</emphasis>: если 3 &#8804; X и X &lt; 6, то Y = 2</p>
      <p><emphasis>Правило 3</emphasis>: если 6 &#8804; X, то Y = 4</p>
      <p>На Прологе это можно выразите с помощью бинарного отношения</p>
      <p><code>f( X, Y)</code></p>
      <p>так:</p>
      <p><code>f( X, 0) :- X &lt; 3.          % Правило 1</code></p>
      <p><code>f( X, 2) :- 3 =&lt; X,  X &lt; 6. % Правило 2</code></p>
      <p><code>f( X, 4) :- 6 =&lt; X.         % Правило 3</code></p>
      <p>В этой программе предполагается, конечно, что к моменту начала вычисления <code>f( X, Y) X</code> уже конкретизирован каким-либо числом; это необходимо для выполнения операторов сравнения.</p>
      <p>Мы проделаем с этой программой два эксперимента. Каждый из них обнаружит в ней свой источник неэффективности, и мы устраним оба этих источника по очереди, применив оператор отсечения. </p>
     </section>
     <section>
      <title>
       <p>5.1.1. Эксперимент 1</p>
      </title>
      <p>Проанализируем, что произойдет, если задать следующий вопрос:</p>
      <p><code>?- f( 1, Y), 2 &lt; Y.</code></p>
      <image l:href="#_45.png"/>
      <p><strong>Рис. 5.2.</strong> В точке, помеченной словом "ОТСЕЧЕНИЕ", уже известно, что правила 2 и 3 должны потерпеть неудачу.</p>
      <p>При вычислении первой цели <code>f( 1, Y)</code> Y конкретизируется нулем. Поэтому вторая цель становится такой:</p>
      <p><code>2 &lt; 0</code></p>
      <p>Она терпит неудачу, а поэтому и весь список целей также терпит неудачу. Это очевидно, однако перед тем как признать, что такому списку целей удовлетворить нельзя, пролог-система при помощи возвратов попытается проверить еще две бесполезные в данном случае альтернативы. Пошаговое описание процесса вычислений приводится на рис. 5.2.</p>
      <p>Три правила, входящие в отношение <code>f</code>, являются взаимоисключающими, поэтому успех возможен самое большее в одном из них. Следовательно, мы (но не пролог-система) знаем, что, как только успех наступил в одном из них, нет смысла проверять остальные, поскольку они все равно обречены на неудачу. В примере, приведенном на рис. 5.2, о том, что в правиле 1 наступил успех, становится известно в точке, обозначенной словом "ОТСЕЧЕНИЕ". Для предотвращения бессмысленного перебора мы должны явно указать пролог-системе, что <emphasis>не нужно</emphasis> осуществлять возврат из этой точки. Мы можем сделать это при помощи конструкции отсечения. "Отсечение" записывается в виде символа <strong>'</strong><code>!</code><strong>'</strong>, который вставляется между целями и играет роль некоторой псевдоцели. Вот наша программа, переписанная с использованием отсечения:</p>
      <p><code>f( X, 0) :- X &lt; 3,  !.</code></p>
      <p><code>f( X, 2) :- 3 =&lt; X,  X &lt; 6,  !.</code></p>
      <p><code>f( X, 4) :- 6 =&lt; X.</code></p>
      <p>Символ  '<code>!</code>'  предотвращает возврат из тех точек программы, в которых он поставлен. Если мы теперь спросим</p>
      <p><code>?- f( 1, Y), 2 &lt; Y.</code></p>
      <p>то пролог-система породит левую ветвь дерева, изображенного на рис. 5.2. Эта ветвь потерпит неудачу на цели <code>2 &lt; 0</code>.   Система попытается сделать возврат, но вернуться она сможет не далее точки, помеченной в программе символом '<code>!</code>'.  Альтернативные ветви, соответствующие правилу 2 и правилу 3, порождены не будут.</p>
      <p>Новая программа, снабженная отсечениями, во всех случаях более эффективна, чем первая версия, в которой они отсутствуют. Неудачные варианты новая программа распознает всегда быстрее, чем старая.</p>
      <p>Вывод: добавив отсечения, мы повысили эффективность. Если их теперь убрать, программа породит тот же результат, только на его получение она истратит скорее всего больше времени. Можно сказать, что в нашем случае после введения отсечений мы изменили только процедурный смысл программы, оставив при этом ее декларативный смысл в неприкосновенности. В дальнейшем мы покажем, что использование отсечения может также затронуть и декларативный смысл программы.</p>
     </section>
     <section>
      <title>
       <p>5.1.2. Эксперимент 2</p>
      </title>
      <p>Проделаем теперь еще один эксперимент со второй версией нашей программы. Предположим, мы задаем вопрос:</p>
      <p><code>?- f( 7, Y).</code></p>
      <p><code>Y = 4</code></p>
      <p>Проанализируем, что произошло. Перед тем, как был получен ответ, система пробовала применить все три правила. Эти попытки породили следующую последовательность целей:</p>
      <p><emphasis>Попытка применить правило 1:</emphasis></p>
      <p> 7 &lt; 3 терпит неудачу, происходит возврат, и попытка применить правило 2 (точка отсечения достигнута не была)</p>
      <p><emphasis>Попытка применить правило 2:</emphasis></p>
      <p> 3 &#8804; 7  успех, но 7 &lt; 6 терпит неудачу; возврат и попытка применить правило 3 (точка отсечения снова не достигнута)</p>
      <p><emphasis>Попытка применить правило 3:</emphasis></p>
      <p> 6 &#8804; 7 — успех</p>
      <p>Приведенные этапы вычисления обнаруживают еще один источник неэффективности. В начале выясняется, что <code>X &lt; 3</code> не является истиной (7 &lt; 3 терпит неудачу). Следующая цель — <code>3 =&lt; X</code> (3 &#8804; 7 — успех). Но нам известно, что, если первая проверка неуспешна, то вторая обязательно будет успешной, так как второе целевое утверждение является отрицанием первого. Следовательно, вторая проверка лишняя и соответствующую цель можно опустить. То же самое верно и для цели <code>6 =&lt; X</code> в правиле 3. Все эти соображения приводят к следующей, более экономной формулировке наших трех правил:</p>
      <p> если X &lt; 3, то Y = 0</p>
      <p> иначе, если 3 &#8804; X  и X &lt; 6, то Y = 2,</p>
      <p> иначе Y = 4.</p>
      <p>Теперь мы можем опустить в нашей программе те условия, которые обязательно выполняются при любом вычислении. Получается третья версия программы:</p>
      <p><code>f( X, 0) :- X &lt; 3, !.</code></p>
      <p><code>f( X, 2) :- X &lt; 6, !.</code></p>
      <p><code>f( X, 4).</code></p>
      <p>Эта программа дает тот же результат, что и исходная, но более эффективна, чем обе предыдущие. Однако, что будет, если мы <emphasis>теперь</emphasis> удалим отсечения? Программа станет такой:</p>
      <p><code>f( X, 0) :- X &lt; 3.</code></p>
      <p><code>f( X, 2) :- X &lt; 6.</code></p>
      <p><code>f( X, 4).</code></p>
      <p>Она может порождать различные решения, часть из которых неверны. Например:</p>
      <p><code>?- f( 1, Y).</code></p>
      <empty-line/>
      <p><code>Y = 0;</code></p>
      <p><code>Y = 2;</code></p>
      <p><code>Y = 4;</code></p>
      <p><code>nо    </code>(нет)</p>
      <p>Важно заметить, что в последней версии, в отличие от предыдущей, отсечения затрагивают не только процедурное поведение, но изменяют также и декларативный смысл программы.</p>
      <p>Более точный смысл механизма отсечений можно сформулировать следующим образом:</p>
      <cite>
       <p>Назовем "целью-родителем" ту цель, которая сопоставилась с головой предложения, содержащего отсечение. Когда в качестве цели встречается отсечение, такая цель сразу же считается успешной и при этом заставляет систему принять те альтернативы, которые были выбраны с момента активизации цели-родителя до момента, когда встретилось отсечение. Все оставшиеся в этом промежутке (от цели-родителя до отсечения) альтернативы не рассматриваются.</p>
      </cite>
      <p>Чтобы прояснить смысл этого определения, рассмотрим предложение вида</p>
      <p><code>H :- В1, В2, ..., Вm, !, ..., Вn.</code></p>
      <p>Будем считать, что это предложение активизировалось, когда некоторая цель G сопоставилась с H. Тогда G является целью-родителем. В момент, когда встретилось отсечение, успех уже наступил в целях <code>В1</code>, …, <code>Вm</code>. При выполнении отсечения это (текущее) решение <code>В1</code>, …, <code>Вm</code> "замораживается" и все возможные оставшиеся альтернативы больше не рассматриваются. Далее, цель G связывается теперь с этим предложением: любая попытка сопоставить  G  с головой какого-либо другого предложения пресекается.</p>
      <p>Применим эти правила к следующему примеру:</p>
      <p><code>С :- P, Q, R, !, S, T, U.</code></p>
      <p><code>С :- V.</code></p>
      <p><code>А :- В, С, D.</code></p>
      <p><code>?- А.</code></p>
      <p>Здесь А, В, С, D, P и т.д. имеют синтаксис термов. Отсечение повлияет на вычисление цели С следующим образом. Перебор будет возможен в списке целей P, Q, R; однако, как только точка отсечения будет достигнута, все альтернативные решения для этого списка изымаются из рассмотрения. Альтернативное предложение, входящее в С:</p>
      <p><code>С :- V.</code></p>
      <p>также не будет учитываться. Тем не менее, перебор будет возможен в списке целей S, T, U. "Цель-родитель" предложения, содержащего отсечения, — это цель С в предложении</p>
      <p><code>А :- В, С, D.</code></p>
      <p>Поэтому отсечение повлияет только на цель С. С другой стороны, оно будет "невидимо" из цели А. Таким образом, автоматический перебор все равно будет происходить в списке целей В, С, D, вне зависимости от наличия отсечения в предложении, которое используется для достижения С.</p>
     </section>
    </section>
    <section>
     <title>
      <p>5.2. Примеры, использующие отсечение </p>
     </title>
     <section>
      <title>
       <p>5.2.1.  Вычисление максимума</p>
      </title>
      <p>Процедуру нахождения наибольшего из двух чисел можно запрограммировать в виде отношения</p>
      <p><code>mах( X, Y, Мах)</code></p>
      <p>где Мах = X, если X больше или равен Y, и Мах есть Y, если X меньше Y. Это соответствует двум таким предложениям:</p>
      <p><code>mах( X, Y, X) :- X &gt;= Y.</code></p>
      <p><code>max( X, Y, Y) :- X &lt; Y.</code></p>
      <p>Эти правила являются взаимно исключающими. Если выполняется первое, второе обязательно потерпит неудачу. Если неудачу терпит первое, второе обязательно должно выполниться. Поэтому возможна более экономная формулировка, использующая понятие "иначе":</p>
      <p> если X &#8805; Y, то Мах = X,</p>
      <p> иначе Мах = Y.</p>
      <p>На Прологе это записывается при помощи отсечения:</p>
      <p><code>mах( X, Y, X) :- X &gt;= Y,  !.</code></p>
      <p><code>mах( X, Y, Y).</code></p>
     </section>
     <section>
      <title>
       <p>5.2.2. Процедура проверки принадлежности списку, дающая единственное решение </p>
      </title>
      <p>Для того, чтобы узнать, принадлежит ли X списку L, мы пользовались отношением</p>
      <p><code>принадлежит( X, L)</code></p>
      <p>Программа была следующей:</p>
      <p><code>принадлежит( X, [X | L] ).</code></p>
      <p><code>принадлежит X, [Y | L] ) :- принадлежит( X, L).</code></p>
      <p>Эта программа дает "недетерминированный" ответ: если X встречается в списке несколько раз, то будет найдено каждое его вхождение. Исправить этот недостаток не трудно: нужно только предотвратить дальнейший перебор сразу же после того, как будет найден первый X, а это произойдет, как только в первом предложении наступит успех. Измененная программа выглядит так:</p>
      <p><code>принадлежит( X, [X | L] ) :- !.</code></p>
      <p><code>принадлежит( X, [Y | L] ) :- принадлежит( X, L).</code></p>
      <p>Эта программа породит только одно решение. Например:</p>
      <p><code>?- принадлежит( X, [а, b, с] ).</code></p>
      <empty-line/>
      <p><code>X = а;</code></p>
      <p><code>nо    </code>(нет)</p>
     </section>
     <section>
      <title>
       <p>5.2.3. Добавление элемента к списку, если он в нем отсутствует (добавление без дублирования)</p>
      </title>
      <p>Часто требуется добавлять элемент X в список L только в том случае, когда в списке еще нет такого элемента. Если же X уже есть в L, тогда L необходимо оставить без изменения, поскольку нам не нужны лишние дубликаты X. Отношение <code>добавить</code> имеет три аргумента:</p>
      <p><code>добавить( X, L, L1)</code></p>
      <p>где X — элемент, который нужно добавить, L — список, в который его нужно добавить, L1 — результирующий новый список. Правила добавления можно сформулировать так:</p>
      <p> если X принадлежит к L, то L1 = L,</p>
      <p> иначе L1 — это список L с добавленным к нему элементом X.</p>
      <p>Проще всего добавлять X в начало списка L так, чтобы X стал головой списка L1. Запрограммировать это можно так:</p>
      <p><code>добавить( X, L, L) :- принадлежит( X, L), !.</code></p>
      <p><code>добавить( X, L, [X | L] ).</code></p>
      <p>Поведение этой процедуры можно проиллюстрировать следующим примером:</p>
      <p><code>?- добавить( а, [b,с], L).</code></p>
      <p><code>L = [a, b, c]</code></p>
      <empty-line/>
      <p><code>?- до6авить( X, [b, с], L).</code></p>
      <p><code>L = [b, с]</code></p>
      <p><code>X = b</code></p>
      <empty-line/>
      <p><code>?- добавить( а, [b, с, X], L).</code></p>
      <p><code>L = [b, с, а]</code></p>
      <p><code>X = а</code></p>
      <p>Этот пример поучителен, поскольку мы не можем легко запрограммировать "недублирующее добавление", не используя отсечения или какой-либо другой конструкции, полученной из него. Если мы уберем отсечение в только что рассмотренной программе, то отношение <code>добавить</code> будет добавлять дубликаты элементов, уже имеющихся в списке. Например:</p>
      <p><code>?- добавить( a, [a, b, c], L),</code></p>
      <p><code>L = [а, b, с]</code></p>
      <p><code>L = [а, а, b, с]</code></p>
      <p>Поэтому отсечение требуется здесь для правильного определения отношения, а не только для повышения эффективности. Этот момент иллюстрируется также и следующим примером.</p>
     </section>
     <section>
      <title>
       <p>5.2.4. Задача классификации объектов</p>
      </title>
      <p>Предположим, что у нас есть база данных, содержащая результаты теннисных партий, сыгранных членами некоторого клуба. Подбор пар противников для каждой партия не подчинялся какой-либо системе, просто каждый игрок встречался с несколькими противниками. Результаты представлены в программе в виде фактов, таких как</p>
      <p><code>победил( том, джон).</code></p>
      <p><code>победил( энн, том).</code></p>
      <p><code>победил( пат, джим).</code></p>
      <p>Мы хотим определить</p>
      <p><code>отношение класс( Игрок, Категория)</code></p>
      <p>которое распределяет игроков по категориям. У нас будет три категории:</p>
      <p> <code>победитель</code> — любой игрок, победивший во всех сыгранных им играх</p>
      <p> <code>боец</code> — любой игрок, в некоторых играх победивший, а в некоторых проигравший</p>
      <p> <code>спортсмен</code> — любой игрок, проигравший во всех сыгранных им партиях</p>
      <p>Например, если в нашем распоряжении есть лишь приведенные выше результаты, то ясно, что Энн и Пат — победители. Том — боец и Джим — спортсмен.</p>
      <p>Легко сформулировать правило для бойца:</p>
      <p> X — боец, если существует некоторый Y, такой, что X победил Y, и</p>
      <p>  существует некоторый Z, такой, что Z победил X.</p>
      <p>Теперь правило для победителя:</p>
      <p> X — победитель, если</p>
      <p>  X победил некоторого Y и</p>
      <p>  X не был побежден никем.</p>
      <p>Эта формулировка содержит отрицание "не", которое нельзя впрямую выразить при помощи тех возможностей Пролога, которыми мы располагаем к настоящему моменту. Поэтому оказывается, что формулировка отношения <code>победитель</code> должна быть более хитрой. Та же проблема возникает и при формулировке правил для отношения <code>спортсмен</code>. Эту проблему можно обойти, объединив определения отношений <code>победитель</code> и <code>боец</code> и использовав связку "иначе". Вот такая формулировка:</p>
      <p> Если X победил кого-либо и X был кем-то побежден,</p>
      <p> то X — боец,</p>
      <p> иначе, если X победил кого-либо,</p>
      <p>  то X — победитель, </p>
      <p>  иначе, если X был кем-то побежден,</p>
      <p>   то X — спортсмен.</p>
      <p>Такую формулировку можно сразу перевести на Пролог. Взаимные исключения трех альтернативных категорий выражаются при помощи отсечений:</p>
      <p><code>класс( X, боец) :-</code></p>
      <p><code> победил( X, _ ),</code></p>
      <p><code> победил( _, X),  !.</code></p>
      <empty-line/>
      <p><code>класс( X, победитель) :-</code></p>
      <p><code> победил( X, _ ),  !.</code></p>
      <empty-line/>
      <p><code>класс( X, спортсмен) :-</code></p>
      <p><code> победил( _, X).</code></p>
      <p>Заметьте, что использование отсечения в предложении для категории <code>победитель</code> не обязательно, что связано с особенностями наших трех классов.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>5.1.</strong> Пусть есть программа:</p>
      <p><code>p( 1).</code></p>
      <p><code>p( 2) :- !.</code></p>
      <p><code>p( 3).</code></p>
      <p>Напишите все ответы пролог-системы на следующие вопросы:</p>
      <p>(a) <code>?- p( X).</code></p>
      <p>(b) <code>?- p( X), p(Y).</code></p>
      <p>(c) <code>?- p( X), !, p(Y).</code></p>
      <p><strong>5.2.</strong> Следующие отношения распределяют числа на три класса - положительные, нуль и отрицательные:</p>
      <p><code>класс( Число, положительные) :- Число &gt; 0.</code></p>
      <p><code>класс( 0, нуль).</code></p>
      <p><code>класс( Число, отрицательные) :- Число &lt; 0.</code></p>
      <p>Сделайте эту процедуру более эффективной при помощи отсечений.</p>
      <p><strong>5.3.</strong> Определите процедуру</p>
      <p><code>разбить( Числа, Положительные, Отрицательные)</code></p>
      <p>которая разбивает список чисел на два списка: список, содержащий положительные числа (и нуль), и список отрицательных чисел. Например,</p>
      <p><code>разбить( [3, -1, 0, 5, -2], [3, 0, 5], [-1, -2] )</code></p>
      <p>Предложите две версии: одну с отсечением, другую — без.</p>
     </section>
    </section>
    <section>
     <title>
      <p>5.3. Отрицание как неуспех</p>
     </title>
     <p>"Мэри любит всех животных, кроме змей". Как выразить это на Прологе? Одну часть этого утверждения выразить легко: "Мэри любит всякого X, если X — животное". На Прологе это записывается так:</p>
     <p><code>любит( мэри, X) :- животное ( X).</code></p>
     <p>Но нужно исключить змей. Это можно сделать, использовав другую формулировку:</p>
     <p> Если X — змея, то "Мэри любит X" — не есть истина,</p>
     <p> иначе, если X — животное, то Мэри любит X.</p>
     <p>Сказать на Прологе, что что-то не есть истина, можно при помощи специальной цели <code>fail</code> (неуспех), которая всегда терпит неудачу, заставляя потерпеть неудачу и ту цель, которая является ее родителем. Вышеуказанная формулировка, переведенная на Пролог с использованием <code>fail</code>, выглядит так:</p>
     <p><code>любит( мэри, X) :-</code></p>
     <p><code> змея( X),  !,  fail.</code></p>
     <p><code>любит( Мэри, X) :-</code></p>
     <p><code> животное ( X).</code></p>
     <p>Здесь первое правило позаботится о змеях: если X — змея, то отсечение предотвратит перебор (исключая таким образом второе правило из рассмотрения), а <code>fail</code> вызовет неуспех. Эти два предложения можно более компактно записать в виде одного:</p>
     <p><code>любит( мэри, X):-</code></p>
     <p><code> змея( X), !, fail;</code></p>
     <p><code> животное ( X).</code></p>
     <p>Ту же идею можно использовать для определения отношения</p>
     <p><code>различны( X, Y)</code></p>
     <p>которое выполняется, если X и Y не совпадают. При этом, однако, мы должны быть точными, потому что "различны" можно понимать по-разному:</p>
     <p>• X и Y не совпадают буквально;</p>
     <p>• X и Y не сопоставимы;</p>
     <p>• значения арифметических выражений X и Y не равны.</p>
     <p>Давайте считать в данном случае, что X и Y различны, если они не сопоставимы. Вот способ выразить это на Прологе:</p>
     <p> Если X и Y сопоставимы, то</p>
     <p>  цель <code>различны( X, Y)</code> терпит неуспех</p>
     <p>  иначе цель <code>различны( X, Y)</code> успешна.</p>
     <p>Мы снова используем сочетание отсечения и <code>fail</code>:</p>
     <p><code>различны( X, X) :- !, fail.</code></p>
     <p><code>различны( X, Y).</code></p>
     <p>То же самое можно записать и в виде одного предложения:</p>
     <p><code>различны( X, Y) :-</code></p>
     <p><code> X = Y, !, fail;</code></p>
     <p><code> true.</code></p>
     <p>Здесь <code>true</code> — цель, которая всегда успешна.</p>
     <p>Эти примеры показывают, что полезно иметь унарный предикат "not" (не), такой, что</p>
     <p><code>nоt( Цель)</code></p>
     <p>истинна, если Цель не истинна. Определим теперь отношение not следующим образом:</p>
     <p> Если <code>Цель</code> успешна, то <code>not( Цель)</code> неуспешна,</p>
     <p> иначе <code>not( Цель)</code> успешна.</p>
     <p>Это определение может быть записано на Прологе так:</p>
     <p><code>not( P) :-</code></p>
     <p><code> P, !, fail;</code></p>
     <p><code> true.</code></p>
     <p>Начиная с этого момента мы будем предполагать, что  <code>not</code> — это встроенная прологовская процедура, которая ведет себя так, как это только что было определено. Будем также предполагать, что оператор <code>not</code> определен как префиксный, так что цель</p>
     <p><code>not( змея( X) )</code></p>
     <p>можно записывать и как</p>
     <p><code>not змея( X)</code></p>
     <p>Многие версии Пролога поддерживают такую запись. Если же приходится иметь дело с версией, в которой нет встроенного оператора <code>not</code>, его всегда можно определить самим.</p>
     <p>Следует заметить, что <code>not</code>, как он здесь определен с использованием неуспеха, не полностью соответствует отрицанию в математической логике. Эта разница может породить неожиданности в поведении программы, если оператором <code>not</code> пользоваться небрежно. Этот вопрос будет рассмотрен в данной главе позже.</p>
     <p>Тем не менее <code>not</code> — полезное средство, и его часто можно с выгодой применять вместо отсечения. Наши два примера можно переписать с <code>not</code>:</p>
     <p><code>любит( мэри, X) :-</code></p>
     <p><code> животное ( X),</code></p>
     <p><code> not змея( X).</code></p>
     <empty-line/>
     <p><code>различны( X, Y) :-</code></p>
     <p><code> not( X = Y).</code></p>
     <p>Это, конечно, выглядит лучше, нежели наши прежние формулировки. Вид предложений стал более естественным, и программу стало легче читать.</p>
     <p>Нашу программу теннисной классификации из предыдущего раздела можно переписать с использованием <code>not</code> так, чтобы ее вид был ближе к исходным определениям наших трех категорий:</p>
     <p><code>класс( X, боец) :-</code></p>
     <p><code> победил( X, _ ),</code></p>
     <p><code> победил( _, X).</code></p>
     <empty-line/>
     <p><code>класс( X, победитель) :-</code></p>
     <p><code> победил( X, _ ),</code></p>
     <p><code> not победил( _, X).</code></p>
     <empty-line/>
     <p><code>класс( X, спортсмен) :-</code></p>
     <p><code> not победил( X, _ ).</code></p>
     <p>В качестве еще одного примера использования <code>not</code> рассмотрим еще раз программу 1 для решения задачи о восьми ферзях из предыдущей главы (рис. 4.7). Мы определили там отношение <code>небьет</code> между некоторым ферзем и остальными ферзями. Это отношение можно определить также и как отрицание отношения "бьет". На рис. 5.3 приводится соответствующим образом измененная программа.</p>
     <empty-line/>
     <p><code>решение( []).</code></p>
     <p><code>решение( [X/Y | Остальные] ) :-</code></p>
     <p><code> решение( Остальные),</code></p>
     <p><code> принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] ),</code></p>
     <p><code> not бьет( X/Y, Остальные).</code></p>
     <empty-line/>
     <p><code>бьет( X/Y, Остальные) :-</code></p>
     <p><code> принадлежит( X1/Y1, Остальные),</code></p>
     <p><code> ( Y1 = Y;</code></p>
     <p><code>   Y1 is Y + X1 - X;</code></p>
     <p><code>   Y1 is Y - X1 + X ).</code></p>
     <p><code> принадлежит( А, [А | L] ).</code></p>
     <empty-line/>
     <p><code>принадлежит( А, [В | L] ) :-</code></p>
     <p><code> принадлежит( А, L).</code></p>
     <empty-line/>
     <p><code>% Шаблон решения</code></p>
     <p><code>шаблон( [1/Y1, 2/Y2, 3/Y3, 4/Y4, 5/Y5, 6/Y6, 7/Y7, 8/Y8]).</code></p>
     <p><strong>Рис. 5.3.</strong>  Еще одна программа для решения задачи о восьми ферзях.</p>
     <empty-line/>
     <subtitle>Упражнения</subtitle>
     <p><strong>5.4.</strong> Даны два списка <code>Кандидаты</code> и <code>Исключенные</code>, напишите последовательность целей (используя <code>принадлежит</code> и <code>not</code>), которая, при помощи перебора, найдет все элементы списка <code>Кандидаты</code>, не входящие в список <code>Исключенные</code>.</p>
     <p><strong>5.5.</strong> Определите отношение, выполняющее вычитание множеств:</p>
     <p><code>разность( Множ1, Множ2, Разность)</code></p>
     <p>где все три множества представлены в виде списков. Например,</p>
     <p><code>разность( [a, b, c, d], [b, d, e, f], [a, c] )</code></p>
     <p>Посмотреть ответ</p>
     <p><strong>5.6.</strong> Определите предикат</p>
     <p><code>унифицируемые( Спис1, Терм, Спис2)</code></p>
     <p>где <code>Спис2</code> — список всех элементов <code>Спис1</code>, которые сопоставимы с <code>Терм</code>'ом, но не конкретизируются таким сопоставлением. Например:</p>
     <p><code>?-  унифицируемые( [X, b, t( Y)], t( a), Спис).</code></p>
     <p><code>Спис = [ X, t( Y)]</code></p>
     <p>Заметьте, что и X и Y должны остаться неконкретизированными, хотя сопоставление с <code>t( a)</code> вызывает их конкретизацию. Указание: используйте <code>not ( Терм1 = Терм2)</code>. Если цель <code>Терм1 = Терм2</code> будет успешна, то <code>not( Терм1 = Tepм2)</code> потерпит неудачу и получившаяся конкретизация будет отменена!</p>
    </section>
    <section>
     <title>
      <p>5.4. Трудности с отсечением и отрицанием</p>
     </title>
     <p>Используя отсечение, мы кое-что выиграли, но не совсем даром. Преимущества и недостатки применения отсечения были показаны на примерах из предыдущих разделов. Давайте подытожим сначала преимущества:</p>
     <p>(1) При помощи отсечения часто можно повысить эффективность программы. Идея состоит в том, чтобы прямо сказать пролог-системе: не пробуй остальные альтернативы, так как они все равно обречены на неудачу.</p>
     <p>(2) Применяя отсечение, можно описать взаимоисключающие правила, поэтому есть возможность запрограммировать утверждение:</p>
     <p> <emphasis>если</emphasis> условие P, <emphasis>то</emphasis> решение Q,</p>
     <p> <emphasis>иначе</emphasis> решение R</p>
     <p>Выразительность языка при этом повышается.</p>
     <p>Ограничения на использование отсечения проистекают из того, что есть опасность потерять такое важное для нас соответствие между декларативным и процедурным смыслами программы. Если в программе нет отсечений, то мы можем менять местами порядок предложений и целей, что повлияет только на ее эффективность, но не на декларативный смысл. Если же отсечения в ней присутствуют, то изменение порядка предложений может повлиять на ее декларативный смысл. Это значит, что программа с измененным порядком, возможно, будет давать результаты, отличные от результатов исходной программы. Вот пример, демонстрирующий этот факт:</p>
     <p><code>p :- а, b.</code></p>
     <p><code>p :- с.</code></p>
     <p>Декларативный смысл программы: p истинно тогда и только тогда, когда истинны одновременно и а, и b или истинно с. Это можно записать в виде такой логической формулы:</p>
     <p> p &lt;===&gt; (а &amp; b) U с</p>
     <p>Можно поменять порядок этих двух предложений, но декларативный смысл останется прежним. Введем теперь отсечение</p>
     <p><code>p :- а, !, b.</code></p>
     <p><code>p :- с.</code></p>
     <p>Декларативный смысл станет теперь таким:</p>
     <p> p &lt;===&gt; (а &amp; b) U ( ~а &amp; с)</p>
     <p>Если предложения поменять местами</p>
     <p><code>p :- с.</code></p>
     <p><code>p :- а, !, b.</code></p>
     <p>декларативный смысл станет таким:</p>
     <p> p &lt;===&gt; с U ( а &amp; b)</p>
     <p>Важным моментом здесь является то, что при использовании отсечения требуется уделять больше внимания процедурным аспектам. К несчастью, эта дополнительная трудность повышает вероятность ошибок программирования.</p>
     <p>В наших примерах из предыдущего раздела мы видели, что удаление отсечений из программы может привести к изменению ее декларативного смысла. Но были также в такие случаи, когда отсечение на него не влияло. Использование отсечений последнего типа требует меньшей осторожности, и поэтому такие отсечения иногда называют "зелеными отсечениями". С точки зрения наглядности программы такие отсечения "невинны" и их использование вполне приемлемо. При чтении программы их можно просто игнорировать.</p>
     <p>Напротив, отсечения, влияющие на декларативный смысл, называются "красными". Красные отсечения — это такие отсечения, которые делают программу трудной для понимания, и их нужно применять с особой осторожностью.</p>
     <p>Отсечение часто используется в комбинации со специальной целью <code>fail</code>. В частности, мы определили отрицание какой-либо цели (<code>not</code>), как ее неуспех. Определенное таким образом отрицание представляет собой просто особый (более ограниченный) вид отсечения. Из соображений ясности программ мы предпочтем пользоваться <code>not</code> вместо комбинации <emphasis>отсечение — неуспех</emphasis> (всюду, где возможно), поскольку отрицание является понятием более высокого уровня, чем <emphasis>отсечение — неуспех</emphasis>.</p>
     <p>Следует заметить, что использование оператора <code>not</code> также может приводить к неприятностям, и его тоже следует применять с осторожностью. Трудность заключается в том, что тот оператор <code>not</code>, который был нами определен, не в точности соответствует отрицанию в математике. Если спросить</p>
     <p><code>?- not человек( мэри).</code></p>
     <p>система, возможно, ответит "да". Не следует понимать этот ответ как "мэри не человек". Что в действительности пролог-система хочет сказать своим "да", так это то, что программе не хватает информации для доказательства утверждения "Мэри — человек". Это происходит потому, что при обработке цели <code>not</code> система не пытается доказать истинность этой цели впрямую. Вместо этого она пытается доказать противоположное утверждение, и если такое противоположное утверждение доказать не удается, система считает, что цель <code>not</code> — успешна. Такое рассуждение основано на так называемом <emphasis>предположении о замкнутости мира</emphasis>. В соответствии с этим постулатом <emphasis>мир замкнут</emphasis> в том смысле, что все в нем существующее либо указано в программе, либо может быть из нее выведено. И наоборот — если что-либо не содержится в программе (или не может быть из нее выведено), то оно не истинно и, следовательно, истинно его отрицание. Это обстоятельство требует особого внимания, поскольку мы обычно не считаем мир замкнутым: если в программе явно не сказано, что</p>
     <p><code>человек( мэри)</code></p>
     <p>то мы этим обычно вовсе не хотим сказать, что Мэри не человек.</p>
     <p>Дальнейшее изучение опасных аспектов использования <code>not</code> проведем на таком примере:</p>
     <p><code>r( а).</code></p>
     <p><code>g( b).</code></p>
     <p><code>p( X) :- not r( X).</code></p>
     <p>Если спросить теперь</p>
     <p><code>?-  g( X), p( X).</code></p>
     <p>система ответит</p>
     <p><code>X = b</code></p>
     <p>Если же задать тот же вопрос, но в такой форме</p>
     <p><code>?- p( X), g( X).</code></p>
     <p>система ответит</p>
     <p><code>nо        </code>(нет)</p>
     <p>Читателю предлагается проследить работу программы по шагам, чтобы понять, почему получились разные ответы. Основная разница между вопросами состоит в том, что переменная X к моменту вычисления <code>p( X)</code> в первом случае была уже конкретизирована, в то время как во втором случае этого еще не произошло.</p>
     <p>Мы детально обсудили аспекты применения отсечения, которое неявно присутствует в <code>not</code>. При этом нами руководило желание предупредить пользователей о соблюдении необходимой осторожности, а вовсе не желание убедить их совсем не пользоваться этим оператором. Отсечение полезно, а часто и необходимо. А что касается трудностей Пролога, порождаемых отсечением, то подобные неудобства часто возникают и при программировании на других языках.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Отсечение подавляет перебор. Его применяют как для повышения эффективности программ, так и для повышения выразительности языка.</p>
     <p>• Эффективность повышается путем прямого указания (при помощи отсечения) пролог — системе не проверять альтернативы, про которые нам заранее известно, что они должны потерпеть неудачу.</p>
     <p>• Отсечение дает возможность сформулировать взаимно исключающие утверждения при помощи правил вида:</p>
     <p> <emphasis>если</emphasis> <strong>Условие</strong> <emphasis>то</emphasis> <strong>Утверждение1</strong> <emphasis>иначе</emphasis> <strong>Утверждение2</strong></p>
     <p>• Отсечение дает возможность ввести <emphasis>отрицание как неуспех</emphasis>: <code>not( Цель)</code> определяется через неуспех цели <code>Цель</code>.</p>
     <p>• Иногда бывают полезными две особые цели <code>true</code> и <code>fail</code>. <code>true</code> — всегда успешна и <code>fail</code> — всегда терпит неудачу.</p>
     <p>• Существуют ограничения в применении отсечения: его появление может нарушить, соответствие между декларативным и процедурным смыслами программы. Поэтому хороший стиль программирования предполагает осторожное применение отсечений и отказ от их применения без достаточных оснований.</p>
     <p>• Оператор <code>not</code>, определенный через неуспех, не полностью соответствует отрицанию в математической логике. Поэтому <code>not</code> тоже нужно применять с осторожностью.</p>
     <subtitle>Литература</subtitle>
     <p>Различать "зеленые и "красные" отсечения предложил ван Эмден (1982).</p>
     <p>van Emden M. (1982). Red and green cuts. <emphasis>Logic Programming Newsletter:  2</emphasis>.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 6</p>
     <p>Ввод и вывод</p>
    </title>
    <section>
     <p>В этой главе мы рассмотрим некоторые встроенные средства для записи данных в файл и считывания их из файла. Такие средства можно также применять и для форматирования объектов данных программы, чтобы получить желаемую форму их внешнего представления. Одновременно мы рассмотрим и средства синтеза и декомпозиции атомов.</p>
    </section>
    <section>
     <title>
      <p>6.1. Связь с файлами</p>
     </title>
     <p>До сих пор мы применяли только один метод связи пользователя с программой — пользователь задает программе вопросы, а программа ему отвечает, конкретизируя переменные. Такой механизм связи прост и практичен и, несмотря на свою простоту, обеспечивает ввод и вывод информации. Однако он обладает слишком малой гибкостью и поэтому часто не совсем удобен. В следующих случаях требуется расширение этого основного механизма связи:</p>
     <p>• ввод данных в форме, отличной от вопроса - например, в виде предложений, написанных на английском языке</p>
     <p>• вывод информации в произвольном формате</p>
     <p>• обмен информацией с произвольным файлом, а не только с пользовательским терминалом</p>
     <p>Встроенные предикаты, предназначенные для этого расширения, отличаются в разных реализациях Пролога. Мы изучим здесь простой и удобный набор таких предикатов, применяемый во многих реализациях. Однако за деталями и специфическими особенностями следует, конечно, обращаться к руководствам по конкретным пролог-системам.</p>
     <image l:href="#_46.png"/>
     <p><strong>Рис. 6. 1.</strong>  Связь между пролог-программой и различными файлами.</p>
     <p>Рассмотрим вначале вопрос о том, как обмениваться информацией с файлами, а затем — как можно вводить и выводить данные в разных форматах.</p>
     <p>На рис. 6.1 показана общая ситуация, в которой пролог-программа взаимодействует с несколькими файлами. Она может, в принципе, считывать данные из нескольких входных файлов, называемых также <emphasis>входными потоками</emphasis>, и выводить данные в несколько выходных файлов, называемых <emphasis>выходными потоками</emphasis>. Информация, поступающая с пользовательского терминала, рассматривается просто как еще один входной поток. Аналогично информация, выводимая на этот терминал, рассматривается как один из выходных потоков. На оба этих "псевдофайла" ссылаются с помощью имени <code>user</code> (пользователь). Имена остальных файлов программист должен выбирать в соответствии с правилами именования файлов, принятыми в используемой компьютерной системе.</p>
     <p>В каждый момент выполнения пролог-программы лишь два файла являются "активными": один для ввода, другой — для вывода. Эти два файла называются <emphasis>текущим входным потоком</emphasis> и <emphasis>текущим выходным потоком</emphasis> соответственно. В начальный момент эти два потока соответствуют терминалу. Текущий входной поток может быть заменен на другой файл <code>ИмяФайла</code> посредством цели</p>
     <p><code>see( ИмяФайла)              </code>( Смотри(ИмяФайла) )</p>
     <p>Такая цель всегда успешна (если только с файлом <code>ИмяФайла</code> все в порядке), а в качестве побочного эффекта происходит переключение ввода с предыдущего входного потока на файл <code>ИмяФайла</code>. Поэтому типичным примером использования предиката <code>see</code> является следующая последовательность целей, которая считывает информацию из файла <code>файл1</code>, а затем переключается обратно на терминал:</p>
     <p><code>...</code></p>
     <p><code>see( файл1),</code></p>
     <p><code>читать_из_файла( Информация),</code></p>
     <p><code>see( user),                  </code>( user — пользователь)</p>
     <p><code>...</code></p>
     <p>Текущий выходной поток может быть изменен при помощи цели вида</p>
     <p><code>tell( ИмяФайла)              </code>( сообщить( ИмяФайла) )</p>
     <p>Следующая последовательность целей выводит некоторую информацию в <code>файл3</code>, а после этого перенаправляет последующий вывод обратно на терминал:</p>
     <p><code>...</code></p>
     <p><code>tell( файл3),</code></p>
     <p><code>записать_в_файл( Информация),</code></p>
     <p><code>tell( user),</code></p>
     <p><code>...</code></p>
     <p>Цель</p>
     <p><code>seen                          </code>( конец чтения)</p>
     <p>закрывает текущий входной файл. Цель</p>
     <p><code>told                          </code>( конец записи)</p>
     <p>закрывает текущий выходной файл.</p>
     <p>Файлы могут обрабатываться только последовательно. В этом смысле все файлы ведут себя так же, как терминал. Каждый запрос на чтение из входного файла приводит к чтению в текущей позиции текущего входного потока. После этого чтения текущая позиция, естественно, будет перемещена на следующий, еще не прочитанный элемент данных. Следующий запрос на чтение приведет к считыванию, начиная с этой новой текущей позиции. Если запрос на чтение делается в конце файла, то в качестве ответа на такой запрос выдается атом <code>end_of_file</code> (конец файла). Считанную один раз информацию считать вторично невозможно.</p>
     <p>Запись производится точно так же, каждый запрос на вывод информации приведет к тому, что она будет присоединена в концу текущего выходного потока. Невозможно сдвинуться назад и переписать часть файла.</p>
     <p>Все файлы являются "текстовыми", т.е. файлами, состоящими из символов. Символы — это буквы, цифры и специальные знаки. О некоторых из них говорят, что они непечатаемые, поскольку, будучи выведенными на терминал, они не появляются на экране. Однако их присутствие может сказаться каким-либо другим образом, например появятся пробелы или пустые строки.</p>
     <p>Существуют два основных способа, с помощью которых файлы рассматриваются в Прологе в зависимости от формы записанной в них информации. Один способ - рассматривать символ как основной элемент файла. Соответственно один запрос на ввод или вывод приведет к чтению или записи одного символа. Для этой цели предназначены встроенные предикаты <code>get</code>, <code>get0</code> и <code>put</code> (получить, получить0 и выдать).</p>
     <p>Другой способ рассматривать файл — считать, что в качестве основных элементов построения файла используются более крупные единицы текста. Такой естественной более крупной единицей является прологовский терм. Поэтому каждый запрос на ввод/вывод такого типа приведет к переносу целого терма из текущего входного потока или в текущий выходной поток соответственно. Предикатами для переноса термов являются предикаты <code>read</code> и <code>write</code> (читать и писать). В этом случае информация в файле должна, конечно, по форме соответствовать синтаксису термов.</p>
     <p>Очевидно, что выбор формы организации файла зависит от задачи. Всякий раз, когда особенности задачи допускают естественное представление информации в соответствии с синтаксисом термов, следует предпочесть файлы, состоящие из термов. Тогда появится возможность за одно обращение и вводу или выводу пересылать целые осмысленные фрагменты информации. С другой стороны, существуют задачи, природа которых диктует иную организацию файлов. Примером такого рода задачи является обработка предложений естественного языка, скажем, для организации диалога между системой и пользователем на английском языке. В таких случаях файлы следует рассматривать как последовательности символов, которые не укладываются в синтаксис термов.</p>
    </section>
    <section>
     <title>
      <p>6.2. Обработка файлов термов </p>
     </title>
     <section>
      <title>
       <p>6.2.1. <emphasis>reаd</emphasis> и <emphasis>write</emphasis></p>
      </title>
      <p>Встроенный предикат <code>read</code> используется для чтения термов из текущего входного потока. Цель</p>
      <p><code>read( X)</code></p>
      <p>вызывает чтение следующего терма T и сопоставление его с X. Если X — переменная, то в результате X конкретизируется и становится равным T. Если сопоставление терпит неудачу, цель <code>read( X)</code> тоже терпит неудачу. Предикат <code>read</code> — детерминированный в том смысле, что в случае неуспеха не происходит возврата для ввода следующего терма. После каждого терма во входном файле должна стоять точка или пробел, или символ возврата каретки.</p>
      <p>Если <code>read( X)</code> вычисляется в тот момент, когда достигнут конец текущего входного файла, тогда X конкретизируется атомом <code>end_of_file</code> (конец файла).</p>
      <p>Встроенный предикат <code>write</code> выводит терм. Поэтому цель</p>
      <p><code>write( X)</code></p>
      <p>выведет терм X в текущий выходной файл. X будет выведен в той же стандартной форме, в какой обычно пролог-система изображает на экране или распечатке значения переменных. Полезной особенностью Пролога является то, что процедура <code>write</code> "знает", как изображать любой терм, как бы сложен он не был.</p>
      <p>Существуют дополнительные встроенные предикаты для форматирования вывода. Они вставляют пробелы в дополнительные строки в выходной поток. Цель</p>
      <p><code>tab( N)</code></p>
      <p>выводит <code>N</code> пробелов. Предикат <code>nl</code> (без аргументов) приводит к переходу на новую строку.</p>
      <p>Следующие примеры иллюстрируют использование этих процедур.</p>
      <p>Предположим, у нас есть процедура для вычисления кубов чисел:</p>
      <p><code>куб( N, С) :-</code></p>
      <p><code> С is N * N * N.</code></p>
      <p>Предположим далее, что мы хотим применить ее для вычисления кубов элементов некоторой последовательности чисел. Это можно сделать с помощью последовательности вопросов:</p>
      <p><code>?- куб( 2, X).</code></p>
      <p><code>X = 8</code></p>
      <empty-line/>
      <p><code>?- ку6( 5, Y).</code></p>
      <p><code>Y = 125</code></p>
      <empty-line/>
      <p><code>?-  куб( 12, Z).</code></p>
      <p><code>Z = 1728</code></p>
      <p>Для получения каждого результата нам придется набирать соответствующую цель. Давайте теперь изменим эту программу так, чтобы процедура <code>куб</code> сама читала соответствующие данные. Теперь программа будет сама читать данные и выводить их кубы до тех пор, пока не будет прочитан атом <code>стоп</code>:</p>
      <p><code>куб :-</code></p>
      <p><code> read( X),</code></p>
      <p><code> обработать( X).</code></p>
      <empty-line/>
      <p><code>обработать( стоп) :- !.</code></p>
      <p><code>обработать( N) :-</code></p>
      <p><code> С is N * N * N,</code></p>
      <p><code> write( С),</code></p>
      <p><code> куб.</code></p>
      <p>Это был пример программы, декларативный смысл которой трудно сформулировать. В то же время ее процедурный смысл совершенно ясен: чтобы вычислить <code>куб</code>, сначала нужно считать X, а затем его обработать; если <code>X = стоп</code>, то все сделано, иначе вывести X&#179; и рекурсивно запустить процедуру <code>куб</code> для обработки остальных чисел.</p>
      <p>С помощью этой новой процедуры таблица кубов чисел может быть получена таким образом:</p>
      <p><code>?- куб.</code></p>
      <empty-line/>
      <p><code>2.</code></p>
      <p><code>8</code></p>
      <p><code>5.</code></p>
      <p><code>125</code></p>
      <p><code>12.</code></p>
      <p><code>1728</code></p>
      <p><code>стоп.</code></p>
      <p><code>yes</code></p>
      <p>Числа 2, 5 и 12 были введены пользователем с терминала, остальные числа были выведены программой. Заметьте, что после каждого числа, введенного пользователем, должна стоять точка, которая сигнализирует о конце терма.</p>
      <p>Может показаться, что приведённую процедуру <code>куб</code> можно упростить. Однако следующая попытка такого упрощения является ошибочной:</p>
      <p><code>куб :-</code></p>
      <p><code> read( стоп), !.</code></p>
      <p><code>куб :-</code></p>
      <p><code> read( N),</code></p>
      <p><code> С is N * N * N,</code></p>
      <p><code> write( С),</code></p>
      <p><code> куб.</code></p>
      <p>Причина, по которой эта процедура работает неправильно, станет очевидной, если проследить, какие действия она выполняет с входным аргументом, скажем с числом 5. Цель <code>read( стоп)</code> потерпит неудачу при чтении этого числа, и оно будет потеряно навсегда. Следующая цель <code>read</code> введет следующий терм. С другой стороны может случиться, что сигнал <code>стоп</code> будет считан целью <code>read( N)</code>, что приведет к попытке перемножить нечисловую информацию.</p>
      <p>Процедура <code>куб</code> ведет диалог между пользователем и программой. В таких случаях обычно желательно, чтобы программа перед тем, как читать с терминала новые данные, дала сигнал пользователю о том, что она готова к приему информации, а также, возможно, и о том, какого вида информация ожидается. Это делается обычно путем выдачи "приглашения" перед чтением. Нашу процедуру <code>куб</code> можно для этого изменить, например, так:</p>
      <p><code>куб :-</code></p>
      <p><code> write( 'Следующее число, пожалуйста:'),</code></p>
      <p><code> read( X),</code></p>
      <p><code> обработать( X).</code></p>
      <empty-line/>
      <p><code>обработать( стоп) :- !.</code></p>
      <p><code>обработать( N) :-</code></p>
      <p><code> С is N * N * N,</code></p>
      <p><code> write( 'Куб'), write( N), write( 'равен'),</code></p>
      <p><code> write( С), nl,</code></p>
      <p><code> куб.</code></p>
      <p>Разговор с новой версией мог бы быть, например, таким:</p>
      <p><code>?- куб.</code></p>
      <empty-line/>
      <p><code>Следующее число, пожалуйста: 5.</code></p>
      <p><code>Куб 5 равен 125</code></p>
      <empty-line/>
      <p><code>Следующее число, пожалуйста: 12.</code></p>
      <p><code>Куб 12 равен 1728</code></p>
      <empty-line/>
      <p><code>Следующее число, пожалуйста: стоп.</code></p>
      <p><code>yes</code></p>
      <p>В некоторых реализациях для того, чтобы приглашение появилось на экране перед чтением, необходимо выдать дополнительный запрос (такой, скажем, как <code>ttyflush</code>) после записи.</p>
      <p>В последующих разделах мы увидим некоторые типичные примеры операций, в которых участвуют чтение и запись.</p>
     </section>
     <section>
      <title>
       <p>6.2.2. Вывод списков </p>
      </title>
      <p>Кроме стандартного прологовского формата для списков существуют несколько других естественных форм их внешнего представления, которые в некоторых ситуациях являются более предпочтительными. Следующая процедура</p>
      <p><code>вывспис( L)</code></p>
      <p>выводит список L так, что каждый его элемент занимает отдельную строку:</p>
      <p><code>вывспис( []).</code></p>
      <p><code>вывспис( [X | L) :-</code></p>
      <p><code> write( X), nl,</code></p>
      <p><code> вывспис( L).</code></p>
      <p>Если у нас есть список списков, то одной из естественных форм его выводе является такая, при которой все элементы каждого списка записываются на отдельной строке. Для этого мы определим процедуру <code>вывспис2</code>. Вот пример ее использования:</p>
      <p><code>?- вывспис2( [ [а, b, с], [d, e, f], [g, h, i] ] ).</code></p>
      <empty-line/>
      <p><code>а b с</code></p>
      <p><code>d e f</code></p>
      <p><code>g h i</code></p>
      <p>Процедура, выполняющая эту работу, такова:</p>
      <p><code>вывспис2( []).</code></p>
      <p><code>вывспис2( [L | LL] ) :-</code></p>
      <p><code> строка( L), nl,</code></p>
      <p><code> вывспис1( LL).</code></p>
      <empty-line/>
      <p><code>строка( []).</code></p>
      <p><code>строка( [X | L] ) :-</code></p>
      <p><code> write( X), tab( 1),</code></p>
      <p><code> строка( L).</code></p>
      <p>Список целых чисел иногда удобно представить в виде диаграммы. Следующая процедура <code>диагр</code> выводит список в такой форме (предполагается, что числа списка заключены между 0 и 80). Пример ее использования:</p>
      <p><code>?- диагр( [3, 4, 6, 5] ).</code></p>
      <empty-line/>
      <p><code>***</code></p>
      <p><code>****</code></p>
      <p><code>******</code></p>
      <p><code>*****</code></p>
      <p>Процедуру <code>диагр</code> можно определить так:</p>
      <p><code>диагр( [N | L]) :-</code></p>
      <p><code> звездочки( N), nl,</code></p>
      <p><code> диагр( L).</code></p>
      <empty-line/>
      <p><code>звеэдочки( N) :-</code></p>
      <p><code> N &gt; 0,</code></p>
      <p><code> write( *),</code></p>
      <p><code> N1 is N - 1,</code></p>
      <p><code> звездочки( N1).</code></p>
      <p><code>звездочки( N) :-</code></p>
      <p><code> N =&lt; 80.</code></p>
     </section>
     <section>
      <title>
       <p>6.2.3. Формирование термов</p>
      </title>
      <p>Предположим, наша программа имеет дело с семьями, которые представлены в виде термов так, как это сделано в гл. 4 (рис. 4.1). Тогда, если, переменная F конкретизирована термом, изображенный на рис. 4.1, то цель</p>
      <p><code>write( F)</code></p>
      <p>вызовет вывод этого терма в стандартной форме примерно так:</p>
      <p><code>семья( членсемьи( том, фокс, дата( 7, май, 1950),</code></p>
      <p><code> работает( bbс, 15200)),</code></p>
      <p><code> членсемьи( энн, фокс, дата( 9, май, 1951),</code></p>
      <p><code>  неработает),</code></p>
      <p><code> [членсемьи( пат, фокс, дата( 5, май, 1973),</code></p>
      <p><code>   неработает),</code></p>
      <p><code>  членсемьи( джим, фокс, дата( 5, май, 1973),</code></p>
      <p><code>   неработает)])</code></p>
      <empty-line/>
      <p><code>родители</code></p>
      <p><code> том фокс, датарожд 7 май 1950, работает bbс,</code></p>
      <p><code>  оклад 15200</code></p>
      <p><code> энн фокс, датарожд 9 май 1951, неработает</code></p>
      <p><code>дети</code></p>
      <p><code> пат фокс, датарожд 5 май 1973, неработает</code></p>
      <p><code> джим фокс, датарожд 5 май 1973, неработает</code></p>
      <p><strong>Рис. 6.2.</strong> Улучшенный формат вывода термов, представляющих семью.</p>
      <empty-line/>
      <p>Здесь содержится полная информация, однако форма представления легко может запутать, поскольку трудно проследить, какие ее части образуют самостоятельные семантические единицы. Поэтому обычно предпочитают выводить такую информацию в каком-либо формате, например так, как показано на рис. 6.2. Процедура</p>
      <p><code>вывсемью( F)</code></p>
      <p>с помощью которой это достигается, приведена на рис. 6.3.</p>
      <empty-line/>
      <p><code>вывсемью( семья ( Муж, Жена, Дети) :-</code></p>
      <p><code> nl, write( родители), nl, nl,</code></p>
      <p><code> вывчленсемьи( Муж), nl,</code></p>
      <p><code> вывчленсемьи( Жена), nl, nl,</code></p>
      <p><code> write( дети), nl, nl,</code></p>
      <p><code> вывчленсемьи( Дети).</code></p>
      <empty-line/>
      <p><code>вывчленсемьи( членсемьи( Имя, Фамилия, дата( Д, М, Г), Работа) ) :-</code></p>
      <p><code> tab(4), write( Имя),</code></p>
      <p><code> tab(1), write( Фамилия),</code></p>
      <p><code> write( ', дата рождения'),</code></p>
      <p><code> write( Д), tab( 1),</code></p>
      <p><code> write( M), tab( 1),</code></p>
      <p><code> write( Г), write( ','),</code></p>
      <p><code> вывработу( Работа).</code></p>
      <empty-line/>
      <p><code>вывсписчлсемьи( []).</code></p>
      <p><code>вывсписчлсемьи( [P | L]) :-</code></p>
      <p><code> вывчленсемьи( P), nl,</code></p>
      <p><code> вывсписчлсемьи( L).</code></p>
      <empty-line/>
      <p><code>вывработу( неработает) :-</code></p>
      <p><code> write( неработает).</code></p>
      <p><code>вывработу( работает Место, Оклад) ) :-</code></p>
      <p><code> write(' работает '), write( Место),</code></p>
      <p><code> write( ', оклад '), write( Оклад).</code></p>
      <p><strong>Рис. 6.3.</strong>  Программа, обеспечивающая вывод в формате, представленном на рис. 6.2.</p>
     </section>
     <section>
      <title>
       <p>6.2.4. Обработка произвольного файла термов</p>
      </title>
      <p>Типичная последовательность целей для обработки файла F от начала до конца будет выглядеть примерно так:</p>
      <p><code>... , see( F), обработкафайла, sеe( user), ...</code></p>
      <p>Здесь <code>обработкафайла</code> — процедура, которая читает и обрабатывает последовательно каждый терм файла F один за другим до тех пор, пока не встретится конец файла. Приведем типичную схему для процедуры <code>обработкафайла</code>:</p>
      <p><code>обработкафайла :-</code></p>
      <p><code> read( Терм),</code></p>
      <p><code> обработка( Терм).</code></p>
      <empty-line/>
      <p><code>обработка( end_of_file) :- !.</code></p>
      <p><code> % Все сделано</code></p>
      <p><code>обработка( Терм) :-</code></p>
      <p><code> обраб( Терм),</code></p>
      <p><code>  % Обработать текущий элемент</code></p>
      <p><code> обработкафайла.</code></p>
      <p><code>  % Обработать оставшуюся часть файла</code></p>
      <p>Здесь <code>обраб( Терм)</code> представляет процедуру обработки отдельного терма. В качестве примера такой обработки рассмотрим процедуру, которая выдает на терминал каждый терм вместе с его порядковым номером. Назовем эту процедуру <code>показфайла</code>. У нее должен быть дополнительный аргумент для подсчета прочитанных термов:</p>
      <p><code>показфайла( N) :-</code></p>
      <p><code> read( Терм),</code></p>
      <p><code> показ( Терм, N).</code></p>
      <empty-line/>
      <p><code>показ( Терм, N) :- !</code></p>
      <p><code> write( N), tab( 2), write( Терм),</code></p>
      <p><code> N1 is N + 1,</code></p>
      <p><code> показфайла( N1).</code></p>
      <p>Вот другой пример программы обработки файлов, построенной по подобной схеме. Пусть есть файл с именем <code>файл1</code>, термы которого имеют форму</p>
      <p><code>изделие( НомерИзд, Описание, Цена, ИмяПоставщика)</code></p>
      <p>Каждый терм описывает одну строку каталога изделий. Нужно построить новый файл. содержащий только те изделия, которые выпускаются каким-то конкретным поставщиком. Поскольку поставщик в этом новом файле у всех изделий будет одинаков, его имя нужно записать только один раз в самом начале и убрать из всех остальных термов. Процедура будет называться</p>
      <p><code>создатьфайл( Поставщик)</code></p>
      <p>Например, если исходный каталог хранится в файле <code>файл1</code>, а мы хотим создать специальный каталог в файле <code>файл2</code>, содержащий всю информацию о том, что поставляет Гаррисон, тогда мы применим процедуру <code>создатьфайл</code> следующим образом:</p>
      <p><code>?- seе( файл1), tеll( файл2), создатьфайл( гаррисон),</code></p>
      <p><code> see( user), tell( user).</code></p>
      <p>Процедуру <code>создатьфайл</code> можно определить так:</p>
      <p><code>создатьфайл( Поставщик) :-</code></p>
      <p><code> write( Поставщик), write( '.'), nl,</code></p>
      <p><code> создатьостальное( Поставщик).</code></p>
      <empty-line/>
      <p><code>создатьостальное( Поставщик) :-</code></p>
      <p><code> read( Изделие),</code></p>
      <p><code> обработать( Изделие, Поставщик).</code></p>
      <empty-line/>
      <p><code>обработать( end_ot_file) :- !.</code></p>
      <p><code>обработать( Изделие( Ном, Опис, Цена, Поставщик),</code></p>
      <p><code> Поставщик) :- !,</code></p>
      <p><code> write( Изделие( Ном, Опис, Цена) ),</code></p>
      <p><code> write( '.'), nl,</code></p>
      <p><code> создатьостальное( Поставщик).</code></p>
      <empty-line/>
      <p><code>обработать ( _, Поставщик) :-</code></p>
      <p><code> создатьостальное( Поставщик).</code></p>
      <p>Обратите внимание на то, что <code>обработать</code> вписывает точки между термами, чтобы впоследствии файл мог быть прочитан процедурой <code>read</code>.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>6.1.</strong> Пусть <code>f</code> — файл термов. Определите процедуру</p>
      <p><code>найтитерм( Терм)</code></p>
      <p>которая выводит на терминал новый терм из <code>f</code>, сопоставимый с <code>Терм</code>'ом.</p>
      <p><strong>6.2.</strong> Пусть <code>f</code> — файл термов. Напишите процедуру</p>
      <p><code>найтивсетермы( Терм)</code></p>
      <p>которая выводит на экран все термы из <code>f</code>, сопоставимые с <code>Tepм</code>'ом. Обеспечьте при этом, чтобы во время поиска <code>Терм</code> не конкретизировался (это могло бы помешать ему сопоставиться с другими термами дальше по файлу).</p>
     </section>
    </section>
    <section>
     <title>
      <p>6.3. Обработка символов</p>
     </title>
     <p>Символ записывается в текущий выходной поток при помощи цели</p>
     <p><code>put( С)</code></p>
     <p>где С — символ, который нужно вывести, в кодировке ASCII (число от 0 до 127), например, вопрос</p>
     <p><code>?- put( 65), put( 66), put( 67).</code></p>
     <p>породит следующий вывод:</p>
     <p><code>АВС</code></p>
     <p>65 — ASCII-код 'А', 66 — 'В', 67 — 'С'.</p>
     <p>Одиночный символ можно считать из текущего входного потока при помощи цели</p>
     <p><code>get0( С)</code></p>
     <p>Она вызывает чтение символа из входного потока, и переменная С конкретизируется ASCII-кодом этого символа. Вариантом предиката <code>get0</code> является <code>get</code>, который используется для чтения символов, отличных от пробела. Поэтому цель</p>
     <p><code>get( С)</code></p>
     <p>вызовет пропуск всех непечатаемых символов (в частности пробелов) от текущей позиции во входном потоке до первого печатаемого символа. Этот символ затем тоже считывается и С конкретизируется его ASCII-кодом.</p>
     <p>В качестве примера использования предикатов, переносящих одиночные символы, давайте рассмотрим процедуру <code>сжатие</code>, выполняющую следующую работу: считывание из входного потока произвольного предложения и вывод его же, но в форматированном виде — все группы идущих подряд пробелов заменены на одиночные пробелы. Для простоты будем считать, что все предложения входного потока, обрабатываемые процедурой <code>сжатие</code>, оканчиваются точками, а слова в них отделены одно от другого одним или несколькими пробелами, и только ими. Тогда следующее предложение будет допустимым:</p>
     <p>Робот    пытался     налить    вина    из     бутылки.</p>
     <p>Цель <code>сжатие</code> выведет его в таком виде:</p>
     <p>Робот пытался налить вина из бутылки.</p>
     <p>Процедура <code>сжатие</code> будет иметь такую же структуру, как и процедуры обработки файлов из предыдущего раздела. Сначала она прочтет первый символ, выведет его, а затем завершит обработку, в зависимости от того, каким был этот символ. Есть три альтернативы, которые соответствуют следующим случаям: символ является точкой, пробелом или буквой. Взаимное исключение этих трех альтернатив обеспечивается в программе отсечениями:</p>
     <p><code>сжатие :-</code></p>
     <p><code> get0( С),</code></p>
     <p><code> put( С).</code></p>
     <empty-line/>
     <p><code>сделатьостальное( С).</code></p>
     <p><code> сделатьостальное( 46) :- !.</code></p>
     <p><code>  % 46 -АSСII-код точки, Все сделано</code></p>
     <empty-line/>
     <p><code>сделатьостальное( 32) :- !,</code></p>
     <p><code>  % 32 - ASCII-код пробела</code></p>
     <p><code> get( С),</code></p>
     <p><code> put( С),</code></p>
     <p><code> сделатьостальное( С).</code></p>
     <empty-line/>
     <p><code>сделатьостальное( Буква) :-</code></p>
     <p><code> сжатие.</code></p>
     <subtitle>Упражнение</subtitle>
     <p><strong>6.3.</strong> Обобщите процедуру сжатие на случай запятых. Все пробелы, стоящие непосредственно перед запятой, нужно убрать, а после каждой запятой нужно поместить единственный пробел.</p>
    </section>
    <section>
     <title>
      <p>6.4. Создание и декомпозиция атомов</p>
     </title>
     <p>Часто желательно информацию, считанную как последовательность символов, иметь в программе в виде атома. Для этой цели существует встроенный предикат <code>name</code>. Он устанавливает взаимосвязь между атомами и их кодировкой в ASCII. Таким образом,</p>
     <p><code>name( A, L)</code></p>
     <p>истинно, если L — список кодов ASCII, кодирующих атом. Например,</p>
     <p><code>name( zx232, [122, 120, 50, 51, 50] )</code></p>
     <p>истинно. Существуют два типичных способа использования <code>name</code>:</p>
     <p>(1) дан атом, разбить его на отдельные символы;</p>
     <p>(2) дан список символов, объединить их в один атом.</p>
     <p>Примером первого случая применения предиката является программа, которая имеет дело с заказами такси и водителями. Все это представлено в программе атомами</p>
     <p><code>заказ1, заказ2, водитель1, водитель2, такси1, таксилюкс</code></p>
     <p>Предикат</p>
     <p><code>такси( X)</code></p>
     <p>проверяет, относится ли атом X к тем атомам, которые представляют такси:</p>
     <p><code>такси( X) :-</code></p>
     <p><code> name( X, Хспис),</code></p>
     <p><code> nаmе( такси, Тспис),</code></p>
     <p><code> конк( Тспис, _, Хспис).</code></p>
     <empty-line/>
     <p><code>конк( [], L, L).</code></p>
     <p><code>конк( [А | L1], L2, [А | L3] ) :-</code></p>
     <p><code> конк( L1, L2, L3).</code></p>
     <p>Предикаты <code>заказ</code> и <code>водитель</code> можно определить аналогично.</p>
     <p>Наш следующий пример иллюстрирует применение объединения отдельных символов в один атом. Мы определим предикат</p>
     <p><code>читпредложение( Списслов)</code></p>
     <p>который считает предложение с произвольной формой на естественном языке и конкретизирует <code>Списслов</code> некоторым внутренним представлением этого предложения. В качестве внутреннего представления, обеспечивающего возможность дальнейшей обработки предложения, естественно избрать следующее: каждое слово входного предложения представляется прологовским атомом, а все предложение представляется списком этих атомов. Например, если входной поток таков:</p>
     <p><code>Мэри было приятно видеть неудачу робота.</code></p>
     <p>то цель <code>читпредложение( Предложение)</code> вызовет конкретизацию</p>
     <p><code>Предложение=['Мэри', было, приятно, видеть, неудачу, робота]</code></p>
     <p>Для простоты будем считать, что каждое предложение оканчивается точкой и внутри него не используются никакие знаки препинания.</p>
     <p>Программа для <code>читпредложение</code> показана на рис. 6.4. Вначале процедура читает текущий входной символ <code>Симв</code>, а затем передает его процедуре <code>читостальное</code> для завершения работы. Процедура <code>читостальное</code> должна правильно обработать следующие три случая:</p>
     <p>(1) <code>Симв</code> — точка, тогда все сделано.</p>
     <p>(2) <code>Симв</code> — пробел, — игнорировать его и <code>читпредложение</code> от остального ввода.</p>
     <p>(3) <code>Симв</code> — буква, — сначала считать слово <code>Слово</code>, которое начинается с <code>Симв</code>, а затем запустить <code>читпредложение</code>, чтобы считать оставшуюся часть предложения, породив при этом <code>Списслов</code>. Общим результатом этого будет список <code>[Слово | Списслов]</code>.</p>
     <p>Процедура, считывающая символы одного слова, такова:</p>
     <p><code>читбуквы( Буква, Буквы, Сделсимв)</code></p>
     <p>Ее три аргумента:</p>
     <p>(1) <code>Буква</code> — текущая буква (уже считанная) читаемого слова.</p>
     <p>(2) <code>Буквы</code> — список букв (начинающийся с буквы <code>Буква</code>), оставшихся до конца слова.</p>
     <p>(3) <code>Следсимв</code> — входной символ, непосредственно следующий за читаемым словом. <code>Следсимв</code> не должен быть буквой.</p>
     <p>Мы завершим данный пример замечанием о возможном применения процедуры <code>читпредложение</code>. Ее можно использовать в программе обработки текста на естественном языке. Предложения, представленные в виде списков слов, имеют удобную форму для дальнейшей обработки при помощи Пролога. В простейшем случае такой обработкой мог бы быть поиск во входном предложении определенных ключевых слов. Значительно более сложной задачей является понимание предложения, т.е. извлечение из него смысла, представленного в некотором избранном формализме. Это важная область исследований в искусственном интеллекте.</p>
     <empty-line/>
     <p><code>/*</code></p>
     <p><code>Процедура читпредложение считывает предложение</code></p>
     <p><code>и из его слов создает список атомов. Например,</code></p>
     <p><code> читпредложение( Списслов)</code></p>
     <p><code>порождает</code></p>
     <p><code> Списслов=['Мэри', было, приятно, видеть, неудачу, робота]</code></p>
     <p><code>если входным было предложение</code></p>
     <p><code> Мэри было приятно видеть неудачу робота.</code></p>
     <p><code>*/</code></p>
     <p><code>читпредложение( Списслов) :-</code></p>
     <p><code> gеt0( Симв),</code></p>
     <p><code> читостальное( Симв, Списслов).</code></p>
     <empty-line/>
     <p><code>читостальное( 46, []) :- !.</code></p>
     <p><code>  % Конец предложения: 46 = ASCII-код для '.'</code></p>
     <p><code> читостальное( 32, Списслов) :- !,</code></p>
     <p><code>  % 32 = ASCII-код для пробела</code></p>
     <p><code> читпредложение( Списслов).</code></p>
     <p><code>  % Пропустить пробел</code></p>
     <empty-line/>
     <p><code>читостальное( Буква, [Слово | Списслов]) :-</code></p>
     <p><code> читбуквы( Буква, Буквы, Следсимв),</code></p>
     <p><code>  % Считать буквы текущего слова</code></p>
     <p><code> nаmе( Слово, Буквы),</code></p>
     <p><code>  читостальное( Следсимв, Списслов).</code></p>
     <empty-line/>
     <p><code>читбуквы( 46, [], 46) :- !.</code></p>
     <p><code> % Конец слова: 46 = точка</code></p>
     <p><code>читбуквы( 32, [], 32) :- !.</code></p>
     <p><code> % Конец слова: 32 = пробел</code></p>
     <p><code>читбуквы( Бкв, [Бкв | Буквы], Следсимв) :-</code></p>
     <p><code> get0( Симв),</code></p>
     <p><code> читбуквы( Симв, Буквы, Следсимв).</code></p>
     <p><strong>Рис. 6.4.</strong> Процедура для преобразования предложения в список атомов.</p>
     <empty-line/>
     <subtitle>Упражнения</subtitle>
     <p><strong>6.4.</strong> Определите отношение</p>
     <p><code>начинается( Атом, Символ)</code></p>
     <p>для проверки, начинается ли <code>Атом</code> с символа <code>Символ</code>.</p>
     <p><strong>6.5.</strong> Определите процедуру <code>plural</code>, которая преобразует английские существительные из единственного числа во множественное, добавляя к слову окончание s. Например:</p>
     <p><code>?- plural( table, X).</code></p>
     <p><code>X  =  tables</code></p>
     <p><strong>6.6.</strong> Напишите процедуру</p>
     <p><code>поиск( Ключслово, Предложение)</code></p>
     <p>которая при каждом вызове находит в текущем входном файле предложение, содержащее заданное ключевое слово <code>Ключслово</code>. <code>Предложение</code> в своей исходной форме должно быть представлено в виде последовательности символов или в виде атома (процедуру <code>читпредложение</code> из данного раздела можно соответственно модифицировать).</p>
    </section>
    <section>
     <title>
      <p>6.5. Ввод программ: <emphasis>consult, reconsult</emphasis></p>
     </title>
     <p>Передавать программы пролог-системе можно при помощи двух встроенных предикатов: <code>consult </code>и <code>reconsult</code>. Чтобы система считала программу из файла F, нужно поставить цель</p>
     <p><code>?- consult( F).</code></p>
     <p>В результате все предложения программы, содержащейся в F, будут использованы пролог-системой при ответе на дальнейшие вопросы пользователя. Если позже в том же сеансе произойдет "консультация" с другим файлом, предложения этого нового файла будут просто добавлены в конец текущего множества предложений.</p>
     <p>Для того, чтобы запустить программу, не обязательно записывать ее в файл, а затем "консультироваться" с ним. Вместо чтения файла система может принимать программу прямо с терминала, который соответствует псевдофайлу <code>user</code>. Добиться этого можно так:</p>
     <p><code>?- consult( user).</code></p>
     <p>После этого система будет ожидать ввода предложений программы с терминала.</p>
     <p>В некоторых пролог-системах применяется сокращенная запись для чтения программ из файлов. Файлы, из которых предстоит чтение, просто помещаются в список и этот список используется в качестве цели. Например:</p>
     <p><code>?- [файл1, файл2, файл3].</code></p>
     <p>Это в точности эквивалентно следующим трем целям:</p>
     <p><code>?-  соnsult( файл1), соnsult( файл2), соnsult( файл3).</code></p>
     <p>Встроенный предикат <code>reconsult</code> аналогичен <code>consult</code>. Цель</p>
     <p><code>?- reconsult( F).</code></p>
     <p>даст тот же эффект, что и <code>consult( F)</code> с одним исключением. Если в F есть предложения, касающиеся отношений, которые уже были определены ранее, старые определения заменяются на новые из F. Разница между <code>consult</code> и <code>reconsult</code> в том, что <code>consult</code> всегда добавляет новые предложения, в то время как <code>reconsult</code> переопределяет ранее введенные определения. Однако <code>reconsult</code> не произведет никакого эффекта на те отношения, о которых в F ничего не сказано.</p>
     <p>Следует еще раз заметить, что детали "консультирования" с файлами зависят от конкретной реализации Пролога. Это замечание касается и большинства остальных встроенных процедур.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Ввод и вывод (отличный от связанного с вопросами к программе) осуществляется посредством встроенных процедур. В данной главе описан простой и практичный набор таких процедур, имеющихся во многих реализациях Пролога.</p>
     <p>• Файлы являются последовательными. Существуют <emphasis>текущие входной</emphasis> и <emphasis>выходной потоки</emphasis>. Пользовательский терминал рассматривается как файл с именем <code>user</code>.</p>
     <p>• Переключение между потоками осуществляется с помощью процедур:</p>
     <p><code>sее( Файл)</code></p>
     <p> <code>Файл</code> становится текущим входным потоком</p>
     <p><code>tell( Файл)</code></p>
     <p> <code>Файл</code> становится текущим выходным потоком</p>
     <p><code>seen</code></p>
     <p> закрывается текущий входной поток</p>
     <p><code>told</code></p>
     <p> закрывается текущий выходной поток</p>
     <p>• Файлы читаются и записываются двумя способами:</p>
     <p>  как последовательности символов</p>
     <p>  как последовательности термов</p>
     <p>Встроенные процедуры для чтения и записи символов и термов таковы:</p>
     <p><code>rеad( Терм)</code></p>
     <p>  вводит следующий терм</p>
     <p><code>write( Терм)</code></p>
     <p>  выводит <code>Терм</code></p>
     <p><code>put( КодСимвола)</code></p>
     <p>  выводит символ с заданным ASCII-кодом</p>
     <p><code>get0( КодСимвола)</code></p>
     <p>  вводит следующий символ</p>
     <p><code>gеt( КодСимвола)</code> </p>
     <p>  вводит ближайший следующий "печатаемый" символ</p>
     <p>• Две процедуры облегчают форматирование:</p>
     <p><code>nl      </code>начинает новую строку</p>
     <p><code>tab( N) </code>выводит N пробелов</p>
     <p>• Процедура <code>nаmе( Атом, СписокКодов)</code> осуществляет синтез и декомпозицию атомов. <code>СписокКодов</code> — список ASCII кодов символов, образующих <code>Атом</code>. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 7</p>
     <p>Другие встроенные процедуры</p>
    </title>
    <section>
     <p>В данной главе мы изучим некоторые другие, не упоминавшиеся ранее встроенные процедуры, предназначенные для более серьезного программирования на Прологе. Эта новые процедуры дают возможность запрограммировать операции, которые известными нам средствами запрограммировать невозможно. Один набор таких процедур касается обработки термов: эти процедуры проверяют, была ли некоторая переменная конкретизирована целым числом, они разбирают термы на части, конструируют новые термы и т.д. Другой полезный набор процедур работает с "базой данных": процедуры из этого набора добавляют новые отношения в программу или удаляют из нее существующие.</p>
     <p>Множество встроенных процедур сильно зависит от конкретной реализации Пролога. Однако процедуры, обсуждаемые в данной главе, имеются во многих реализациях. Различные реализации могут иметь свои наборы дополнительных средств.</p>
    </section>
    <section>
     <title>
      <p>7.1. Проверка типов термов </p>
     </title>
     <section>
      <title>
       <p>7.1.1. Предикаты <emphasis>var</emphasis>, <emphasis>nоnvar</emphasis>, <emphasis>atom</emphasis>, <emphasis>integer</emphasis>, <emphasis>atomic</emphasis></p>
      </title>
      <p>Термы бывают разных типов: переменные, целые числа, атомы и т.д. Если терм — переменная, то в некоторый момент выполнения программы он может оказаться конкретизированным или не конкретизированным. Далее, если он конкретизирован, то его значение может быть атомом, структурой и т.п. Иногда бывает полезно узнать, каков тип этого значения. Например, пусть мы хотим сложить значения двух переменных X и Y:</p>
      <p><code>Z is X + Y</code></p>
      <p>Перед вычислением этой цели необходимо, чтобы X и Y были конкретизированы целыми числами. Если у нас нет уверенности в том, что X и Y действительно конкретизированы целыми числами, то перед выполнением арифметического действия нужно проверить это программно.</p>
      <p>Для этого следует воспользоваться встроенным предикатом <code>integer</code> (целое). Предикат <code>integer( X)</code> принимает значение истина, если X — целое или если X — переменная, имеющая целое значение. Будем говорить в этом случае, что X "обозначает" целое. Цель для сложения X и Y можно тогда "защитить" такой проверкой переменных X и Y:</p>
      <p><code>..., integer( X), integer( Y), Z is X + Y, ...</code></p>
      <p>Если неверно, что X и Y оба являются целыми, то система и не будет пытаться их сложить. Таким образом, цели <code>integer</code> "охраняют" цель <code>Z is X + Y</code> от бессмысленного вычисления.</p>
      <p>Встроенные предикаты этого типа таковы: <code>var</code> (переменная), <code>nonvar</code> (непеременная), <code>atom</code> (атом), <code>integer</code> (целое), <code>atomic</code> (атомарный). Они имеют следующий смысл:</p>
      <p><code>var( X)</code></p>
      <p>Эта цель успешна, если X в текущий момент — не конкретизированная переменная.</p>
      <p><code>nonvar( X)</code></p>
      <p>Эта цель успешна, если X — терм, отличный от переменной, или если X — уже конкретизированная переменная.</p>
      <p><code>atom( X)</code></p>
      <p>Эта цель истинна, если X обозначает атом.</p>
      <p><code>integer( X)</code></p>
      <p>Цель истинна, если X обозначает целое.</p>
      <p><code>atomic( X)</code></p>
      <p>Цель истинна, если X обозначает целое или атом.</p>
      <p>Следующие примеры вопросов к пролог-системе иллюстрируют применение этих встроенных предикатов:</p>
      <p><code>?- var( Z), Z = 2.</code></p>
      <p><code>Z = 2</code></p>
      <empty-line/>
      <p><code>?- Z = 2, var( Z).</code></p>
      <p><code>no</code></p>
      <empty-line/>
      <p><code>?- integer( Z), Z = 2.</code></p>
      <p><code>no</code></p>
      <empty-line/>
      <p><code>?- Z = 2, integer( Z), nonvar( Z).</code></p>
      <p><code>Z = 2</code></p>
      <empty-line/>
      <p><code>?- atom( 22).</code></p>
      <p><code>no</code></p>
      <empty-line/>
      <p><code>?- atomic( 22).</code></p>
      <p><code>yes</code></p>
      <empty-line/>
      <p><code>?- atom( ==&gt;).</code></p>
      <p><code>yes</code></p>
      <empty-line/>
      <p><code>?- atom( p( 1) ).</code></p>
      <p><code>no</code></p>
      <p>Необходимость в предикате <code>atom</code> продемонстрируем на следующем примере. Пусть мы хотим подсчитать, сколько раз заданный атом встречается в некоторой списке объектов. Для этого мы определим процедуру</p>
      <p><code>счетчик( А, L, N)</code></p>
      <p>где <code>А</code> — атом, <code>L</code> — список и <code>N</code> — количество вхождений этого атома. В качестве первой попытки можно было бы определить <code>счетчик</code> так:</p>
      <p><code>счетчик( _, [], 0).</code></p>
      <p><code>счетчик( A, [A | L], N) :- !,</code></p>
      <p><code> счетчик( A, L, N1),</code></p>
      <p><code>  % N1 - число вхождений атома в хвост</code></p>
      <p><code> N is N1 + 1.</code></p>
      <p><code>счетчик( А, [ _ | L], N) :-</code></p>
      <p><code> счетчик( A, L, N).</code></p>
      <p>Теперь на нескольких примерах посмотрим, как эта процедура работает:</p>
      <p><code>?- счетчик( а, [а, b, а, а], N).</code></p>
      <p><code>N = 3</code></p>
      <empty-line/>
      <p><code>?- счетчик( a, [a, b, X, Y], Na).</code></p>
      <p><code>Na = 3</code></p>
      <p><code>...</code></p>
      <empty-line/>
      <p><code>?- счетчик( b, [a, b, X, Y], Nb).</code></p>
      <p><code>Nb = 3</code></p>
      <p><code>...</code></p>
      <empty-line/>
      <p><code>?- L=[a, b, X, Y], счетчик( а, L, Na), счетчик( b, L, Nb).</code></p>
      <p><code>Na = 3</code></p>
      <p><code>Nb = 1</code></p>
      <p><code>X = a</code></p>
      <p><code>Y = a</code></p>
      <p><code>...</code></p>
      <p>В последнем примере как X, так и Y после конкретизации получили значение <code>а</code>, и поэтому Nb оказалось равным только 1, однако мы хотели не этого. Нас интересовало количество реальных появлений конкретного <emphasis>атома</emphasis>, а вовсе не число термов, <emphasis>сопоставимых</emphasis> с этим атомом. В соответствии с этим более точным определением отношения <code>счетчик</code> мы должны теперь проверять, является ли голова списка атомом. Усовершенствованная программа выглядит так:</p>
      <p><code>счетчик( _, [], 0).</code></p>
      <p><code>счетчик( А, [В | L], N) :-</code></p>
      <p><code> atom( В), А = В, !, % B равно атому А?</code></p>
      <p><code>счетчик( A, L, N1),  % Подсчет в хвосте</code></p>
      <p><code> N is N1 + 1;</code></p>
      <p><code>счетчик( А, L, N).</code></p>
      <p><code>  % Иначе - подсчитать только в хвосте</code></p>
      <p>В следующем более сложном упражнении по программированию числовых ребусов используется предикат <code>nonvar</code>.</p>
     </section>
     <section>
      <title>
       <p>7.1.2. Решение числового ребуса с использованием <emphasis>nonvar</emphasis></p>
      </title>
      <p>Известным примером числового ребуса является</p>
      <p><code>D O N A L D</code></p>
      <p><code>+</code></p>
      <p><code>G E R A L D</code></p>
      <p><code>-----------</code></p>
      <p><code>R O B E R T</code></p>
      <p>Задача состоит в том. чтобы заменить буквы D, О, N и т.д. на цифры таким образом, чтобы вышеприведенная сумма была правильной. Разным буквам должны соответствовать разные цифры, иначе возможно тривиальное решение, например, все буквы можно заменить на нули.</p>
      <p>Определим отношение</p>
      <p><code>сумма( N1, N2, N)</code></p>
      <p>где N1, N2 и N представляют три числа данного ребуса. Цель <code>cyммa(N1, N2, N)</code> достигается, если существует такая замена букв цифрами, что N1+N2 = N.</p>
      <p>Первым шагом к решению будет выбор представления чисел N1, N2 и N в программе. Один из способов - представить каждое число в виде списка его цифр. Например, число 255 будет тогда представляться списком [2, 2, 5]. Поскольку значения цифр нам не известны заранее, каждая цифра будет обозначаться соответствующей неинициализированной переменной. Используя это представление, мы можем сформулировать задачу так:</p>
      <p><code>  [ D, O, N, A, L, D ]</code></p>
      <p><code>+ [ G, E, R, A, L, D ]</code></p>
      <p><code>= [ R, О, B, E, R, T ]</code></p>
      <p>Теперь задача состоит в том. чтобы найти такую конкретизацию переменных D, О, N и т.д., для которой сумма верна. После того, как отношение <code>сумма</code> будет запрограммировано, задание для пролог-системы на решение ребуса будет иметь вид</p>
      <p><code>?- сумма( [D, O, N, A, L, D], [G, E, R, A, L, D],</code></p>
      <p><code> [R, O, В, E, R, T ).</code></p>
      <image l:href="#_47.png"/>
      <p><strong>Рис. 7.1. </strong>Поразрядное сложение. Отношения в показанном i-м разряде такие: D<sub>3i </sub>= (C1 + D<sub>1i</sub> + D<sub>2i</sub>) mod 10; C = (C1 + D<sub>1i</sub> + D<sub>2i</sub>) div 10 (div — целочисленное деление, mod — остаток от деления).</p>
      <p>Для определения отношения <code>сумма</code> над списками цифр нам нужно запрограммировать реальные правила суммирования в десятичной системе счисления. Суммирование производится цифра за цифрой, начиная с младших цифр в сторону старших, всякий раз учитывая цифру переноса справа. Необходимо также сохранять множество допустимых цифр, т.е. цифр, которые еще не были использованы для конкретизации уже встретившихся переменных. Поэтому, вообще говоря, кроме трех чисел N1, N2 и N в рассмотрении должна участвовать некоторая дополнительная информация, как показано на рис. 7.1:</p>
      <p>• перенос перед сложением</p>
      <p>• перенос после сложения</p>
      <p>• множество цифр, доступных перед сложением</p>
      <p>• оставшиеся цифры, не использованные при сложении</p>
      <p>Для формулировки отношения <code>сумма</code> мы снова воспользуемся принципом обобщения задачи: введем вспомогательное, более общее отношение <code>сумма1</code>. Это отношение будет иметь несколько дополнительных аргументов, соответствующих той дополнительной информации, о которой говорилось выше:</p>
      <p><code>сумма1( N1, N2, N, C1, С, Цифры1, Цифры)</code></p>
      <p>Здесь N1, N2 и N — наши три числа, как и в отношении сумма, C1 — перенос справа (до сложения N1 и N2), а С — перенос влево (после сложения). Пример:</p>
      <p><code>?- сумма1( [H, E], [6, E], [U, S], 1, 1,</code></p>
      <p><code> [1, 3, 4, 7, 8, 9], Цифры ).</code></p>
      <empty-line/>
      <p><code>H = 8</code></p>
      <p><code>E = 3</code></p>
      <p><code>S = 7</code></p>
      <p><code>U = 4</code></p>
      <p><code>Цифры = [1, 9]</code></p>
      <p>Если N1 и N удовлетворяют отношению <code>сумма</code>, то, как показано на рис. 7.1, C1 и С должны быть равны 0. <code>Цифры1</code> — список цифр, которые не были использованы для конкретизации переменных. Поскольку мы допускаем использование в отношении <code>сумма</code> любых цифр, ее определение в терминах отношения <code>сумма1</code> выглядит так:</p>
      <p><code>сумма( N1, N2, N) :-</code></p>
      <p><code> cyммa1( N1, N2, N, 0, 0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ ).</code></p>
      <p>Бремя решения задачи переложено теперь на отношение <code>сумма1</code>. Но это отношение является уже достаточно общим, чтобы можно было определить его рекурсивно. Без ограничения общности мы предположим, что все три списка, представляющие три числа, имеют одинаковую длину. Наш пример, конечно, удовлетворяет этому условию, но если это не так, то всегда можно приписать слева нужное количество нулей к более "короткому" числу.</p>
      <p>Определение отношения <code>сумма1</code> можно разбить на два случая:</p>
      <p>(1) Все три числа представляются пустыми списками. Тогда</p>
      <p><code>сумма1( [], [], [], 0, 0, Циф, Циф).</code></p>
      <p>(2) Все три числа имеют какую-то самую левую цифру и справа от нее - остальные цифры. То есть, они имеют вид:</p>
      <p><code>[D1 | N1], [D2 | N2], [D | N]</code></p>
      <p>В этом случае должны выполняться два условия:</p>
      <p> (а) Оставшиеся цифры, рассматриваемые как три числа N1, N2 и N, сами должны удовлетворять отношению <code>сумма1</code>, выдавая влево некоторый перенос C2 и оставляя некоторое подмножество неиспользованных цифр <code>Циф2</code>.</p>
      <p> (b) Крайние левые цифры D1, D2 и D, а также перенос C2 должны удовлетворять отношению, показанному на рис. 7.1: C2, D1 и D2 складываются, давая в результате D и перенос влево. Это условие в нашей программе формулируется в виде отношения <code>суммацифр</code>.</p>
      <p>Переводя это на Пролог, получаем:</p>
      <p><code>сумма1( [D1 | N1], [D2 | N2], [D | N], C1, С, Циф1, Циф) :-</code></p>
      <p><code> сумма1( Nl, N2, N, C1, C2, Циф1, Циф2),</code></p>
      <p><code> суммацифр( D1, D2, C2, D, С, Циф2, Циф).</code></p>
      <p>Осталось только описать на Прологе отношение <code>суммацифр</code>. В его определении есть одна тонкая деталь, касающаяся применения металогического предиката <code>nonvar</code>. D1, D2 и D должны быть десятичными цифрами. Если хоть одна из этих переменных еще не конкретизирована, ее нужно конкретизировать какой-нибудь цифрой из списка <code>Циф2</code>. Как только такая конкретизация произошла, эту цифру нужно удалить из множества доступных цифр. Если D1, D2 и D уже конкретизированы, тогда, конечно, ни одна из доступных цифр "потрачена" не будет. В программе эти действия реализуются при помощи недетерминированного вычеркивания элемента списка. Если этот элемент - не переменная, ничего не вычеркивается (конкретизации не было). Вот эта программа:</p>
      <p><code>удалить( Элемент, Список, Список) :-</code></p>
      <p><code> nonvar( Элемент), !.</code></p>
      <p><code>удалить( Элемент, [Элемент | Список ], Список).</code></p>
      <p><code>удалить(Элемент, [А | Список], [А | Список1]) :-</code></p>
      <p><code> удалить( Элемент, Список, Список1).</code></p>
      <p>Полная программа для решения арифметических ребусов приводится на рис. 7.2. В программу включены также определения двух ребусов. Вопрос к пролог-системе для ребуса про DONALD'a, GERALD'a и ROBERT'a с использованием этой программы выглядит так:</p>
      <p><code>?- ребус1( N1, N2, N), сумма( N1, N2, N).</code></p>
      <empty-line/>
      <p><code>% Решение числовых ребусов</code></p>
      <p><code>сумма( N1, N2, N) :-</code></p>
      <p><code>  % Числа представлены в виде списков цифр</code></p>
      <p><code> сумма1( N1, N2, N,</code></p>
      <p><code>  0, 0,</code></p>
      <p><code>   % Перенос справа и перенос влево равны 0</code></p>
      <p><code>  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], _ ).</code></p>
      <p><code>   % Все цифры доступны</code></p>
      <empty-line/>
      <p><code>сумма1( [], [], [], 0, 0, Цифры, Цифры).</code></p>
      <p><code>сумма1( [D1 | N1], [D2 | N2], [D | N], C1, С, Циф1, Циф) :-</code></p>
      <p><code> сумма1( Nl, N2, N, C1, C2, Циф1, Циф2),</code></p>
      <p><code> суммацифр( Dl, D2, C2, С, Циф2, Циф).</code></p>
      <empty-line/>
      <p><code>суммацифр( Dl, D2, C1, D, С, Циф1, Циф) :-</code></p>
      <p><code> удалить( D1, Циф1, Циф2),</code></p>
      <p><code>  % Выбор доступной цифры для D1</code></p>
      <p><code> удалить( D2, Циф2, Циф3),</code></p>
      <p><code>  % Выбор доступной цифры для D2</code></p>
      <p><code> удалить( D, Циф3, Циф),</code></p>
      <p><code>  % Выбор доступной цифры для D</code></p>
      <p><code> S is D1 + D2 + C1,</code></p>
      <p><code> D is S mod 10,</code></p>
      <p><code> С is S div 10.</code></p>
      <empty-line/>
      <p><code>удалить( A, L, L) :-</code></p>
      <p><code> nonvar( A), !.</code></p>
      <p><code>  % Переменная А уже конкретизирована</code></p>
      <p><code>удалить( А, [А | L], L).</code></p>
      <p><code>удалить( А, [В | L], [В | L1]) :-</code></p>
      <p><code> удалить( A, L, L1).</code></p>
      <empty-line/>
      <p><code>% Примеры ребусов</code></p>
      <p><code>ребус1( [D, O, N, A, L, D],</code></p>
      <p><code> [G, E, R, A, L, D],</code></p>
      <p><code> [R, O, B, E, R, T].</code></p>
      <empty-line/>
      <p><code>ребус2( [0, S, E, N, D],</code></p>
      <p><code> [0, M, O, R, E],</code></p>
      <p><code> [M, O, N, E, Y].</code></p>
      <p><strong>Рис. 7.2.</strong>  Программа для арифметических ребусов.</p>
      <empty-line/>
      <p>Иногда этот ребус упрощают, сообщая часть решения в виде дополнительного ограничения, например D равно 5. В такой форме ребус можно передать пролог-системе при помощи <code>сумма1</code>:</p>
      <p><code>?- сумма1( [5, O, N, A, L, 5],</code></p>
      <p><code> [G, E, R, A, L, 5],</code></p>
      <p><code> [R, O, B, E, R, T],</code></p>
      <p><code> 0, 0, [0, 1, 2, 3, 4, 6, 7, 8, 9], _ ).</code></p>
      <p>Интересно, что в обоих случаях существует только одно решение, т.е. только один способ заменить буквы цифрами.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>7.1.</strong> Напишите процедуру <code>упростить</code> для упрощения алгебраических сумм, в которых участвуют числа и символы (строчные буквы). Пусть эта процедура переупорядочивает слагаемые так, чтобы символы предшествовали числам. Вот примеры ее использования:</p>
      <p><code>?- упростить( 1 + 1 + а, E).</code></p>
      <p><code>E = а + 2</code></p>
      <empty-line/>
      <p><code>?- упростить( 1 + a + 4 + 2 + b + с, E).</code></p>
      <p><code>E = а + b + с + 7</code></p>
      <empty-line/>
      <p><code>?- упростить( 3 + x + x, E).</code></p>
      <p><code>E = 2*x + 3</code></p>
      <p><strong>7.2.</strong> Определите процедуру</p>
      <p><code>добавить( Элемент, Список)</code></p>
      <p>для добавления нового элемента в список. Предполагается, что все элементы, хранящиеся в списке, — атомы. <code>Список</code> состоит из всех хранящихся в нем элементов, а за ними следует хвост, который не конкретизирован и служит для принятия новых элементов. Пусть, например, в списке уже хранятся <code>а</code>, <code>b</code> и <code>с</code>, тогда</p>
      <p><code>Список = [а, b, с | Хвост]</code></p>
      <p>где <code>Хвост</code> — переменная. Цель</p>
      <p><code>добавить( d, Список)</code></p>
      <p>вызовет конкретизацию</p>
      <p><code>Xвoст = [d | НовыйХвост]</code> и</p>
      <p><code>Список = [а, b, с, d | НовыйХвост]</code></p>
      <p>Таким способом структура может наращиваться, включая в себя новые элементы. Определите также соответствующее отношение принадлежности.</p>
     </section>
    </section>
    <section>
     <title>
      <p>7.2. Создание и декомпозиция термов: <emphasis>=.., functor, arg, name</emphasis></p>
     </title>
     <p>Имеются три встроенные предиката для декомпозиции и синтеза термов: <code>functor</code>, <code>arg</code> и <code>=..</code>. Рассмотрим сначала отношение <code>=..</code>, которое записывается как инфиксный оператор. Цель</p>
     <p><code>Терм =.. L</code></p>
     <p>истинна, если L — список, начинающийся с главного функтора терма <code>Терм</code>, вслед за которым идут его аргументы. Вот примеры:</p>
     <p><code>?- f( а, b) =.. L.</code></p>
     <p><code>L = [f, а, b]</code></p>
     <empty-line/>
     <p><code>?- T =.. [прямоугольник, 3, 5].</code></p>
     <p><code>T = прямоугольник( 3, 5)</code></p>
     <empty-line/>
     <p><code>?- Z =.. [p, X, f( X,Y) ].</code></p>
     <p><code>Z = p( X, f( X,Y) )</code></p>
     <p>Зачем может понадобиться разбирать терм на составляющие компоненты — функтор и его аргументы? Зачем создавать новый терм из заданного функтора и аргументов? Следующий пример показывает, что это действительно нужно.</p>
     <p>Рассмотрим программу, которая манипулирует геометрическими фигурами. Фигуры — это квадраты, прямоугольники, треугольники, окружности в т.д. В программе их можно представлять в виде термов, функтор которых указывает на тип фигуры, а аргументы задают ее размеры:</p>
     <p><code>квадрат( Сторона)</code></p>
     <p><code>треугольник( Сторона1, Сторона2, Сторона3)</code></p>
     <p><code>окружность( R)</code></p>
     <p>Одной из операций над такими фигурами может быть увеличение. Его можно реализовать в виде трехаргументного отношения</p>
     <p><code>увел( Фиг, Коэффициент, Фиг1)</code></p>
     <p>где <code>Фиг</code> и <code>Фиг1</code> — геометрические фигуры одного типа (с одним в тем же функтором), причем параметры <code>Фиг1</code> равны параметрам <code>Фиг</code>, умноженным на <code>Коэффициент</code>. Для простоты будем считать, что все параметры <code>Фиг</code>, а также <code>Коэффициент</code> уже известны, т.е. конкретизированы числами. Один из способов программирования отношения <code>увел</code> таков:</p>
     <p><code>увел( квадрат( A), F, квадрат( А1) ) :-</code></p>
     <p><code> A1 is F*A</code></p>
     <empty-line/>
     <p><code>увел( окружность( R), F, окружность( R1) ) :-</code></p>
     <p><code> R1 is F*R1</code></p>
     <empty-line/>
     <p><code>увел( прямоугольник( А, В), F, прямоугольник( А1, В1)) :-</code></p>
     <p><code> A1 is F*A, B1 is F*B.</code></p>
     <p>Такая программа будет работать, однако она будет выглядеть довольно неуклюже при большом количестве различных типов фигур. Мы будем вынуждены заранее предвидеть все возможные типы, которые могут когда-либо встретиться. Придется заготовить по предложению на каждый тип, хотя во всех этих предложениях по существу говорится одно и то же: возьми параметры исходной фигуры, умножь их на коэффициент и создай фигуру того же типа с этими новыми параметрами.</p>
     <p>Ниже приводится программа, в которой делается попытка (неудачная) справиться для начала хотя бы со всеми однопараметрическими фигурами при помощи одного предложения:</p>
     <p><code>увел( Тип( Пар), F, Тип( Пар1) ):-</code></p>
     <p><code> Пар1 is F*Пар.</code></p>
     <p>Однако в Прологе подобные конструкции, как правило, запрещены, поскольку функтор должен быть атомом, и, следовательно, переменная <code>Тип</code> синтаксически не будет воспринята как функтор. Правильный метод — воспользоваться предикатом '<code>=..</code>'. Тогда процедура <code>увел</code> будет иметь обобщенную формулировку, пригодную для фигур любых типов:</p>
     <p><code>увел( Фиг, F, Фиг1):-</code></p>
     <p><code> Фиг =.. [Тип | Параметры],</code></p>
     <p><code> умножспис( Параметры, F, Параметры1),</code></p>
     <p><code> Фиг1 =.. [Тип | Параметры)].</code></p>
     <empty-line/>
     <p><code>умножспис( [], _, []).</code></p>
     <p><code>умножспис( [X | L], F, [X1 | L1] ) :-</code></p>
     <p><code> X1 is F*X, умножспис( L, F, L1).</code></p>
     <p>Наш следующий пример использования предиката '<code>=..</code>' связан с обработкой символьных выражений (формул), где часто приходится подставлять вместо некоторого подвыражения другое выражение. Мы определим отношение</p>
     <p><code>подставить( Подтерм, Терм, Подтерм1, Терм1)</code></p>
     <p>следующим образом: если все вхождения <code>Подтерм</code>'а в <code>Терм</code> заменить на <code>Подтерм1</code>, то получится <code>Терм1</code>. Например:</p>
     <p><code>?- подставить( sin( x), 2*sin( x)*f( sin( x)), t, F ).</code></p>
     <p><code>F = 2*t*f( t)</code></p>
     <p>Под "вхождением" <code>Подтерм</code>'а в <code>Терм</code> мы будем понимать такой элемент <code>Терм</code>'а, который <emphasis>сопоставим</emphasis> с <code>Подтерм</code>'ом. Вхождения будем искать сверху вниз. Поэтому цель</p>
     <p><code>?- подставить( а+b, f( а, А+В), v, F).</code></p>
     <p>даст результат</p>
     <p><code>F = f( а, v)</code></p>
     <p><code>А = а</code></p>
     <p><code>В = b</code></p>
     <p>а не</p>
     <p><code>F = f( a, v + v)</code></p>
     <p><code>А = а + b</code></p>
     <p><code>В = а + b</code></p>
     <p>При определении отношения <code>подставить</code> нам нужно рассмотреть несколько случаев и для каждого принять свое решение:</p>
     <p>если <code>Подтерм</code> = <code>Терм</code>, то <code>Терм1</code> = <code>Подтерм1</code>;</p>
     <p>иначе если <code>Терм</code> — "атомарный" (не структура),</p>
     <p> то <code>Терм1</code> = <code>Терм</code> (подставлять нечего),</p>
     <p> иначе подстановку нужно выполнить над аргументами <code>Tерм</code>'a.</p>
     <p>Эти правила можно превратить в программу, показанную на рис. 7.3.</p>
     <p>Термы, полученные при помощи предиката '<code>=..</code>', разумеется, можно использовать и в качестве целей. Это дает возможность программе в процессе вычислений самой порождать и вычислять цели, структура которых не обязательно была известна заранее в момент написания программы. Последовательность целей, иллюстрирующая этот прием, могла бы выглядеть примерно так:</p>
     <p><code>получить( Функтор),</code></p>
     <p><code> вычислить( Списарг),</code></p>
     <p><code> Цель =.. [Функтор | Списарг],</code></p>
     <p><code> Цель</code></p>
     <p>Здесь <code>получить</code> и <code>вычислить</code> — некоторые определенные пользователем процедуры, предназначенные для вычисления компонент цели. После этого цель порождается предикатом '<code>=..</code>', а затем активизируется при помощи простого указания ее имени <code>Цель</code>.</p>
     <empty-line/>
     <p><code>% Отношение</code></p>
     <p><code>%</code></p>
     <p><code>% подставить( Подтерм, Терм, Подтерм1, Терм1)</code></p>
     <p><code>%</code></p>
     <p><code>% состоит в следующем: если все вхождения Подтерм'а в Терм</code></p>
     <p><code>% заменить на Подтерм1, то получится Терм1.</code></p>
     <empty-line/>
     <p><code>% Случай 1: Заменить весь терм</code></p>
     <p><code>подставить( Терм, Терм, Терм1, Терм1) :- !.</code></p>
     <empty-line/>
     <p><code>% Случай 2: нечего подставлять</code></p>
     <p><code>подставить( _, Терм, _, Терм) :-</code></p>
     <p><code> atomic( Терм), !.</code></p>
     <empty-line/>
     <p><code>% Случай 3: Проделать подстановку в аргументах</code></p>
     <p><code>подставить( Под, Терм, Под1, Терм1) :-</code></p>
     <p><code> Терм =.. [F | Арги],</code></p>
     <p><code>  % Выделить аргументы</code></p>
     <p><code> подспис( Под, Арги, Под1, Арги1),</code></p>
     <p><code>  % Выполнить над ними подстановку</code></p>
     <p><code> Терм1 =.. [F | Арги1].</code></p>
     <empty-line/>
     <p><code>подспис( Под, [Терм | Термы], Под1, [Терм1 | Термы1]) :-</code></p>
     <p><code> подставить( Под, Терм, Под1, Терм1),</code></p>
     <p><code> подспис( Под, Термы, Под1, Термы1).</code></p>
     <p><strong>Рис. 7.3.</strong>  Процедура подстановки в терм вместо одного из его подтермов некоторого другого подтерма.</p>
     <empty-line/>
     <p>Некоторые реализации Пролога могут содержать требование, чтобы все цели, появляющиеся в программе, по своей <emphasis>синтаксической</emphasis> форме были либо атомами, либо структурами с атомом в качестве главного функтора. Поэтому переменная, вне зависимости от ее текущей конкретизации, может по своей синтаксической форме не подойти в качестве цели. Эту трудность можно обойти при помощи еще одного встроенного предиката <code>call</code> (вызов), чьим аргументом является цель, подлежащая вычислению. В соответствий с этим предыдущий пример должен быть переписан так:</p>
     <p><code>...</code></p>
     <p><code>Цель = [Функтор | Списарг],</code></p>
     <p><code>саll( Цель)</code></p>
     <p>Иногда нужно извлечь из терма только его главный функтор или один из аргументов. В этом случае можно, конечно, воспользоваться отношением '<code>=..</code>'. Но более аккуратным и практичным, а также и более эффективным способом будет применение одной из двух новых встроенных процедур: <code>functor</code> и <code>аrg</code>. Вот их смысл: цель</p>
     <p><code>functor( Терм, F, N)</code></p>
     <p>истинна, если <code>F</code> — главный функтор <code>Tepм</code>'a, а <code>N</code> — арность <code>F</code>. Цель</p>
     <p><code>arg( N, Терм, А)</code></p>
     <p>истинна, если <code>А</code> — N-й аргумент в <code>Терм</code>'е, в предположении, что нумерация аргументов идет слева направо и начинается с 1. Примеры для иллюстрации:</p>
     <p><code>?- functor( t( f( x), X, t), Фун, Арность).</code></p>
     <p><code>Фун = t</code></p>
     <p><code>Арность = 3</code></p>
     <empty-line/>
     <p><code>?- аrg( 2, f( X, t( a), t( b) ), Y).</code></p>
     <p><code>Y = t( a)</code></p>
     <empty-line/>
     <p><code>?- functor( D, дата, 3),</code></p>
     <p><code>arg( 1, D, 29),</code></p>
     <p><code>arg( 2, D, июнь),</code></p>
     <p><code>arg( 3, D, 1982).</code></p>
     <p><code>D = дата( 29, июнь, 1982)</code></p>
     <p>Последний пример иллюстрирует особый случай применения предиката <code>functor</code>. Цель <code>functor( D, дата, 3)</code> создает "обобщенный" терм с главным функтором <code>дата</code> и тремя аргументами. Этот терм обобщенный, так как все три его аргумента — не конкретизированные переменные, чья имена генерируются пролог-системой. Например:</p>
     <p><code>D = дата( _5, _6, _7)</code></p>
     <p>Затем эти три переменные конкретизируются при помощи трех целей <code>аrg</code>.</p>
     <p>К рассматриваемому множеству встроенных предикатов относится также и введенный в гл. 6 предикат <code>name</code>, предназначенный для синтеза и декомпозиция атомов. Для полноты изложения мы здесь напомним его смысл. Цель</p>
     <p><code>name( A, L)</code></p>
     <p>истинна, если L — список кодов (в кодировке ASCII) символов, входящих в состав атома А.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>7.3.</strong> Определите предикат <code>конкрет(Терм)</code> так, чтобы он принимал значение истина, когда в <code>Tepм</code>'e нет ни одной неконкретизированной переменной.</p>
     <p><strong>7.4.</strong> Процедура <code>подставить</code> из данного раздела производит, при наличии разных вариантов, лишь самую "внешнюю" подстановку.</p>
     <p>Модифицируйте эту процедуру так, чтобы она находила все возможные варианты при помощи автоматического перебора. Например:</p>
     <p><code>?- подставить( a+b, f( A+B), новый, НовыйТерм).</code></p>
     <p><code>А = а</code></p>
     <p><code>В = b</code></p>
     <p><code>НовыйТерм = f( новый);</code></p>
     <empty-line/>
     <p><code>А = а+b</code></p>
     <p><code>В = а+b</code></p>
     <p><code>НовыйТерм = f( новый + новый)</code></p>
     <p>Наша исходная версия нашла бы только первый из этих двух ответов.</p>
     <p><strong>7.5. </strong>Определите отношение</p>
     <p><code>включает( Tepм1, Терм2)</code></p>
     <p>которое выполняется, если <code>Терм1</code> является более общим, чем <code>Терм2</code>. Например:</p>
     <p><code>?- включает( X, с).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- включает( g( X), g( t( Y))).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- включает f( X,X), f( a,b)).</code></p>
     <p><code>no</code></p>
    </section>
    <section>
     <title>
      <p>7.3. Различные виды равенства</p>
     </title>
     <p>В каких случаях мы считаем, что два терма равны? До сих пор мы рассматривали три вида равенства в Прологе. Первый был связан с сопоставлением и записывался так:</p>
     <p><code>X = Y</code></p>
     <p>Это равенство верно, если X и Y сопоставимы. Следующий вид равенства записывался в виде</p>
     <p><code>X is E</code></p>
     <p>Такое равенство выполняется, если X сопоставим со значением арифметического выражения E. Мы также рассматривали равенства вида</p>
     <p><code>Е1 =:= Е2</code></p>
     <p>которые верны, если равны значения арифметических выражений Е1 и Е2. Наоборот, если значения двух арифметических выражений не равны, мы пишем</p>
     <p><code>Е1 =/= Е2</code></p>
     <p>Иногда нам может понадобиться более строгий вид равенства - <emphasis>буквальное равенство</emphasis> двух термов. Этот вид реализован еще одним встроенным предикатом, записываемым как инфиксный оператор '<code>==</code>':</p>
     <p><code>Т1 == Т2</code></p>
     <p>Это равенство выполняется, если термы Т1 и Т2 идентичны, т.е. имеют в точности одинаковую структуру, причем все соответствующие компоненты совпадают. В частности, должны совпадать и имена переменных. Отношение "не идентичны", дополнительное к данному, записывается так:</p>
     <p><code>T1 \== T2</code></p>
     <p>Приведем несколько примеров:</p>
     <p><code>?- f( a, b) == f( а, b).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- f( a, b) == f( a, X).</code></p>
     <p><code>nо</code></p>
     <empty-line/>
     <p><code>?- f( a, X) == f( a, Y).</code></p>
     <p><code>no</code></p>
     <empty-line/>
     <p><code>?- X \== Y.</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- t( X, f( a, Y) ) == t( X, f( a, Y) ).</code></p>
     <p><code>yes</code></p>
     <p>Давайте в качестве примера переопределим отношение</p>
     <p><code>счетчик( Терм, Список, N)</code></p>
     <p>из разд. 7.1. Пусть на этот раз N будет числом буквальных вхождений <code>Терм</code>'а в <code>Список</code>:</p>
     <p><code>счетчик( _, [], 0).</code></p>
     <p><code>счетчик( Терм, [Голова | L], N) :-</code></p>
     <p><code> Терм == Голова, !,</code></p>
     <p><code> счетчик( Терм, L, N1),</code></p>
     <p><code> N is N1 + 1;</code></p>
     <p><code>счетчик( Терм, L, N).</code> </p>
    </section>
    <section>
     <title>
      <p>7.4. Работа с базой данных</p>
     </title>
     <p>Реляционная модель предполагает, что база данных — это описание некоторого множества отношений. Пролог-программу можно рассматривать как именно такую базу данных: описание отношений частично присутствует в ней в явном виде (факты), а частично — в неявном (правила). Более того, встроенные предикаты дают возможность корректировать эту базу данных в процессе выполнения программ. Это делается добавлением к программе (в процессе вычисления) новых предложений или же вычеркиванием из нее уже существующих. Предикаты, используемые для этой цели, таковы: <code>assert</code> (добавить), <code>asserta</code>, <code>assertz</code> и <code>retract</code> (удалить).</p>
     <p>Цель</p>
     <p><code>assert( С)</code></p>
     <p>всегда успешна, а в качестве своего побочного эффекта вызывает "констатацию" предложения С, т.е. добавление его к базе данных.</p>
     <p>Цель</p>
     <p><code>retract( С)</code></p>
     <p>приводит к противоположному эффекту: удаляет предложение, сопоставимое с С. Следующий диалог иллюстрирует их работу:</p>
     <p><code>?- кризис.</code></p>
     <p><code>no</code></p>
     <empty-line/>
     <p><code>?- assert( кризис).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- кризис.</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- retract( кризис).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- кризис.</code></p>
     <p><code>no</code></p>
     <p>Предложения, добавленные к программе таким способом, ведут себя точно так же, как и те, что были в "оригинале" программы. Следующий пример показывает, как с помощью <code>assert</code> и <code>retract</code> можно работать в условиях изменяющейся обстановки. Предположим, что у нас есть такая программа о погоде:</p>
     <p><code>хорошая :-</code></p>
     <p><code> солнечно, not дождь.</code></p>
     <empty-line/>
     <p><code>необычная :-</code></p>
     <p><code> солнечно, дождь.</code></p>
     <empty-line/>
     <p><code>отвратительная :-</code></p>
     <p><code> дождь, туман.</code></p>
     <empty-line/>
     <p><code>дождь.</code></p>
     <empty-line/>
     <p><code>туман.</code></p>
     <p>Ниже приводится пример диалога с этой программой, во время которого база данных постепенно изменяется:</p>
     <p><code>?- хорошая.</code></p>
     <p><code>no</code></p>
     <empty-line/>
     <p><code>?- отвратительная.</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- retract( туман).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- отвратительная.</code></p>
     <p><code>no</code></p>
     <empty-line/>
     <p><code>?- assert( солнечно).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- необычная.</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- retract( дождь).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- хорошая.</code></p>
     <p><code>yes</code></p>
     <p>Добавлять и удалять можно предложения любой формы. Следующий пример показывает, что, кроме того, <code>retract</code> может работать недетерминировано: используя механизм возвратов с помощью только одной цели <code>retract</code> можно удалить целое множество предложений. Предположим, что в программе, с которой мы "консультируемся", есть такие факты:</p>
     <p><code>быстр( энн).</code></p>
     <p><code>медл( том).</code></p>
     <p><code>медл( пат).</code></p>
     <p>К этой программе можно добавить правило:</p>
     <p><code>?- assert(</code></p>
     <p><code> ( быстрее( X, Y) :-</code></p>
     <p><code>   быстр( X), медл( Y) ) ).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- быстрее( А, В).</code></p>
     <p><code>А = энн</code></p>
     <p><code>В = том</code></p>
     <empty-line/>
     <p><code>?- retract( медл( X) ).</code></p>
     <p><code>X = том;</code></p>
     <p><code>X = пат;</code></p>
     <p><code>nо</code></p>
     <empty-line/>
     <p><code>?- быстрее( энн, _ ).</code></p>
     <p><code>nо</code></p>
     <p>Заметьте, что при добавлении нового правила синтаксис требует, чтобы оно (как аргумент <code>assert</code>) было заключено в скобки.</p>
     <p>При добавлении нового предложения может возникнуть желание указать, на какое место в базе данных его следует поместить. Такую возможность обеспечивают предикаты <code>asserta</code> и <code>assertz</code>. Цель</p>
     <p><code>asserta( С)</code></p>
     <p>помещает С в начале базы данных. Цель</p>
     <p><code>assertz( С)</code></p>
     <p>— в конце. Вот пример, иллюстрирующий работу этих предикатов:</p>
     <p><code>?- assеrt( p( a)), assertz( p( b) ), asserta( p( c) ).</code></p>
     <p><code>yes</code></p>
     <empty-line/>
     <p><code>?- p( X).</code></p>
     <p><code>X = с;</code></p>
     <p><code>X = а;</code></p>
     <p><code>X = b</code></p>
     <p>Между <code>consult</code> и <code>assertz</code> существует связь. Обращение к файлу при помощи <code>consult</code> можно в терминах <code>assertz</code> определить так: считать все термы (предложения) файла и добавить их в конец базы данных.</p>
     <p>Одним из полезных применений предиката <code>asserta</code> является накопление уже вычисленных ответов на вопросы. Пусть, например, в программе определен предикат</p>
     <p><code>решить( Задача, Решение)</code></p>
     <p>Мы можем теперь задать вопрос и потребовать, чтобы ответ на него был запомнен, с тем чтобы облегчить получение ответов на будущие вопросы:</p>
     <p><code>?- решить( задача1, решение),</code></p>
     <p><code> asserta( решить( Задача1, Решение) ).</code></p>
     <p>Если в первой из приведенных целей будет успех, ответ <code>( Решение)</code> будет сохранен, а затем использован так же, как и любое другое предложение, при ответе на дальнейшие вопросы.</p>
     <p>Преимущество такого "запоминания" состоит в том, что на дальнейшие вопросы, сопоставимые с добавленным фактом, ответ будет получен, как правило, значительно быстрее, чем в первый раз. Ответ будет теперь получен как факт, а не как результат вычислений, требующих, возможно, длительного времени.</p>
     <p>Развитие этой идеи состоит в использовании <code>assert</code> для порождения всех решений в виде таблицы фактов. Например, создать таблицу произведений всех чисел от 0 до 9 можно так: породить пару чисел X и Y, вычислить Z, равное X * Y, добавить эти три числа в виде строки в таблицу произведений, а затем создать искусственно неуспех. Неуспех вызовет возврат, в результате которого будет найдена новая пара чисел, и в таблицу добавится новая строка и т.д. Эта идея реализована в процедуре</p>
     <p><code>таблица :-</code></p>
     <p><code> L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],</code></p>
     <p><code> принадлежит( X, L), % Выбрать первый сомножитель</code></p>
     <p><code> принадлежит( Y, L), % Выбрать второй сомножитель</code></p>
     <p><code> Z is X*Y,</code></p>
     <p><code> assert( произв( X,Y,Z) ),</code></p>
     <p><code> fail.</code></p>
     <p>Вопрос</p>
     <p><code>?- таблица.</code></p>
     <p>потерпит, конечно, неудачу, однако в качестве своего побочного эффекта приведет к добавлению в базу данных целой таблицы произведений. После этого можно, например, спросить, какие пары дают произведения, равные 8:</p>
     <p><code>?- произв( А, В, 8).</code></p>
     <p><code>А = 1</code></p>
     <p><code>В = 8;</code></p>
     <empty-line/>
     <p><code>А = 2</code></p>
     <p><code>В = 4;</code></p>
     <empty-line/>
     <p><code>...</code></p>
     <p>Здесь следует сделать одно замечание, относящееся к стилю программирования. Приведенные примеры показали некоторые явно полезные применения <code>assert</code> и <code>retract</code>. Однако использование этих отношений требует особой внимательности. Не рекомендуется применять их слишком часто и без должной осторожности - это плохой стиль программирования. Ведь добавляя и удаляя предложения, мы фактически изменяем программу. Поэтому отношения, выполнявшиеся в некоторой ее точке, могут оказаться неверными в другой. В разные моменты времени ответы на одни и те же вопросы будут различными. Таким образом, большое количество обращений к <code>assert</code> и <code>retract</code> может затемнить смысл программы и станет трудно разобрать, что истинно, а что — нет. В результате поведение программы может стать непонятным, трудно объяснимым, и вряд ли можно будет ей доверять.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>7.6.</strong></p>
     <p> (а) Напишите вопрос к пролог-системе, который удаляет из базы данных всю таблицу <code>произв</code>.</p>
     <p> (b) Измените этот вопрос так, чтобы он удалил из таблицы только те строки, в которых произведение равно 0.</p>
     <p><strong>7.7.</strong> Определите отношение</p>
     <p><code>копия( Терм, Копия)</code></p>
     <p>которое порождает такую копию <code>Терм</code>'а <code>Копия</code>, в которой все переменные переименованы. Это легко сделать, используя <code>assert</code> и <code>retract</code>.</p>
    </section>
    <section>
     <title>
      <p>7.5. Средства управления</p>
     </title>
     <p>К настоящему моменту мы познакомились с большинством дополнительных средств управления, за исключением <code>repeat</code> (повторение). Здесь мы для полноты приводим список всех таких средств.</p>
     <p>• <emphasis>отсечение</emphasis>, записывается как '<code>!</code>', предотвращает перебор, введено в гл. 5.</p>
     <p>• <code>fail</code> — цель, которая всегда терпит неудачу.</p>
     <p>• <code>true</code> — цель, которая всегда успешна.</p>
     <p>• <code>not( P)</code> — вид отрицания, который всегда ведет себя в точном соответствии со следующим определением:</p>
     <p><code>not( P) :- P, !, fail; true.</code></p>
     <p>Некоторые проблемы, связанные с отсечением и <code>not</code> детально обсуждались в гл. 5.</p>
     <p>• <code>саll( P)</code> активизирует цель <code>P</code>. Обращение к <code>саll</code> имеет успех, если имеет успех P.</p>
     <p>• <code>repeat</code> — цель, которая всегда успешна. Ее особое свойство состоит в том, что она недетерминирована, поэтому всякий раз, как до нее доходит перебор, она порождает новую ветвь вычислений. Цель <code>repeat</code> ведет себя так, как если бы она была определена следующим образом:</p>
     <p><code>repeat.</code></p>
     <p><code>repeat :- repeat.</code></p>
     <p>Стандартный способ применения <code>repeat</code> показан в процедуре <code>квадраты</code>, которая читает последовательность чисел и выдает их квадраты. Последовательность чисел заканчивается атомом <code>стоп</code>, который служит для процедуры сигналом окончания работы.</p>
     <p><code>квадраты :-</code></p>
     <p><code> repeat,</code></p>
     <p><code> read( X),</code></p>
     <p><code> ( X = стоп, !;</code></p>
     <p><code>   Y is X*X, write( Y), fail ).</code></p>
    </section>
    <section>
     <title>
      <p>7.6. <emphasis>bagof</emphasis>, <emphasis>setof</emphasis> и <emphasis>findall</emphasis></p>
     </title>
     <p>При помощи механизма автоматического перебора можно получить одни за другим все объекты, удовлетворяющие некоторой цели. Всякий раз, как порождается новое решение, предыдущее пропадает и становится с этого момента недоступным. Однако у нас может возникнуть желание получить доступ ко всем порожденным объектам сразу, например собрав их в список. Встроенные предикаты <code>bagof</code> (набор) и <code>setof</code> (множество) обеспечивают такую возможность; вместо них иногда используют предикат <code>findall</code> (найти все).</p>
     <p>Цель</p>
     <p><code>bagof( X, P, L)</code></p>
     <p>порождает список L всех объектов X, удовлетворяющих цели P. Обычно <code>bagof</code> имеет смысл применять только тогда, когда X и P содержат общие переменные. Например, допустим, что мы включили в программу следующую группу предложений для разбиения букв (из некоторого множества) на два класса — гласные и согласные:</p>
     <p><code>класс( а, глас).</code></p>
     <p><code>класс( b, согл).</code></p>
     <p><code>класс( с, согл).</code></p>
     <p><code>класс( d, согл).</code></p>
     <p><code>класс( e, глас).</code></p>
     <p><code>класс( f, согл).</code></p>
     <p>Тогда мы можем получить список всех согласных, упомянутых в этих предложениях, при помощи цели:</p>
     <p><code>?- bagof( Буква, класс( Буква, согл), Буквы).</code></p>
     <p><code>Буквы = [d, c, d, f]</code></p>
     <p>Если же мы в указанной цели оставим класс букв неопределенным, то, используя автоматический перебор, получим два списка букв, каждый из которых соответствует одному из классов:</p>
     <p><code>?- bagof( Буква, класс( Буква, Класс), Буквы).</code></p>
     <empty-line/>
     <p><code>Класс = глас</code></p>
     <p><code>Буквы = [а,e]</code></p>
     <empty-line/>
     <p><code>Класс = согл</code></p>
     <p><code>Буквы = [b, c, d, f]</code></p>
     <p>Если <code>bagof( X, P, L)</code> не находит ни одного решения для <code>P</code>, то цель <code>bagof</code> просто терпит неуспех. Если один и тот же X найден многократно, то все его экземпляры будут занесены в <code>L</code>, что приведет к появлению в <code>L</code> повторяющихся элементов.</p>
     <p>Предикат <code>setof</code> работает аналогично предикату <code>bagof</code>. Цель</p>
     <p><code>setof( X, P, L)</code></p>
     <p>как и раньше, порождает список L объектов X, удовлетворяющих P. Только на этот раз список L будет упорядочен, а из всех повторяющихся элементов, если таковые есть, в него попадет только один. Упорядочение происходит по алфавиту или по отношению '<code>&lt;</code>', если элементы списка — числа. Если элементы списка — структуры, то они упорядочиваются по своим главным функторам. Если же главные функторы совпадают, то решение о порядке таких термов принимается по их первым несовпадающим функторам, расположенным выше и левее других (по дереву). На вид объектов, собираемых в список, ограничения нет. Поэтому можно, например, составить список пар вида</p>
     <p><code>Класс / Буква</code></p>
     <p>при этом гласные будут расположены в списке первыми ("глас" по алфавиту раньше "согл"):</p>
     <p><code>?- setof( Класс/Буква, класс( Буква, Класс), Спис).</code></p>
     <p><code>Спис = [глас/а, глас/e, согл/b, согл/с, согл/d, согл/f]</code></p>
     <p>Еще одним предикатом этого семейства, аналогичным <code>bagof</code>, является <code>findall</code>.</p>
     <p><code>findall( X, P, L)</code></p>
     <p>тоже порождает список объектов, удовлетворяющих P. Он отличается от <code>bagof</code> тем, что собирает в список <emphasis>все</emphasis> объекты X, не обращая внимание на (возможно) отличающиеся для них конкретизации тех переменных из P, которых нет в X. Это различие видно из следующего примера:</p>
     <p><code>?- findall( Буква, класс( Буква, Класс), Буквы).</code></p>
     <p><code>Буквы = [a, b, c, d, e, f]</code></p>
     <p>Если не существует ни одного объекта X, удовлетворяющего P, то <code>findall</code> все равно имеет успех и выдает <code>L = []</code>.</p>
     <p>Если в используемой реализации Пролога отсутствует встроенный предикат <code>findall</code>, то его легко запрограммировать следующим образом. Все решения для P порождаются искусственно вызываемыми возвратами. Каждое решение, как только оно получено, немедленно добавляется к базе данных, чтобы не потерять его после нахождения следующего решения. После того, как будут получены и сохранены все решения, их нужно собрать в список, а затем удалить из базы данных при помощи <code>retract</code>. Весь процесс можно представлять себе как построение очереди из порождаемых решений. Каждое вновь порождаемое решение добавляется в конец этой очереди при помощи <code>assert</code>. Когда все решения собраны, очередь расформировывается. Заметим также, что конец очереди надо пометить, например, атомом "дно" (который, конечно, должен отличаться от любого ожидаемого решения). Реализация <code>findall</code> в соответствии с описанным методом показана на рис. 7.4.</p>
     <empty-line/>
     <p><code>findall( X, Цель, ХСпис) :-</code></p>
     <p><code> саll( Цель),           % Найти решение</code></p>
     <p><code> assert( очередь( X) ), % Добавить егo</code></p>
     <p><code> fail;                  % Попытаться найти еще решения</code></p>
     <p><code> assertz( очередь( дно) ),</code></p>
     <p><code>  % Пометить конец решений</code></p>
     <p><code> собрать( ХСпис).       % Собрать решения в список</code></p>
     <empty-line/>
     <p><code>собрать( L) :-</code></p>
     <p><code> retract( очередь(X) ), !,</code></p>
     <p><code>  % Удалить следующее решение</code></p>
     <p><code> ( X == дно, !, L = [];</code></p>
     <p><code>  % Конец решений?</code></p>
     <p><code> L = [X | Остальные], собрать( Остальные) ).</code></p>
     <p><code>  % Иначе собрать остальные</code></p>
     <p><strong>Рис. 7.4.</strong> Реализация отношения findall.</p>
     <empty-line/>
     <subtitle>Упражнения</subtitle>
     <p><strong>7.8.</strong> Используя <code>bagof</code>, определите отношение</p>
     <p><code>множподмножеств( Мн, Подмн)</code></p>
     <p>для вычисления множества всех подмножеств данного множества (все множества представлены списками).</p>
     <p><strong>7.9.</strong> Используя <code>bagof</code>, определите отношение</p>
     <p><code>копия( Терм, Копия)</code></p>
     <p>чтобы <code>Копия</code> представляла собой <code>Терм</code>, в котором все переменные переименованы.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• В любой реализации Пролога обычно предусматривается набор встроенных процедур для выполнения различных полезных операций, несуществующих в чистом Прологе. В данной главе мы рассмотрели подобное множество предикатов, имеющееся во многих реализациях.</p>
     <p>• Тип терма можно установить при помощи следующих предикатов:</p>
     <p><code>var( X)     </code>X — (неконкретизированная) переменная</p>
     <p><code>nonvar( X)  </code>X — не переменная</p>
     <p><code>atom( X)    </code>X — атом</p>
     <p><code>integer( X) </code>X — целое</p>
     <p><code>atomic( X)  </code>X — или атом, или целое</p>
     <p>• Термы можно синтезировать или разбирать на части:</p>
     <p><code>Терм =.. [Функтор [ СписокАргументов]</code></p>
     <p><code>functor( Терм, Функтор, Арность)</code></p>
     <p><code>arg( N, Терм, Аргумент)</code></p>
     <p><code>name( атом, КодыСимволов)</code></p>
     <p>• Программу на Прологе можно рассматривать как реляционную базу данных, которую можно изменять при помощи следующих процедур:</p>
     <p><code>аssert( Предл)  </code>добавляет предложение <code>Предл</code> к программе</p>
     <p><code>аssеrtа( Предл) </code>добавляет в начало</p>
     <p><code>assertz( Предл) </code>добавляет в конец</p>
     <p><code>rеtrасt( Предл) </code>удаляет предложение, сопоставимое с предложением <code>Предл</code></p>
     <p>• Все объекты, отвечающие некоторому заданному условию, можно собрать в список при помощи предикатов:</p>
     <p><code>bagof( X, P, L)   </code>L — список всех X, удовлетворяющих условию P</p>
     <p><code>setof( X, P, L)   </code>L — отсортированный список всех X, удовлетворяющих условию P</p>
     <p><code>findall( X, P, L) </code>аналогичен <code>bagof</code></p>
     <p>• <code>repeat</code> — средство управления, позволяющее порождать неограниченное число альтернатив для автоматического перебора.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 8</p>
     <p>Стиль и методы программирования</p>
    </title>
    <section>
     <p>В этой главе мы рассмотрим некоторые общие принципы хорошего программирования и обсудим, в частности, следующие вопросы: "Как представлять себе прологовские программы? Из каких элементов складывается хороший стиль программирования на Прологе? Как отлаживать пролог-программы? Как повысить их эффективность?"</p>
    </section>
    <section>
     <title>
      <p>8.1. Общие принципы хорошего программирования</p>
     </title>
     <p>Главный вопрос, касающийся хорошего программирования, — это вопрос о том, что такое хорошая программа. Ответ на этот вопрос не тривиален, поскольку существуют разные критерии качества программ.</p>
     <p>Следующие критерии общеприняты:</p>
     <p>• <emphasis>Правильность</emphasis>. Хорошая программа в первую очередь должна быть правильной, т.е. она должна делать именно то, для чего предназначалась. Это требование может показаться тривиальным и самоочевидным. Однако в случае сложных программ правильность достигается не так часто. Распространенной ошибкой при написании программ является пренебрежение этим очевидным критерием, когда большее внимание уделяется другим критериям — таким, как эффективность.</p>
     <p>• <emphasis>Эффективность</emphasis>. Хорошая программа не должна попусту тратить компьютерное время и память.</p>
     <p>• <emphasis>Простота, читабельность</emphasis>. Хорошая, программа должна быть легка для чтения и понимания. Она не должна быть более сложной, чем это необходимо. Следует избегать хитроумных программистских трюков, затемняющих смысл программы. Общая организация программы и расположение ее текста должны облегчать ее понимание.</p>
     <p>• <emphasis>Удобство модификации</emphasis>. Хорошая программа должна быть легко модифицируема и расширяема. Простота и модульная организация программы облегчают внесение в нее изменений.</p>
     <p>• <emphasis>Живучесть</emphasis>. Хорошая программа должна быть живучей. Она не должна сразу "ломаться", если пользователь введет в нее неправильные или непредусмотренные данные. В случае подобных ошибок программа должна сохранять работоспособность и вести себя разумно (сообщать об ошибках).</p>
     <p>• <emphasis>Документированность</emphasis>. Хорошая программа должна быть хорошо документирована. Минимальная документация — листинг с достаточно подробными комментариями.</p>
     <p>Степень важности того или иного критерия зависит от конкретной задачи, от обстоятельств написания программы, а также от условий ее эксплуатации. Наивысшим приоритетом пользуется, без сомнения, правильность. Обычно простоте, удобству модификации, живучести и документированности придают во крайней мере не меньший приоритет, чем эффективности.</p>
     <p>Существует несколько общих соображений, помогающих реализовать вышеупомянутые критерии на практике. Одно важное правило состоит в том, чтобы сначала <emphasis>продумать</emphasis> задачу, подлежащую решению, и лишь затем приступать к написанию текста программы на конкретном языке программирования. Как только мы хорошо поймем задачу, и способ ее решения будет нами полностью и во всех деталях продуман, само программирование окажется быстрым и легким делом и появится неплохой шанс за короткое время получить правильную программу.</p>
     <p>Распространенной ошибкой является попытка начать писать программу даже до того, как была уяснена полная постановка задачи. Главная причина, по которой следует воздерживаться от преждевременного начала программирования, состоит в том, что обдумывание задачи и поиск метода ее решения должны проводиться в терминах, наиболее адекватных самой этой задаче. Эти термины чаще всего далеки от синтаксиса применяемого языка программирования и могут быть утверждениями на естественном языке и рисунками.</p>
     <p>Исходная формулировка способа решения задачи должна быть затем трансформирована в программу, но этот процесс трансформации может оказаться нелегким. Неплохим подходом к его осуществлению является применение принципа <emphasis>пошаговой детализации</emphasis>. Исходная формулировка рассматривается как "решение верхнего уровня", а окончательная программа - как "решение низшего уровня".</p>
     <p>В соответствии с принципом пошаговой детализации окончательная программа получается после серии трансформаций или "детализаций" решения. Мы начинаем с первого решения — решения верхнего уровня, а затем последовательно проходим по цепочке решений; все эти решения эквивалентны, но каждое следующее решение выражено более детально, чей предыдущее. На каждом шагу детализации понятия, использовавшиеся в предыдущих формулировках, прорабатываются более подробно, а их представление все более приближается к языку программирования. Следует отдавать себе отчет в том, что детализация касается не только процедур, но и структур данных. На начальных шагах работают обычно с более абстрактными, более крупными информационными единицами, детальная структура которых уточняется впоследствии.</p>
     <p>Стратегия нисходящей пошаговой детализации имеет следующие преимущества:</p>
     <p>• она позволяет сформулировать грубое решение в терминах, наиболее адекватных решаемой задаче;</p>
     <p>• в терминах таких мощных понятий решение будет сжатым и простым, а потому скорее всего правильным;</p>
     <p>• каждый шаг детализации должен быть достаточно малым, чтобы не представлять больших интеллектуальных трудностей, если это удалось — трансформация решения в новое, более детальное представление скорее всего будет выполнена правильно, а следовательно, таким же правильным окажется и полученное решение следующего шага детализации.</p>
     <p>В случае Пролога мы можем говорить о пошаговой детализации <emphasis>отношений</emphasis>. Если существо задачи требует мышления в алгоритмических терминах, то мы можем также говорить и о детализации <emphasis>алгоритмов</emphasis>, приняв процедурную точку зрения на Пролог.</p>
     <p>Для того, чтобы удачно сформулировать решение на некотором уровне детализации и придумать полезные понятия для следующего, более низкого уровня, нужны идеи. Поэтому программирование — это творческий процесс, что верно в особенности, когда речь идет о начинающих программистах. По мере накопления опыта работа программиста постепенно становится все менее искусством и все более ремеслом. И все же главным остается вопрос: как возникают идеи? Большинство идей приходит из опыта, из тех задач, решения которых уже известны. Если мы не знаем прямого решения задачи, то нам может помочь уже решенная задача, похожая на нашу. Другим источником идей является повседневная жизнь. Например, если необходимо запрограммировать сортировку списка, то можно догадаться, как это сделать, если задать себе вопрос: "А как бы я сам стал действовать, чтобы расположить экзаменационные листы студентов по их фамилиям в алфавитном порядке?"</p>
     <p>Общие принципы, изложенные в данном разделе, известны также как составные части "структурного программирования"; они, в основном, применимы и к программированию на Прологе. В следующих разделах мы обсудим их более детально, обращая особое внимание на применение этих принципов программирования к Прологу.</p>
    </section>
    <section>
     <title>
      <p>8.2. Как представлять себе программы на Прологе</p>
     </title>
     <section>
      <p>Одной из характерных особенностей Пролога является то, что в нем допускается как процедурный, так и декларативный стиль мышления при составлении программы. Эти два подхода детально обсуждались в гл. 2 и затем многократно иллюстрировались на примерах. Какой из этих подходов окажется более эффективным и практичным, зависит от конкретной задачи. Обычно построение декларативного решения задачи требует меньших усилий, но может привести к неэффективной программе. В процессе построения решения мы должны сводить задачу к одной или нескольким более легким подзадачам. Возникает важный вопрос: как находить эти подзадачи? Существует несколько общих принципов, которые часто применяются при программировании на Прологе. Они будут обсуждаться в следующих разделах.</p>
     </section>
     <section>
      <title>
       <p>8.2.1. Использование рекурсии</p>
      </title>
      <p>Этот принцип состоит в том, чтобы разбить задачу на случаи, относящиеся к двум группам:</p>
      <p>(1) тривиальные, или "граничные" случаи;</p>
      <p>(2) "общие" случаи, в которых решение получается из решений для (более простых) вариантов самой исходной задачи.</p>
      <p>Этот метод мы использовали в Прологе постоянно. Рассмотрим еще один пример: обработка списка элементов, при которой каждый элемент преобразуется по одному и тому же правилу. Пусть это будет процедура</p>
      <p><code>преобрспис( Спис, F, НовСпиc)</code></p>
      <p>где <code>Спис</code> — исходный список, <code>F</code> — правило преобразования (бинарное отношение), а <code>НовСпиc</code> — список всех преобразованных элементов. Задачу преобразования списка <code>Спис</code> можно разбить на два случая:</p>
      <p>(1) Граничный случай: <code>Спис = []</code></p>
      <p>Если <code>Спис = []</code>, то <code>НовСпиc = []</code>, независимо от <code>F</code></p>
      <p>(2) Общий случай: <code>Спис = [X | Хвост]</code></p>
      <p>Чтобы преобразовать список вида <code>[X | Хвост]</code>, необходимо:</p>
      <p>  преобразовать список <code>Хвост</code>; результат — <code>НовХвост</code>;</p>
      <p>  элемент <code>X</code> по правилу <code>F</code>; результат — <code>НовХ</code>;</p>
      <p>  результат преобразования всего списка — <code>[НовХ | НовХвост]</code>.</p>
      <p>Тот же алгоритм, изложенный на Прологе:</p>
      <p><code>преобрспис( [], _, []).</code></p>
      <p><code>преобрспис( [X | Хвост], F, [НовХ | НовХвост] :-</code></p>
      <p><code> G =.. [F, X, НовХ],</code></p>
      <p><code> саll( G),</code></p>
      <p><code> пpeoбpcпиc( Хвост, F, НовХвост).</code></p>
      <p>Одна из причин того, что рекурсия так естественна для определения отношений на Прологе, состоит в том, что объекты данных часто сами имеют рекурсивную структуру. К таким объектам относятся списки и деревья. Список либо пуст (граничный случай), либо имеет голову и хвост, который сам является списком (общий случай). Двоичное дерево либо пусто (граничный случай), либо у него есть корень и два поддерева, которые сами являются двоичными деревьями (общий случай). Поэтому для обработки всего непустого дерева необходимо сначала что-то сделать с его корнем, а затем обработать поддеревья.</p>
     </section>
     <section>
      <title>
       <p>8.2.2. Обобщение</p>
      </title>
      <p>Часто бывает полезно обобщить исходную задачу таким образом, чтобы полученная более общая задача допускала рекурсивную формулировку. Исходная задача решается, тогда как частный случай ее более общего варианта. Обобщение отношения обычно требует введения одного или более дополнительных аргументов. Главная проблема состоит в отыскании подходящего обобщения, что может потребовать более тщательного изучения задачи. В качестве примера рассмотрим еще раз задачу о восьми ферзях. Исходная задача состояла в следующем: разместить на доске восемь ферзей так, чтобы обеспечить отсутствие взаимных нападений. Соответствующее отношение назовем</p>
      <p><code>восемьферзей( Поз)</code></p>
      <p>Оно выполняется (истинно), если <code>Поз</code> — представленная тем или иным способом позиция, удовлетворяющая условию задачи. Можно предложить следующую полезную идею: обобщить задачу, перейдя от 8 ферзей к произвольному количеству — N. Количество ферзей станет дополнительным аргументом:</p>
      <p><code>n_ферзей( Поз, N)</code></p>
      <p>Преимущество такого обобщения состоит в том, что отношение <code>n_ферзей</code> допускает непосредственную рекурсивную формулировку:</p>
      <p>(1) Граничный случай: N = 0</p>
      <p>Разместить 0 ферзей — тривиальная задача.</p>
      <p>(2) Общий случай: N &gt; 0</p>
      <p>Для "безопасного" размещения N ферзей необходимо:</p>
      <p>• получить требуемое размещение для (N - 1) ферзей и</p>
      <p>• добавить оставшегося ферзя так, чтобы он не бил ни одного из уже поставленных ферзей.</p>
      <p>Как только мы научимся решать более общую задачу, решить исходную уже не составит труда:</p>
      <p><code>восемьферзей( Поз) :- n_ферзей( Поз, 8)</code></p>
     </section>
     <section>
      <title>
       <p>8.2.3. Использование рисунков</p>
      </title>
      <p>В поиске идей для решения задачи часто бывает полезным обратиться к ее графическому представлению. Рисунок может помочь выявить в задаче некоторые существенные отношения. После этого останется только описать на языке программирования то, что мы <emphasis>видим</emphasis> на рисунке.</p>
      <p>Использование графического представления при решении задач полезно всегда, однако похоже, что в Прологе оно работает особенно хорошо. Происходит это по следующим причинам:</p>
      <p>(1) Пролог особенно хорошо приспособлен для задач, в которых фигурируют объекты и отношения между ними. Часто такие задачи естественно иллюстрировать графами, в которых узлы соответствуют объектам, а дуги — отношениям.</p>
      <p>(2) Естественным наглядным изображением структурных объектов Пролога являются деревья.</p>
      <p>(3) Декларативный характер пролог-программ облегчает перевод графического представления на Пролог. В принципе, порядок описания "картинки" не играет роли, мы просто помещаем в программу то, что видим, в произвольном порядке. (Возможно, что из практических соображений этот порядок впоследствии придется подправить с целью повысить эффективность программы.) </p>
     </section>
    </section>
    <section>
     <title>
      <p>8.3. Стиль программирования</p>
     </title>
     <section>
      <p>Подчиняться при программировании некоторым стилистическим соглашениям нужно для того, чтобы</p>
      <p>• уменьшить опасность внесения ошибок в программы и</p>
      <p>• создавать программы, которые легко читать, понимать, отлаживать и модифицировать.</p>
      <p>Ниже дается обзор некоторых из составных частей хорошего стиля программирования на Прологе. Мы рассмотрим некоторые общие правила хорошего стиля, табличную организацию длинных процедур и вопросы комментирования программ.</p>
     </section>
     <section>
      <title>
       <p>8.3.1. Некоторые правила хорошего стиля</p>
      </title>
      <p>• Предложения программы должны быть короткими. Их тела, как правило, должны содержать только несколько целей.</p>
      <p>• Процедуры должны быть короткими, поскольку длинные процедуры трудны для понимания. Тем не менее длинные процедуры вполне допустимы в том случае, когда они имеют регулярную структуру (этот вопрос еще будет обсуждаться в данной главе).</p>
      <p>• Следует применять мнемонические имена процедур и переменных. Они должны отражать смысл отношений и роль объектов данных.</p>
      <p>• Существенное значение имеет расположение текста программы. Для улучшения читабельности программы нужно постоянно применять пробелы, пустые строки и отступы. Предложения, относящиеся к одной процедуре, следует размещать вместе в виде отдельной группы строк; между предложениями нужно вставлять пустую строку (этого не нужно делать, возможно, только в случае перечисления большого количества фактов, касающихся одного отношения); каждую цель можно размещать на отдельной строке. Пролог-программы иной раз напоминают стихи по эстетической привлекательности своих идей и формы.</p>
      <p>• Стилистические соглашения такого рода могут варьироваться от программы к программе, так как они зависят от задачи и от личного вкуса. Важно, однако, чтобы на протяжении одной программы постоянно применялись одни и те же соглашения.</p>
      <p>• Оператор отсечения следует применять с осторожностью. Если легко можно обойтись без него — не пользуйтесь им. Всегда, когда это возможно, предпочтение следует отдавать "зеленым отсечениям" перед "красными". Как говорилось в гл. 5, отсечение называется "зеленым", если его можно убрать, на затрагивая декларативный смысл предложения. Использование "красных отсечений" должно ограничиваться четко определенными конструкциями, такими как оператор <code>not</code> или конструкция выбора между альтернативами. Примером последней может служить</p>
      <p><emphasis>если</emphasis> <code>Условие</code> <emphasis>то</emphasis> <code>Цель1</code> <emphasis>иначе</emphasis> <code>Цель2</code></p>
      <p>С использованием отсечения эта конструкция переводится на Пролог так:</p>
      <p><code>Условие, !. % Условие выполнено?</code></p>
      <p><code>Цель1;      % Если да, то Цель1</code></p>
      <p><code>Цель2       % Иначе - Цель2</code></p>
      <p>• Из-за того, что оператор <code>not</code> связан с отсечением, он тоже может привести к неожиданностям. Поэтому, применяя его, следует всегда помнить точное прологовское определение этого оператора. Тем не менее, если приходится выбирать между <code>not</code> и отсечением, то лучше использовать <code>not</code>, чем какую-нибудь туманную конструкцию с отсечением.</p>
      <p>• Внесение изменений в программу при помощи <code>assert</code> и <code>retract</code> может сделать поведение программы значительно менее понятным. В частности, одна и та же программа на одни и те же вопросы будет отвечать по-разному в разные моменты времени. В таких случаях, если мы захотим повторно воспроизвести исходное поведение программы, нам придется предварительно убедиться в том, что ее исходное состояние, нарушенное при обращении к <code>assert</code> и <code>retract</code>, полностью восстановлено.</p>
      <p>• Применение точек с запятой может затемнять смысл предложений. Читабельность можно иногда улучшить, разбивая предложения, содержащие точки с запятой, на несколько новых предложений, однако за это, возможно, придется заплатить увеличенном длины программы и потерей в ее эффективности.</p>
      <p>Для иллюстрации некоторых положений данного раздела рассмотрим отношение</p>
      <p><code>слить( Спис1, Спис2, Спис3)</code></p>
      <p>где <code>Спис1</code> и <code>Спис2</code> — упорядоченные списки, а <code>Спис3</code> — результат их слияния (тоже упорядоченный). Например:</p>
      <p><code>слить( [2, 4, 7], [1, 3, 4, 8], [1, 2, 3, 4, 4, 7, 8] )</code></p>
      <p>Вот стилистически неудачная реализация этого отношения:</p>
      <p><code>слить( Спис1, Спис2, Спис3) :-</code></p>
      <p><code> Спис1 = [], !, Спис3 = Спис2;</code></p>
      <p><code>  % Первый список пуст</code></p>
      <p><code> Спис2 = [], !,  Спис3 = Спис1;</code></p>
      <p><code>  % Второй список пуст</code></p>
      <p><code> Спис1 = [X | Остальные],</code></p>
      <p><code> Спис2 = [Y | Остальные],</code></p>
      <p><code> ( X &lt; Y, !,</code></p>
      <p><code>   Z = X, % Z - голова Спис3</code></p>
      <p><code> слить( Остальные1, Спис2, Остальные3 );</code></p>
      <p><code> Z = Y,</code></p>
      <p><code> слить( Спис1, Остальные2, Остальные3 ) ),</code></p>
      <p><code> Спис3 = [Z | Остальные3].</code></p>
      <p>Вот более предпочтительный вариант, не использующий точек с запятой:</p>
      <p><code>слить( [], Спис, Спис).</code></p>
      <p><code>слить( Спис, [], Спис).</code></p>
      <p><code>слить( [X | Остальные1], [Y | Остальные2], [X | Остальные3] ) :-</code></p>
      <p><code> X &lt; Y, !,</code></p>
      <p><code> слить(Остальные1, [Y | Остальные2], Остальные3).</code></p>
      <p><code>слить( Спис1, [Y | Остальные2], [Y | Остальные3]): -</code></p>
      <p><code> слить( Спис1, Остальные2, Остальные3 ).</code></p>
     </section>
     <section>
      <title>
       <p>8.3.2. Табличная организация длинных процедур</p>
      </title>
      <p>Длинные процедуры допустимы, если они имеют регулярную структуру. Обычно эта структура представляет собой множество фактов, соответствующее определению какого-либо отношения в табличной форме. Преимущества такой организации длинной процедуры состоят в том, что:</p>
      <p>• Ее структуру легко понять.</p>
      <p>• Ее удобно совершенствовать: улучшать ее можно, просто добавляя новые факты.</p>
      <p>• Ее легко проверять и модифицировать (просто заменяя отдельные факты, независимо от остальных). </p>
     </section>
     <section>
      <title>
       <p>8.3.3. Комментирование</p>
      </title>
      <p>Программные комментарии должны объяснять в первую очередь, для чего программа предназначена и как ею пользоваться, и только затем — подробности используемого метода решения и другие программные детали. Главная цель комментариев — обеспечить пользователю возможность применять программу, понимать ее и, может быть, модифицировать. Комментарии должны содержать в наиболее краткой форме всю необходимую для этого информацию. Недостаточное комментирование — распространенная ошибка, однако, программу можно и перенасытить комментариями. Объяснения деталей, которые и так ясны из самого текста программы, являются ненужной перегрузкой.</p>
      <p>Длинные фрагменты комментариев следует располагать перед текстом, к которому они относятся, в то время как короткие комментарии должны быть вкраплены в сам текст. Информация, которую в самом общем случае следует включать в комментарии, должна схватывать следующие вопросы:</p>
      <p>• Что программа делает, как ею пользоваться (например, какую цель следует активизировать и каков вид ожидаемых результатов), примеры ее применения.</p>
      <p>• Какие предикаты относятся к верхнему уровню?</p>
      <p>• Как представлены основные понятия (объекты)?</p>
      <p>• Время выполнения и требования по объему памяти.</p>
      <p>• Каковы ограничения на программу?</p>
      <p>• Использует ли она какие-либо средства, связанные с конкретной операционной системой?</p>
      <p>• Каков смысл предикатов программы? Каковы их аргументы? Какие аргументы являются "входными" и какие — "выходными", если это известно? (В момент запуска предиката входные аргументы имеют полностью определенные значения, не содержащие не конкретизированных переменных.)</p>
      <p>• Алгоритмические и реализационные детали.</p>
     </section>
    </section>
    <section>
     <title>
      <p>8.4. Отладка</p>
     </title>
     <p>Когда программа не делает того, чего от нее ждут, главной проблемой становится отыскание ошибки (или ошибок). Всегда легче найти ошибку в какой-нибудь части программы (или в отдельном модуле), чем во всей программе. Поэтому следует придерживаться следующего хорошего принципа: проверять сначала более мелкие программные единицы и только после того, как вы убедились, что им можно доверять, начинать проверку большего модуля или всей программы.</p>
     <p>Отладка в Прологе облегчается двумя обстоятельствами: во-первых, Пролог — интерактивный язык, поэтому можно непосредственно обратиться к любой части программы, задав пролог-системе соответствующий вопрос; во-вторых, в реализациях Пролога обычно имеются специальные средства отладки. Следствием этих двух обстоятельств является то, что отладка программ на Прологе может производиться, вообще говоря, значительно эффективнее, чем в других языках программирования.</p>
     <p>Основным средством отладки является <emphasis>трассировка</emphasis> (tracing). "Трассировать цель" означает: предоставить пользователю информацию, относящуюся к достижению этой цели в процессе ее обработки пролог-системой. Эта информация включает:</p>
     <p>• Входную информацию — имя предиката и значении аргументов в момент активизации цели.</p>
     <p>• Выходную информацию — в случае успеха, значения аргументов, удовлетворяющих цели; в противном случае — сообщение о неуспехе.</p>
     <p>• Информацию о повторном входе, т.е. об активизации той же цели в результате автоматического возврата.</p>
     <p>В промежутке между входом и выходом можно получить трассировочную информацию для всех подцелей этой цели. Таким образом, мы можем следить за обработкой нашего вопроса на всем протяжении нисходящего пути от исходной цели к целям самого нижнего уровня, вплоть до отдельных фактов. Такая детальная трассировка может оказаться непрактичной из-за непомерно большого количества трассировочной информации. Поэтому пользователь может применить "селективную" трассировку. Существуют два механизма селекции: первый подавляет выдачу информации о целях, расположенных ниже некоторого уровня; второй трассирует не все предикаты, а только некоторые, указанные пользователем.</p>
     <p>Средства отладки приводятся в действие при помощи системно-зависимых встроенных предикатов. Обычно используется следующий стандартный набор таких предикатов:</p>
     <p><code>trace</code></p>
     <p>запускает полную трассировку всех целей, следующих за <code>trace</code>.</p>
     <p><code>notrace</code></p>
     <p>прекращает дальнейшее трассирование.</p>
     <p><code>spy( P) </code>(следи за P)</p>
     <p>устанавливает режим трассировки предиката P. Обращение к <code>spy</code> применяют, когда хотят получить информацию только об указанном предикате и избежать трассировочной информации от других целей (как выше, так и ниже уровня запуска P). "Следить" можно сразу за несколькими предикатами.</p>
     <p><code>nospy( P)</code></p>
     <p>прекращает "слежку" за P.</p>
     <p>Трассировка ниже определенной глубины может быть подавлена во время выполнения программы при помощи специальных команд. Существуют и другие команды отладки, такие как возврат к предыдущей точке процесса вычислений. После такого возврата можно, например, повторить вычисления с большей степенью детализации трассировки.</p>
    </section>
    <section>
     <title>
      <p>8.5. Эффективность</p>
     </title>
     <section>
      <p>Существует несколько аспектов эффективности программ, включая такие наиболее общие, как время выполнения и требования по объему памяти. Другим аспектом является время, необходимое программисту для разработки программы.</p>
      <p>Традиционная архитектура вычислительных машин не очень хорошо приспособлена для реализации прологовского способа выполнения программ, предусматривающего достижение целей из некоторого списка. Поэтому ограниченность ресурсов по времени и пространству сказывается в Прологе, пожалуй, в большей степени, чем в большинстве других языков программирования. Вызовет ли это трудности в практических приложениях, зависит от задачи. Фактор времени практически не имеет значения, если пролог-программа, которую запускают по несколько раз в день, занимает 1 секунду процессорного времени, а соответствующая программа на каком-либо другом языке, скажем на Фортране, — 0.1 секунды. Разница в эффективности становится существенной, если эти две программы требуют 50 и 5 минут соответственно.</p>
      <p>С другой стороны, во многих областях применения Пролога он может существенно сократить время разработки программ. Программы на Прологе, вообще говоря, легче писать, легче понимать и отлаживать, чем программы, написанные на традиционных языках. Задачи, тяготеющие к "царству Пролога", включают в себя обработку символьной, нечисловой информации, структурированных объектов данных и отношений между ними. Пролог успешно применяется, в частности. в таких областях, как символьное решение уравнений, планирование, базы данных, автоматическое решение задач, машинное макетирование, реализация языков программирования, дискретное и аналоговое моделирование, архитектурное проектирование, машинное обучение, понимание естественного языка, экспертные системы и другие задачи искусственного интеллекта. С другой стороны, применение Пролога в области вычислительной математики вряд ли можно считать естественным.</p>
      <p>Прогон <emphasis>откомпилированной</emphasis> программы обычно имеет большую эффективность, чем <emphasis>интерпретация</emphasis>. Поэтому, если пролог-система содержит как интерпретатор, так и компилятор, следует пользоваться компилятором, если время выполнения критично.</p>
      <p>Если программа страдает неэффективностью, то ее обычно можно кардинально улучшить, изменив сам алгоритм. Однако для того, чтобы это сделать, необходимо изучить процедурные аспекты программы. Простой способ сокращения времени выполнения состоит в нахождении более удачного порядка предложений в процедуре и целей — в телах процедур. Другой, относительно простой метод заключается в управлении действиями системы посредством отсечений.</p>
      <p>Полезные идеи, относящиеся к повышению эффективности, обычно возникают только при достижении более глубокого понимания задачи. Более эффективный алгоритм может, вообще говоря, привести к улучшениям двух видов:</p>
      <p>• Повышение эффективности поиска путем скорейшего отказа от ненужного перебора и от вычисления бесполезных вариантов.</p>
      <p>• Применение cтруктур данных, более приспособленных для представления объектов программы, с целью реализовать операции над ними более эффективно.</p>
      <p>Мы изучим оба вида улучшений на примерах. Кроме того, мы рассмотрим на примере еще один метод повышения эффективности. Этот метод основан на добавлении в базу данных тех промежуточных результатов, которые с большой вероятностью могут потребоваться для дальнейших вычислений. Вместо того, чтобы вычислять их снова, программа просто отыщет их в базе данных как уже известные факты.</p>
     </section>
     <section>
      <title>
       <p>8.5.1. Повышение эффективности решения задачи о восьми ферзях</p>
      </title>
      <p>В качестве простого примера повышения эффективности давайте вернемся к задаче о восьми ферзях (см. рис. 4.7). В этой программе Y-координаты ферзей перебираются последовательно — для каждого ферзя пробуются числа от 1 до 8. Этот процесс был запрограммирован в виде цели</p>
      <p><code>принадлежит( Y, [1, 2, 3, 4, 5, 6, 7, 8] )</code></p>
      <p>Процедура <code>принадлежит</code> работает так: вначале пробует Y = 1, затем Y = 2, Y = 3 и т.д. Поскольку ферзи расположены один за другим в смежных вертикалях доски, очевидно, что такой порядок перебора не является оптимальным. Дело в том, что ферзи, расположенные в смежных вертикалях будут бить друг друга, если они не будут разнесены по вертикали на расстояние, превышающее, по крайней мере одно поле. В соответствии с этим наблюдением можно попытаться повысить эффективность, просто изменив порядок рассмотрения координат-кандидатов. Например:</p>
      <p><code>принадлежит( Y, [1, 5, 2, 6, 3, 7, 4, 8] )</code></p>
      <p>Это маленькое изменение уменьшит время, необходимое для нахождения первого решения, в 3-4 раза.</p>
      <p>В следующем примере такая же простая идея, связанная с изменением порядка, превращает практически неприемлемую временную сложность в тривиальную.</p>
     </section>
     <section>
      <title>
       <p>8.5.2. Повышение эффективности программы раскраски карты</p>
      </title>
      <p>Задача раскраски карты состоит в приписывании каждой стране на заданной карте одного из четырех заданных цветов с таким расчетом, чтобы ни одна пара соседних стран не была окрашена в одинаковый цвет. Существует теорема, которая гарантирует, что это всегда возможно.</p>
      <p>Пусть карта задана отношением соседства</p>
      <p><code>соседи( Страна, Соседи)</code></p>
      <p>где <code>Соседи</code> — список стран, граничащих со страной <code>Страна</code>. При помощи этого отношения карта Европы с 20-ю странами будет представлена (в алфавитном порядке) так:</p>
      <p><code>соседи( австрия, [венгрия, запгермания, италия,</code></p>
      <p><code> лихтенштейн, чехословакия,</code></p>
      <p><code> швейцария, югославия]).</code></p>
      <p><code>соседи( албания, [греция, югославия]).</code></p>
      <p><code>соседи( андорра, [испания, франция]).</code></p>
      <p><code>...</code></p>
      <p>Решение представим в виде списка пар вида</p>
      <p><code>Страна / Цвет</code></p>
      <p>которые устанавливают цвет для каждой страны на данной карте. Для каждой карты названия стран всегда известны заранее, так что задача состоит в нахождении цветов. Таким образом, для Европы задача сводится к отысканию подходящей конкретизации переменных C1, C2, СЗ и т.д. в списке</p>
      <p><code>[австрия/C1, албания/C2, андорра/С3, ...]</code></p>
      <p>Теперь определим предикат</p>
      <p><code>цвета( СписЦветСтран)</code></p>
      <p>который истинен, если <code>СписЦветСтран</code> удовлетворяет тем ограничениям, которые наложены на раскраску отношением <code>соседи</code>. Пусть четырьмя цветами будут желтый, синий, красный и зеленый. Условие запрета раскраски соседних стран в одинаковый цвет можно сформулировать на Прологе так:</p>
      <p><code>цвета( []).</code></p>
      <p><code>цвета( [Страна/Цвет | Остальные] ) :-</code></p>
      <p><code> цвета( Остальные),</code></p>
      <p><code> принадлежит( Цвет, [желтый, синий, красный, зеленый]),</code></p>
      <p><code> not( принадлежит( Страна1/Цвет, Остальные),</code></p>
      <p><code> сосед( Страна, Страна1) ).</code></p>
      <empty-line/>
      <p><code>сосед( Страна, Страна1) :-</code></p>
      <p><code> соседи( Страна, Соседи),</code></p>
      <p><code> принадлежит( Страна1, Соседи).</code></p>
      <p>Здесь <code>принадлежит( X, L)</code> — как всегда, отношение принадлежности к списку. Для простых карт с небольшим числом стран такая программа будет работать. Что же касается Европы, то здесь результат проблематичен. Если считать, что мы располагаем встроенным предикатом <code>setof</code>, то можно попытаться раскрасить карту Европы следующим образом. Определим сначала вспомогательное отношение:</p>
      <p><code>страна( С) :- соседи( С, _ ).</code></p>
      <p>Тогда вопрос для раскраски карты Европы можно сформулировать так:</p>
      <p><code>?- sеtоf( Стр/Цвет, страна( Стр), СписЦветСтран),</code></p>
      <p><code> цвета( СписЦветСтран).</code></p>
      <p>Цель <code>setof</code> — построить "шаблон" списка <code>СписЦветСтран</code>, в котором в элементах вида страна/ цвет вместо цветов будут стоять неконкретизированные переменные. Предполагается, что после этого цель <code>цвета</code> конкретизирует их. Такая попытка скорее всего потерпит неудачу вследствие неэффективности работы программы.</p>
      <p>Тщательное исследование способа, при помощи которого пролог-система пытается достичь цели <code>цвета</code>, обнаруживает источник неэффективности. Страны расположены в списке в алфавитном порядке, а он не имеет никакого отношения к их географическим связям. Порядок, в котором странам приписываются цвета, соответствует порядку их расположения в списке (с конца к началу), что в нашем случае никак не связано с отношением <code>соседи</code>. Поэтому процесс раскраски начинается в одном конце карты, продолжается в другой и т.д., перемещаясь по ней более или менее случайно. Это легко может привести к ситуации, когда при попытке раскрасить очередную страну окажется, что она окружена странами, уже раскрашенными во все четыре доступных цвета. Подобные ситуации приводят к возвратам, снижающим эффективность.</p>
      <p>Ясно поэтому, что эффективность зависит от порядка раскраски стран. Интуиция подсказывает простую стратегию раскраски, которая должна быть лучше, чем случайная: начать со страны, имеющей иного соседей, затем перейти к ее соседям, затем — к соседям соседей и т.д. В случае Европы хорошим кандидатом для начальной страны является Западная Германия (как имеющая наибольшее количество соседей — 9). Понятно, что при построении шаблона списка элементов вида страна/цвет Западную Германию следует поместить в конец этого списка, а остальные страны - добавлять со стороны его начала. Таким образом, алгоритм раскраски, который начинает работу с конца списка, в начале займется Западной Германией и продолжит работу, переходя от соседа к соседу.</p>
      <p>Новый способ упорядочивания списка стран резко повышает эффективность по отношению к исходному, алфавитному порядку, и теперь возможные раскраски карты Европы будут получены без труда.</p>
      <p>Можно было бы построить такой правильно упорядоченный список стран вручную, но в этом нет необходимости. Эту работу выполнит процедура <code>создспис</code>. Она начинает построение с некоторой указанной страны (в нашем случае — с Западной Германии) и собирает затем остальные страны в список под названием <code>Закрытый</code>. Каждая страна сначала попадает в другой список, названный <code>Открытый</code>, а потом переносится в <code>Закрытый</code>. Всякий раз, когда страна переносится из <code>Открытый</code> в <code>Закрытый</code>, ее соседи добавляются в <code>Открытый</code>.</p>
      <p><code>создспис( Спис) :-</code></p>
      <p><code> собрать( [запгермания], [], Спис ).</code></p>
      <empty-line/>
      <p><code>собрать( [], Закрытый, Закрытый).</code></p>
      <p><code>  % Кандидатов в Закрытый больше нет</code></p>
      <p><code>собрать( [X | Открытый], Закрытый, Спис) :-</code></p>
      <p><code> принадлежит( X | Закрытый), !,</code></p>
      <p><code>  % X уже собран ?</code></p>
      <p><code> собрaть( Открытый, Закрытый, Спис).</code></p>
      <p><code>  % Отказаться от X</code></p>
      <p><code>собрать( [X | Открытый], Закрытый, Спис) :-</code></p>
      <p><code> соседи( X, Соседи),</code></p>
      <p><code>  % Найти соседей X</code></p>
      <p><code> конк( Соседи, Открытый, Открытый1),</code></p>
      <p><code>  % Поместить их в Открытый</code></p>
      <p><code> собрать( Открытый1, [X | Закрытый], Спис).</code></p>
      <p><code>  % Собрать остальные</code></p>
      <p>Отношение <code>конк</code> — как всегда — отношение конкатенации списков.</p>
     </section>
     <section>
      <title>
       <p>8.5.3. Повышение эффективности конкатенации списков за счет совершенствования структуры данных</p>
      </title>
      <p>До сих пор в наших программах конкатенация была определена так:</p>
      <p><code>конк( [], L, L).</code></p>
      <p><code>конк( [X | L1], L2, [X | L3] ) :-</code></p>
      <p><code> конк( L1, L2, L3 ).</code></p>
      <p>Эта процедура неэффективна, если первый список — длинный. Следующий пример объясняет, почему это так:</p>
      <p><code>?- конк( [а, b, с], [d, e], L).</code></p>
      <p>Этот вопрос порождает следующую последовательность целей:</p>
      <p><code>конк( [а, b, с], [d, e], L)</code></p>
      <p><code> конк( [b, с], [d, e], L') </code>где <code>L = [a | L']</code></p>
      <p><code>  конк( [с], [d, e], L'')   </code>где <code>L' = [b | L''']</code></p>
      <p><code>   конк( [], [d, e], L''')   </code>где <code>L'' = [c | L''']</code></p>
      <p><code>    true  </code>(истина) где <code>L''' = [d, e]</code></p>
      <p>Ясно, что программа фактически сканирует весь первый список, пока не обнаружит его конец.</p>
      <p>А нельзя ли было бы проскочить весь первый список за один шаг и сразу подсоединить к нему второй список, вместо того, чтобы постепенно продвигаться вдоль него? Но для этого необходимо знать, где расположен конец списка, а следовательно, мы нуждаемся в другом его представлении. Один из вариантов — представлять список парой списков. Например, список</p>
      <p><code>[а, b, с]</code></p>
      <p>можно представить следующими двумя списками:</p>
      <p><code>L1 = [a, b, c, d, e]</code></p>
      <p><code>L2 = [d, e]</code></p>
      <p>Подобная пара списков, записанная для краткости как <code>L1-L2</code>, представляет собой "разность" между L1 и L2. Это представление работает только при том условии, что L2 — "конечный участок" списка L1. Заметим, что один и тот же список может быть представлен несколькими "разностными парами". Поэтому список <code>[а, b, с]</code> можно представить как</p>
      <p><code>[а, b, с]-[]</code></p>
      <p>или</p>
      <p><code>[a, b, c, d, e]-[d, e]</code></p>
      <p>или</p>
      <p><code>[a, b, c, d, e | T]-[d, e | T]</code></p>
      <p>или</p>
      <p><code>[а, b, с | T]-T</code></p>
      <p>где T — произвольный список, и т.п. Пустой список представляется любой парой <code>L-L</code>.</p>
      <p>Поскольку второй член пары указывает на конец списка, этот конец доступен сразу. Это можно использовать для эффективной реализации конкатенации. Метод показан на рис. 8.1. Соответствующее отношение конкатенации записывается на Прологе в виде факта</p>
      <p><code>конкат( A1-Z1, Z1-Z2, A1-Z2).</code></p>
      <p>Давайте используем <code>конкат</code> для конкатенации двух списков: списка <code>[а, b, с]</code>, представленного парой <code>[а, b, с | Т1]-Т1</code>, и списка <code>[d, e]</code>, представленного парой <code>[d, e | Т2]-Т2</code>:</p>
      <p><code>?- конкат( [а, b, с | Т1]-T1, [d, e | Т2]-Т2, L ).</code></p>
      <p>Оказывается, что для выполнения конкатенации достаточно простого сопоставления этой цели с предложением <code>конкат</code>. Результат сопоставления:</p>
      <p><code>T1 = [d, e | Т2]</code></p>
      <p><code>L = [a, b, c, d, e | T2]-T2</code></p>
      <image l:href="#_48.png"/>
      <p><strong>Рис. 8.1.</strong> Конкатенация списков, представленных в виде разностных пар. <code>L1</code> представляется как <code>A1-Z1</code>, <code>L2</code> как <code>A2-Z2</code> и результат <code>L3</code> — как <code>A1-Z2</code>. При этом должно выполняться равенство <code>Z1 = А2</code>.</p>
     </section>
     <section>
      <title>
       <p>8.5.4. Повышение эффективности зa счет добавления вычисленных фактов к базе данных</p>
      </title>
      <p>Иногда в процессе вычислений приходится одну и ту же цель достигать снова и снова. Поскольку в Прологе отсутствует специальный механизм выявления этой ситуации, соответствующая цепочка вычислений каждый раз повторяется заново.</p>
      <p>В качестве примера рассмотрим программу вычисления N-го числа Фибоначчи для некоторого заданного N. Последовательность Фибоначчи имеет вид:</p>
      <p>1, 1, 2, 3, 5, 8, 13, …</p>
      <p>Каждый член последовательности, за исключением первых двух, представляет собой сумму предыдущих двух членов. Для вычисления N-гo числа Фибоначчи F определим предикат</p>
      <p><code>фиб( N, F)</code></p>
      <p>Нумерацию чисел последовательности начнем с N = 1. Программа для <code>фиб</code> обрабатывает сначала первые два числа Фибоначчи как два особых случая, а затем определяет общее правило построения последовательности Фибоначчи:</p>
      <p><code>фиб( 1, 1).    % 1-e число Фибоначчи</code></p>
      <p><code>фиб( 2, 1).    % 2-e число Фибоначчи</code></p>
      <p><code>фиб( N, F) :-  % N-e число Фиб., N &gt; 2</code></p>
      <p><code> N &gt; 2,</code></p>
      <p><code> N1 is N - 1, фиб( N1, F1),</code></p>
      <p><code> N2 is N - 2, фиб( N2, F2),</code></p>
      <p><code> F is F1 + F2. % N-e число есть сумма двух</code></p>
      <p><code>               % предыдущих</code></p>
      <p>Процедура <code>фиб</code> имеет тенденцию к повторению вычислений. Это легко увидеть, если трассировать цель</p>
      <p><code>?- фиб( 6, F).</code></p>
      <p>На рис. 8.2 показано, как протекает этот вычислительный процесс. Например, третье число Фибоначчи <code>f( 3)</code> понадобилось в трех местах, и были повторены три раза одни и те же вычисления.</p>
      <p>Этого легко избежать, если запоминать каждое вновь вычисленное число. Идея состоит в применении встроенной процедуры <code>assert</code> для добавления этих (промежуточных) результатов в базу данных в виде фактов. Эти факты должны предшествовать другим предложениям, чтобы предотвратить применение общего правила в случаях, для которых результат уже известен. Усовершенствованная процедура <code>фиб2</code> отличается от <code>фиб</code> только этим добавлением:</p>
      <p><code>фиб2( 1, 1).            % 1-e число Фибоначчи</code></p>
      <p><code>фиб2( 2, 1).            % 2-e число Фибоначчи</code></p>
      <p><code>фиб2( N, F) :-          % N-e число Фиб., N &gt; 2</code></p>
      <p><code> N &gt; 2,</code></p>
      <p><code> N1 is N - 1, фиб2( N1, F1),</code></p>
      <p><code> N2 is N - 2, фиб2( N2, F2),</code></p>
      <p><code> F is F1 + F2,           % N-e число есть сумма</code></p>
      <p><code>                         % двух предыдущих</code></p>
      <p><code> asserta( фиб2( N, F) ). % Запоминание N-го числа</code></p>
      <p>Эта программа, при попытке достичь какую-либо цель, будет смотреть сперва на накопленные об этом отношении факты и только после этого применять общее правило. В результате, после вычисления цели <code>фиб2( N, F)</code>, все числа Фибоначчи вплоть до N-го будут сохранены. На рис. 8.3 показан процесс вычислении 6-го числа при помощи <code>фиб2</code>. Сравнение этого рисунка с рис. 8.2. показывает, на сколько уменьшилась вычислительная сложность. Для больших N такое уменьшение еще более ощутимо.</p>
      <p>Запоминание промежуточных результатов — стандартный метод, позволяющий избегать повторных вычислений. Следует, однако, заметить, что в случае чисел Фибоначчи повторных вычислений можно избежать еще и применением другого алгоритма, а не только запоминанием промежуточных результатов.</p>
      <image l:href="#_49.png"/>
      <p><strong>Рис. 8.2.</strong>  Вычисление 6-го числа Фибоначчи процедурой <code>фиб</code>.</p>
      <image l:href="#_50.png"/>
      <p><strong>Рис. 8.3.</strong> Вычисление 6-го числа Фибоначчи при помощи процедуры <code>фиб2</code>, которая запоминает предыдущие результаты. По сравнению с процедурой <code>фиб</code> здесь вычислений меньше (см. рис. 8.2).</p>
      <p>Этот новый алгоритм позволяет создать программу более трудную для понимания, зато более эффективную. Идея состоит на этот раз не в том, чтобы определить N-e число Фибоначчи просто как сумму своих предшественников по последовательности, оставляя рекурсивным вызовам организовать вычисления "сверху вниз" вплоть до самых первых двух чисел. Вместо этого можно работать "снизу вверх": начать с первых двух чисел и продвигаться вперед, вычисляя члены последовательности один за другим. Остановиться нужно в тот момент, когда будет достигнуто N-e число. Большая часть работы в такой программе выполняется процедурой</p>
      <p><code>фибвперед( М, N, F1, F2, F)</code></p>
      <p>Здесь F1 и F2 — (М – 1)-e и М-e числа, а F — N-e число Фибоначчи. Рис. 8.4 помогает понять отношение <code>фибвперед</code>. В соответствии с этим рисунком <code>фибвперед</code> находит последовательность преобразований для достижения конечной конфигурации (в которой М = N) из некоторой заданной начальной конфигурации. При запуске <code>фибвперед</code> все его аргументы, кроме F, должны быть конкретизированы, а М должно быть меньше или равно N. Вот эта программа:</p>
      <p><code>фиб3( N, F) :-</code></p>
      <p><code> фибвперед( 2, N, 1, 1, F).</code></p>
      <p><code>  % Первые два числа Фиб. равны 1</code></p>
      <empty-line/>
      <p><code>фибвперед( М, N, F1, F2, F2) :-</code></p>
      <p><code> М &gt;= N. % N-e число достигнуто</code></p>
      <p><code>фибвперед( M, N, F1, F2, F) :-</code></p>
      <p><code> M &lt; N,  % N-e число еще не достигнуто</code></p>
      <p><code> СледМ is М + 1,</code></p>
      <p><code> СледF2 is F1 + F2,</code></p>
      <p><code> фибвперед( СледМ, N, F2, СледF2, F).</code></p>
      <image l:href="#_51.png"/>
      <p><strong>Рис. 8.4.</strong> Отношения в последовательности Фибоначчи. "Конфигурация" изображается здесь в виде большого круга и определяется тремя параметрами: индексом М и двумя последовательными числами f( M-1) и f( М).</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>8.1.</strong> Все показанные ниже процедуры <code>подсп1</code>, <code>подсп2</code> и <code>подсп3</code> реализуют отношение взятия подсписка. Отношение <code>подсп1</code> имеет в значительной мере процедурное определение, тогда как <code>подсп2</code> и <code>подсп3</code> написаны в декларативном стиле. Изучите поведение этих процедур на примерах нескольких списков, обращая внимание на эффективность работы. Две из них ведут себя одинаково и имеют одинаковую эффективность. Какие? Почему оставшаяся процедура менее эффективна?</p>
      <p><code>подсп1( Спис, Подспис) :-</code></p>
      <p><code> начало( Спис, Подспис).</code></p>
      <p><code>подсп1( [ _ | Хвост], Подспис) :-</code></p>
      <p><code>  % Подспис - подсписок хвоста</code></p>
      <p><code> подсп1( Хвост, Подспис).</code></p>
      <empty-line/>
      <p><code>начало( _, []).</code></p>
      <p><code>начало( [X | Спис1], [X | Спис2] ) :-</code></p>
      <p><code> начало( Спис1, Спис2).</code></p>
      <empty-line/>
      <p><code>подсп2( Спис, Подспис) :-</code></p>
      <p><code> конк( Спис1, Спис2, Спис),</code></p>
      <p><code> конк( Спис3, Подспис, Cпис1).</code></p>
      <empty-line/>
      <p><code>подсп3( Спис, Подспис) :-</code></p>
      <p><code> конк( Спис1, Спис2, Спис),</code></p>
      <p><code> конк( Подспис, _, Спис2).</code></p>
      <p><strong>8.2.</strong> Определите отношение</p>
      <p><code>добавить_в_конец( Список, Элемент, НовыйСписок)</code></p>
      <p>добавляющее <code>Элемент</code> в конец списка <code>Список</code>; результат — <code>НовыйСписок</code>. Оба списка представляйте разностными парами.</p>
      <p><strong>8.3.</strong> Определите отношение</p>
      <p><code>обратить( Список, ОбращенныйСписок)</code></p>
      <p>где оба списка представлены разностными парами.</p>
      <p><strong>8.4.</strong> Перепишите процедуру <code>собрать</code> из разд. 8.5.2, используя разностное представление списков, чтобы конкатенация выполнялась эффективнее.</p>
     </section>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Для оценки качества программы существует несколько критериев: </p>
     <p>  правильность</p>
     <p>  эффективность</p>
     <p>  простота, читабельность</p>
     <p>  удобство модификации</p>
     <p>  документированность</p>
     <p>• Принцип <emphasis>пошаговой детализации</emphasis> — хороший способ организации процесса разработки программ. Пошаговая детализация применима к отношениям, алгоритмам и структурам данных.</p>
     <p>• Следующие методы часто помогают находить идеи для совершенствования программ на Прологе:</p>
     <p>  <emphasis>Применение рекурсии</emphasis>: выявить граничные и общие случаи рекурсивного определения.</p>
     <p>  <emphasis>Обобщение</emphasis>: рассмотреть такую более общую задачу, которую проще решить, чем исходную.</p>
     <p>  <emphasis>Использование рисунков</emphasis>: графическое представление помогает в выявлении важных отношений.</p>
     <p>• Полезно следовать некоторым стилистическим соглашениям для уменьшения опасности внесения ошибок в программы и создания программ, легких для чтения, отладки и модификации.</p>
     <p>• В пролог-системах обычно имеются средства отладки. Наиболее полезными являются средства трассировки программ.</p>
     <p>• Существует много способов повышения эффективности программы. Наиболее простые способы включают в себя:</p>
     <p>  изменение порядка целей и предложений</p>
     <p>  управляемый перебор при помощи введения отсечений</p>
     <p>  запоминание (с помощью <code>assert</code>) решений, которые иначе пришлось бы перевычислять</p>
     <p>Более тонкие и радикальные методы связаны с улучшением алгоритмов (особенно, в части повышения эффективности перебора) и с совершенствованием структур данных. </p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Часть 2</p>
    <p>Пролог в искусственном интеллекте</p>
   </title>
   <image l:href="#_52.png"/>
   <section>
    <title>
     <p>Глава 9</p>
     <p>Операции над структурами данных</p>
    </title>
    <section>
     <p>Один из фундаментальных вопросов программирования — это вопрос о представлении сложных объектов (таких как, например, множества), а также вопрос об эффективной реализации операций над подобными объектами. В этой главе мы рассмотрим несколько часто используемых структур данных, принадлежащих к трем большим семействам: спискам, деревьям и графам. Мы изучим способы представления этих структур на Прологе и составим программы, реализующие некоторые операции над ними, в том числе, сортировку списков, работу с множествами как древовидными структурами, запись элементов данных в дерево, поиск данных в дереве, нахождение пути в графе и т.п. Мы подробно разберем несколько примеров, чрезвычайно поучительных с точки зрения программирования на Прологе.</p>
    </section>
    <section>
     <title>
      <p>9.1. Представление списков. Сортировка</p>
     </title>
     <section>
      <title>
       <p>9.1.1. Замечания в некоторых альтернативных способах представления списков</p>
      </title>
      <p>В главе 3 была введена специальная система обозначений для списков (специальная прологовская нотация), которую мы и использовали в последующем изложении. Разумеется, это был всего лишь один из способов представления списков на Прологе. <emphasis>Список</emphasis> — это, в самом общем смысле, структура, которая либо</p>
      <p>• <emphasis>пуста</emphasis>, либо</p>
      <p>• состоит из <emphasis>головы</emphasis> и <emphasis>хвоста</emphasis>, причем хвост должен быть сам списком.</p>
      <p>Поэтому для представления этой структуры нам необходимо иметь всего лишь два языковых средства: специальный символ, обозначающий пустой список, и функтор для соединения головы с хвостом. Мы могли бы, например, выбрать</p>
      <p><code>ничего_не_делать</code></p>
      <p>в качестве символа, обозначающего пустой список, и атом</p>
      <p><code>затем</code></p>
      <p>в качестве инфиксного оператора для построения списка по заданным голове и хвосту. Этот оператор мы можем объявить в программе, например, так:</p>
      <p><code>:- op( 500, xfy, затем).</code></p>
      <p>Список</p>
      <p><code>[ войти, сесть, поужинать]</code></p>
      <p>можно было бы тогда записать как</p>
      <p><code>войти затем сесть затем поужинать</code></p>
      <p><code> затем ничего_не_делать</code></p>
      <p>Важно заметить, что на соответствующем уровне абстракции специальная прологовская нотация и всевозможные альтернативные способы обозначения списков сводятся, фактически, к одному и тому же представлению. В связи с этим типовые операции над списками, такие как</p>
      <p><code>принадлежит ( X, L)</code></p>
      <p><code>конк( L1, L2, L3)</code></p>
      <p><code>удалить( X, L1, L2)</code></p>
      <p>запрограммированные нами в специальной прологовской нотации, легко поддаются перепрограммированию в различные системы обозначений, выбранные пользователем. Например, отношение <code>конк</code> транслируется на язык "затем — ничего_не_делать" следующим образом. Определение, которое мы использовали до сих пор, имеет вид</p>
      <p><code>конк( [], L, L).</code></p>
      <p><code>конк( [X | L1], L2, [X | L3] ) :-</code></p>
      <p><code> конк( L1, L2, L3).</code></p>
      <p>В новой системе обозначений оно превращается в</p>
      <p><code>конк( ничего_не_делать, L, L).</code></p>
      <p><code>конк( X затем L1, L2, X затем L3) :-</code></p>
      <p><code> конк(L1, L2, L3).</code></p>
      <p>Этот пример показывает, как легко наши определения отношений над списками обобщаются на весь класс структур этого типа. Решение о том, какой именно способ записи списков будет использоваться в той или иной программе, следует принимать в соответствии с тем смыслом, который мы придаем списку в каждом конкретном случае. Если, например, список — это просто множество элементов, то наиболее удобна обычная прологовская нотация, поскольку в ней непосредственно выражается то, что программист имел в виду. С другой стороны, некоторые типы выражений также можно трактовать как своего рода списки. Например, для конъюнктов в исчислении высказываний подошло бы следующее спископодобное представление:</p>
      <p>• <code>истина</code> соответствует пустому списку,</p>
      <p>• <code>&amp;</code> — оператор для соединения головы с хвостом, определяемый, например, как</p>
      <p><code>:- op( 300, xfy, &amp;)</code></p>
      <p>Конъюнкция членов а, b, и с выглядела бы тогда как</p>
      <p><code>а &amp; b &amp; с &amp; истина</code></p>
      <p>Все приведенные примеры базируются, по существу, на одной и той же структуре, представляющей список. Однако в гл. 8 мы рассмотрели существенно другой способ, влияющий на эффективность вычислений. Уловка состояла в том, что список представлялся в виде пары списков, являясь их "разностью". Было показано, что такое представление приводит к очень эффективной реализации отношения конкатенации.</p>
      <p>Материал настоящего раздела проливает свет и на то различие, которое существует между применением операторов в математике и применением их в Прологе. В математике с каждым оператором всегда связано некоторое действие, в то время как в Прологе операторы используются просто для представления структур.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>9.1.</strong> Определите отношение</p>
      <p><code>список( Объект)</code></p>
      <p>для распознавания случаев, когда <code>Объект</code> является стандартным прологовским списком.</p>
      <p><strong>9.2.</strong> Определите отношение принадлежности к списку, используя систему обозначений, введенную в этой разделе: "затем — ничего_не_делать".</p>
      <p><strong>9.3.</strong> Определите отношение</p>
      <p><code>преобр( СтандСпис, Спис)</code></p>
      <p>для преобразования списков из стандартного представления в систему "затем — ничего_не_делать". Например:</p>
      <p><code>преобр( [а, b], а затем b затем ничего_не_делать)</code></p>
      <p>ответ</p>
      <p><strong>9.4.</strong> Обобщите отношение <code>преобр</code> на случай произвольного альтернативного представления списков. Конкретное представление задается символом, обозначающим пустой список, и функтором для соединения головы с хвостом. В отношении <code>преобр</code> придется добавить два новых аргумента:</p>
      <p><code>преобр( СтандСпис, Спис, Функтор, ПустСпис)</code></p>
      <p>Примеры применения этого отношения:</p>
      <p><code>?- пpeoбp( [а, b], L, затем, ничего_не_делать).</code></p>
      <p><code>L = а затем b затем ничего_не_делать</code></p>
      <empty-line/>
      <p><code>?-  преобр( [а, b, с], L, +, 0).</code></p>
      <p><code>L = а+(b+(с+0) )</code></p>
     </section>
     <section>
      <title>
       <p>9.1.2. Сортировка списков</p>
      </title>
      <p>Сортировка применяется очень часто. Список можно отсортировать (упорядочить), если между его элементами определено отношение порядка. Для удобства изложения мы будем использовать отношение порядка</p>
      <p><code>больше( X, Y)</code></p>
      <p>означающее, что X <emphasis>больше, чем</emphasis> Y, независимо от того, что мы в действительности понимаем под "больше, чем". Если элементами списка являются числа, то отношение <code>больше</code> будет, вероятно, определено как</p>
      <p><code>больше( X, Y) :- X &gt; Y.</code></p>
      <p>Если же элементы списка — атомы, то отношение <code>больше</code> может соответствовать алфавитному порядку между ними.</p>
      <p>Пусть</p>
      <p><code>сорт( Спис, УпорСпис)</code></p>
      <p>обозначает отношение, в котором <code>Спис</code> — некоторый список, а <code>УпорСпис</code> — это список, составленный из тех же элементов, но упорядоченный по возрастанию в соответствия с отношением <code>больше</code>. Мы построим три определения этого отношения на Прологе, основанные на трех различных идеях о механизме сортировки. Вот первая идея:</p>
      <cite>
       <p>Для того, чтобы упорядочить список <code>Спис</code>, необходимо:</p>
       <p>• Найти в <code>Спис</code> два смежных элемента X и Y, таких, что <code>больше( X, Y)</code>, и поменять X и Y местами, получив тем самым новый список <code>Спис1</code>; затем отсортировать <code>Спис1</code>.</p>
       <p>• Если в <code>Спис</code> нет ни одной пары смежных элементов X и Y, таких, что <code>больше( X, Y)</code>, то считать, что <code>Спис</code> уже отсортирован.</p>
      </cite>
      <p>Мы переставили местами 2 элемента X и Y, расположенные в списке "не в том порядке", с целью приблизить список к своему упорядоченному состоянию. Имеется в виду, что после достаточно большого числа перестановок все элементы списка будут расположены в правильном порядке. Описанный принцип сортировки принято называть <emphasis>методом пузырька</emphasis>, поэтому соответствующая прологовская процедура будет называться <code>пузырек</code>.</p>
      <p><code>пузырек( Спис, УпорСпис) :-</code></p>
      <p><code> перест( Спис, Спис1), !, % Полезная перестановка?</code></p>
      <p><code> пузырек( Спис1, УпорСпис).</code></p>
      <p><code>пузырек( УпорСпис, УпорСпис).</code></p>
      <p><code>  % Если нет, то список уже упорядочен</code></p>
      <empty-line/>
      <p><code>перест( [X, Y | Остаток], [Y, X ) Остаток] ):-</code></p>
      <p><code> % Перестановка первых двух элементов</code></p>
      <p><code> больше( X, Y).</code></p>
      <p><code>перест( [Z | Остаток], [Z | Остаток1] ):-</code></p>
      <p><code> перест( Остаток, Остаток1). % Перестановка в хвосте</code></p>
      <p>Еще один простой алгоритм сортировки называется <emphasis>сортировкой со вставками.</emphasis> Он основан на следующей идее:</p>
      <cite>
       <p>Для того, чтобы упорядочить непустой список <code>L = [X | Хв]</code>, необходимо:</p>
       <p>(1) Упорядочить хвост <code>Хв</code> списка  <code>L</code>.</p>
       <p>(2) Вставить голову <code>X</code> списка <code>L</code> в упорядоченный хвост, поместив ее в такое место, чтобы получившийся список остался упорядоченным. Список отсортирован.</p>
      </cite>
      <p>Этот алгоритм транслируется в следующую процедуру <code>вставсорт</code> на Прологе:</p>
      <p><code>вставсорт([], []).</code></p>
      <p><code>вставсорт( [X | Хв], УпорСпис) :-</code></p>
      <p><code> вставсорт( Хв, УпорХв), % Сортировка хвоста</code></p>
      <empty-line/>
      <p><code>встав( X, УпорХв, УпорСпис).</code></p>
      <p><code>  % Вставить X на нужное место</code></p>
      <p><code>встав( X, [Y | УпорСпис], [Y | УпорСпис1]):-</code></p>
      <p><code> больше( X, Y), !,</code></p>
      <p><code> встав( X, УпорСпис, УпорСпис1).</code></p>
      <p><code>встав( X, УпорСпис, [X | УпорСпис] ).</code></p>
      <image l:href="#_53.png"/>
      <p><strong>Рис. 9.1.</strong> Сортировка списка процедурой <code>быстрсорт</code>.</p>
      <p>Процедуры сортировки <code>пузырек</code> и <code>вставсорт</code> просты, но не эффективны. Из этих двух процедур процедура со вставками более эффективна, однако среднее время, необходимое для сортировки списка длиной  <emphasis>n</emphasis>  процедурой <code>вставсорт</code>, возрастает с ростом <emphasis>n</emphasis> пропорционально <emphasis>n</emphasis>&#178;. Поэтому для длинных списков значительно лучше работает алгоритм <emphasis>быстрой сортировки</emphasis>, основанный на следующей идее (рис. 9.1):</p>
      <cite>
       <p>Для того, чтобы упорядочить непустой список <code>L</code>,  необходимо:</p>
       <p>(1) Удалить из списка <code>L</code> какой-нибудь элемент <code>X</code> и разбить оставшуюся часть на два списка, называемые <code>Меньш</code> и <code>Больш</code>, следующим образом: все элементы большие, чем <code>X</code>, принадлежат списку <code>Больш</code>, остальные — списку <code>Меньш</code>.</p>
       <p>(2) Отсортировать список <code>Меньш</code>, результат — список <code>УпорМеньш</code>.</p>
       <p>(3) Отсортировать список <code>Больш</code>, результат — список <code>УпорБольш</code>.</p>
       <p>(4) Получить результирующий упорядоченный список как конкатенацию списков <code>УпорМеньш</code> и <code>[ X | УпорБольш]</code>.</p>
      </cite>
      <p>Заметим, что если исходный список пуст, то результатом сортировки также будет пустой список. Реализация быстрой сортировки на Прологе показана на рис. 9.2. Здесь в качестве элемента X, удаляемого из списка, всегда выбирается просто голова этого списка. Разбиение на два списка запрограммировано как отношение с четырьмя аргументами:</p>
      <p><code>разбиение( X, L, Больш, Меньш).</code></p>
      <p>Временная сложность нашего алгоритма зависит от того, насколько нам повезет при разбиении сортируемого списка. Если списки всегда разбиваются на два списка примерно равной длины, то процедура сортировки имеет временную сложность порядка <emphasis>n </emphasis>log <emphasis>n</emphasis>, где <emphasis>n</emphasis> — длина исходного списка. Если же, наоборот, разбиение всегда приводит к тому, что один из списков оказывается значительно больше другого, то сложность будет порядка  <emphasis>n</emphasis>&#178;. Анализ показывает, что, к счастью, средняя производительность быстрой сортировки ближе к лучшему случаю, чем к худшему.</p>
      <p>Программу, показанную на рис. 9.2, можно усовершенствовать, если реализовать операцию конкатенации более эффективно. Напомним, что конкатенация становится тривиальной операцией после применения разностного представления списков, введенного в гл. 8. Для того, чтобы использовать эту идею в нашей процедуре сортировки, нужно представить встречающиеся в ней списки в форме пар вида <code>A-Z</code> следующим образом:</p>
      <p><code> УпорМеньш</code> имеет вид <code>A1-Z1</code></p>
      <p><code> УпорБольш</code> имеет вид <code>A2-Z2</code></p>
      <empty-line/>
      <p><code>быстрсорт( [], [] ).</code></p>
      <p><code>быстрсорт( [X | Хвост], УпорСпис) :-</code></p>
      <p><code> разбиение( X, Хвост, Меньш, Больш),</code></p>
      <p><code> быстрсорт( Меньш, УпорМеньш),</code></p>
      <p><code> быстрсорт( Больш, УпорБольш),</code></p>
      <p><code> конк( УпорМеньш, [X | УпорБольш], УпорСпис).</code></p>
      <empty-line/>
      <p><code>разбиение( X, [], [], [] ).</code></p>
      <p><code>разбиение( X, [Y | Хвост], [Y | Меньш], Больш ) :-</code></p>
      <p><code> больше( X, Y), !,</code></p>
      <p><code> разбиение( X, Хвост, Меньш, Больш).</code></p>
      <p><code>разбиение( X, [Y | Хвост], Меньш, [Y | Больш] ) :-</code></p>
      <p><code> разбиение( X, Хвост, Меньш, Больш).</code></p>
      <empty-line/>
      <p><code>конк( [], L, L).</code></p>
      <p><code>конк( [X | L1], L2, [X | L3] ) :-</code></p>
      <p><code> конк( L1, L2, L3 ).</code></p>
      <p><strong>Рис. 9.2.</strong> Быстрая сортировка.</p>
      <empty-line/>
      <p>Тогда конкатенации списков</p>
      <p><code>УпорМеньш</code> и <code>[ X | УпорБольш]</code></p>
      <p>будет соответствовать конкатенация пар</p>
      <p><code>A1-Z1</code> и <code>[ X | A2]-Z2</code></p>
      <p>В результате мы получим</p>
      <p><code>А1-Z2</code>, причем <code>Z1 = [ X | А2]</code></p>
      <p>Пустой список представляется парой Z-Z. Систематически вводя изменения в программу рис. 9.2, мы получим более эффективный способ реализации процедуры <code>быстрсорт</code>, показанный на рис. 9.3 под именем <code>быстрсорт2</code>. Здесь, как и раньше, процедура <code>быстрсорт</code> использует обычное представление списков, но в действительности сортировку выполняет более эффективная процедура <code>быстрсорт2</code>, использующая разностное представление. Эти две процедуры связаны между собой, соотношением</p>
      <p><code>быстрсорт( L, S) :-</code></p>
      <p><code> быстрсорт2( L, S-[] ).</code></p>
      <empty-line/>
      <p><code>быстрсорт( Спис, УпорСпис) :-</code></p>
      <p><code> быстрсорт2( Спис, УпорСпис-[] ).</code></p>
      <empty-line/>
      <p><code>быстрсорт2( [], Z-Z).</code></p>
      <p><code>быстрсорт2( [X | Хвост], A1-Z2) :-</code></p>
      <p><code> разбиение( X, Хвост, Меньш, Больш),</code></p>
      <p><code> быстрсорт2( Меньш, А1-[X | A2] ),</code></p>
      <p><code> быстрсорт2( Больш, A2-Z2).</code></p>
      <p><strong>Рис. 9.3.</strong> Более эффективная реализация процедуры <code>быстрсорт</code>с использованием разностного представления списков. Отношение <code>разбиение( X, Спис, Меньш, Больш)</code> определено, как на рис. 9.2.</p>
      <empty-line/>
      <subtitle>Упражнения</subtitle>
      <p><strong>9.5.</strong> Напишите процедуру слияния двух упорядоченных списков в один третий список. Например:</p>
      <p><code>?- слить( [2, 5, 6, 6, 8], [1, 3, 5, 9], L).</code></p>
      <p><code>L = [1, 2, 3, 5, 5, 6, 6, 8, 9]</code></p>
      <p><strong>9.6.</strong> Программы сортировки, показанные на рис. 9.2 и 9.3, отличаются друг от друга способом представления списков. Первая из них использует обычное представление, в то время как вторая — разностное представление. Преобразование из одного представления в другое очевидно и может быть автоматизировано. Введите в программу рис. 9.2 необходимые изменения, чтобы преобразовать ее в программу рис. 9.3.</p>
      <p><strong>9.7.</strong> Наша программа <code>быстрсорт</code> в случае, когда исходный список уже упорядочен или почти упорядочен, работает очень неэффективно. Проанализируйте причины этого явления.</p>
      <p><strong>9.8.</strong> Существует еще одна хорошая идея относительно механизма сортировки списков, позволяющая избавиться от недостатков программы <code>быстрсорт</code>, а именно: разбить список на два меньших списка, отсортировать их, а затем слить вместе. Итак, для того, чтобы отсортировать список L, необходимо</p>
      <p>• разбить L на два списка L1 и L2 примерно одинаковой длины;</p>
      <p>• произвести сортировку списков L1 и L2,получив списки S1 и S2;</p>
      <p>• слить списки S1 и S2, завершив на этом сортировку списка L.</p>
      <p>Реализуйте этот принцип сортировки и сравните его эффективность с эффективностью программы <code>быстрсорт</code>.</p>
     </section>
    </section>
    <section>
     <title>
      <p>9.2. Представление множеств двоичными деревьями</p>
     </title>
     <p>Списки часто применяют для представления множеств. Такое использование списков имеет тот недостаток, что проверка принадлежности элемента множеству оказывается довольно неэффективной. Обычно предикат <code>принадлежит( X, L)</code> для проверки принадлежности X к L программируют так:</p>
     <p><code>принадлежит X, [X | L] ).</code></p>
     <p><code>принадлежит X, [ Y | L] ) :-</code></p>
     <p><code> принадлежит( X, L).</code></p>
     <p>Для того, чтобы найти X в списке L, эта процедура последовательно просматривает список элемент за элементом, пока ей не встретится либо элемент X, либо конец списка. Для длинных списков такой способ крайне неэффективен.</p>
     <p>Для облегчения более эффективной реализация отношения принадлежности применяют различные древовидные структуры. В настоящем разделе мы рассмотрим двоичные деревья.</p>
     <p>Двоичное дерево либо пусто, либо состоит из следующих трех частей:</p>
     <p>• корень</p>
     <p>• левое поддерево</p>
     <p> правое поддерево</p>
     <p>Корень может быть чем угодно, а поддеревья должны сами быть двоичными деревьями. На рис. 9.4 показано представление множества [а, b, с, d] двоичным деревом. Элементы множества хранятся в виде вершин дерева. Пустые поддеревья на рис. 9.4 не показаны. Например, вершина b имеет два поддерева, которые оба пусты.</p>
     <p>Существует много способов представления двоичных деревьев на Прологе. Одна из простых возможностей — сделать корень главным функтором соответствующего терма, а поддеревья — его аргументами. Тогда дерево рис. 9.4 примет вид</p>
     <p><code>а( b, с( d) )</code></p>
     <p>Такое представление имеет среди прочих своих недостатков то слабое место, что для каждой вершины дерева нужен свой функтор. Это может привести к неприятностям, если вершины сами являются структурными объектами.</p>
     <image l:href="#_54.png"/>
     <p><strong>Рис. 9.4.</strong> Двоичное дерево.</p>
     <p>Существует более эффективный и более привычный способ представления двоичных деревьев: нам нужен специальный символ для обозначения пустого дерева и функтор для построения непустого дерева из трех компонент (корня и двух поддеревьев). Относительно функтора и специального символа сделаем следующий выбор:</p>
     <p>• Пусть атом <code>nil</code> представляет пустое дерево.</p>
     <p>• В качестве функтора примем <code>дер</code>, так что дерево с корнем <code>X</code>, левым поддеревом <code>L</code> и правым поддеревом <code>R</code> будет иметь вид терма <code>дер( L, X, R)</code> (см. рис. 9.5).</p>
     <p>В этом представлении дерево рис. 9.4 выглядит как</p>
     <p><code>дер( дер( nil, b, nil), a,</code></p>
     <p><code> дер( дер( nil, d, nil), с, nil) ).</code></p>
     <p>Теперь рассмотрим отношение принадлежности, которое будем обозначать <code>внутри</code>. Цель</p>
     <p><code>внутри( X, T)</code></p>
     <p>истинна, если <code>X</code> есть вершина дерева <code>T</code>. Отношение <code>внутри</code> можно определить при помощи следующих правил:</p>
     <cite>
      <p>X есть вершина дерева T, если</p>
      <p>• корень дерева T совпадает с X, или</p>
      <p>• X — это вершина из левого поддерева, или</p>
      <p>• X — это вершина из правого поддерева.</p>
     </cite>
     <image l:href="#_55.png"/>
     <p><strong>Рис. 9.5.</strong> Представление двоичных деревьев.</p>
     <p>Эти правила непосредственно транслируются на Пролог следующим образом:</p>
     <p><code>внутри( X, дер( _, X, _) ).</code></p>
     <p><code>внутри( X, дер( L, _, _) ) :-</code></p>
     <p><code> внутри( X, L).</code></p>
     <p><code>внутри( X, дер( _, _, R) ) :-</code></p>
     <p><code> внутри( X, R).</code></p>
     <p>Очевидно, что цель</p>
     <p><code>внутри( X, nil)</code></p>
     <p>терпит неудачу при любом X.</p>
     <p>Посмотрим, как ведет себя наша процедура. Рассмотрим рис. 9.4. Цель</p>
     <p><code>внутри( X, T)</code></p>
     <p>используя механизм возвратов, находит все элементы данных, содержащиеся в множестве, причем обнаруживает их в следующем порядке:</p>
     <p><code>X = а; X = b; X = с; X = d</code></p>
     <p>Теперь рассмотрим вопрос об эффективности. Цель</p>
     <p><code>внутри( а, T)</code></p>
     <p>достигается сразу же после применения первого предложения процедуры <code>внутри</code>. С другой стороны, цель</p>
     <p><code>внутри( d, T)</code></p>
     <p>будет успешно достигнута только после нескольких рекурсивных обращений. Аналогично цель</p>
     <p><code>внутри( e, T)</code></p>
     <p>потерпит неудачу только после того, как будет просмотрено все дерево в результате рекурсивного применения процедуры <code>внутри</code> ко <emphasis>всем</emphasis> поддеревьям дерева T.</p>
     <p>В этом последнем случае мы видим такую же неэффективность, как если бы мы представили множество просто списком. Положение можно улучшить, если между элементами множества существует отношение порядка. Тогда можно упорядочить данные в дереве слева направо в соответствии с этим отношением.</p>
     <image l:href="#_56.png"/>
     <p><strong>Рис. 9.6.</strong> Двоичный справочник. Элемент 6 найден после прохода по отмеченному пути 5&#8594;8&#8594;6.</p>
     <p>Будем говорить, что непустое дерево <code>дер( Лев, X, Прав)</code> упорядочено слева направо, если</p>
     <p>(1) все вершины левого поддерева <code>Лев</code> меньше X;</p>
     <p>(2) все вершины правого поддерева <code>Прав</code> больше X;</p>
     <p>(3) оба поддерева упорядочены.</p>
     <p>Будем называть такое двоичное дерево <emphasis>двоичным справочником</emphasis>. Пример показан на рис. 9.6.</p>
     <p>Преимущество упорядочивания состоит в том, что для поиска некоторого объекта в двоичном справочнике всегда достаточно просмотреть не более одного поддерева. Экономия при поиске объекта X достигается за счет того, что, сравнив X с корнем, мы можем сразу же отбросить одно из поддеревьев. Например, пусть мы ищем элемент 6 в дереве, изображенной на рис. 9.6. Мы начинаем с корня 5, сравниваем 6 с 5, получаем 6 &gt; 5. Поскольку все элементы данных в левом поддереве должны быть меньше, чем 5, единственная область, в которой еще осталась возможность найти элемент 6, — это правое поддерево. Продолжаем поиск в правом поддереве, переходя к вершине 8, и т.д.</p>
     <p>Общий метод поиска в двоичном справочнике состоит в следующем:</p>
     <cite>
      <p>Для того, чтобы найти элемент X в справочнике Д, необходимо:</p>
      <p>• если X — это корень справочника Д, то считать, что X уже найден, иначе</p>
      <p>• если X меньше, чем корень, то искать X в левом поддереве, иначе</p>
      <p>• искать X в правом поддереве;</p>
      <p>• если справочник Д пуст, то поиск терпит неудачу.</p>
     </cite>
     <p>Эти правила запрограммированы в виде процедуры, показанной на рис. 9.7. Отношение <code>больше( X, Y)</code>, означает, что X больше, чем Y. Если элементы, хранимые в дереве, — это числа, то под "больше, чем" имеется в виду просто X &gt; Y.</p>
     <p>Существует способ использовать процедуру <code>внутри</code> также и для <emphasis>построения</emphasis> двоичного справочника. Например, справочник Д, содержащий элементы 5, 3, 8, будет построен при помощи следующей последовательности целей:</p>
     <p><code>?- внутри( 5, Д), внутри( 3, Д), внутри( 8, Д).</code></p>
     <p><code>Д = дер( дер( Д1, 3, Д2), 5, дер( Д3, 8, Д4) ).</code></p>
     <p>Переменные Д1, Д2, Д3 и Д4 соответствуют четырем неопределенным поддеревьям. Какими бы они ни были, все равно дерево Д будет содержать заданные элементы 3, 5 и 8. Структура построенного дерева зависит от того порядка, в котором указываются цели (рис. 9.8).</p>
     <empty-line/>
     <p><code>внутри( X, дер( _, X, _ ).</code></p>
     <p><code>внутри( X, дер( Лев, Корень, Прав) ) :-</code></p>
     <p><code> больше( Корень, X), % Корень больше, чем X</code></p>
     <p><code>внутри( X, Лев).     % Поиск в левом поддереве</code></p>
     <p><code>внутри( X, дер( Лев, Корень, Прав) ) :-</code></p>
     <p><code> больше( X, Корень), % X больше, чем корень</code></p>
     <p><code> внутри( X, Прав).   % Поиск в правом поддереве</code></p>
     <p><strong>Рис. 9.7.</strong> Поиск элемента X в двоичном справочнике.</p>
     <empty-line/>
     <image l:href="#_57.png"/>
     <p><strong>Рис. 9.8.</strong> (а) Дерево <code>Д</code>, построенное как результат достижения целей: <code>внутри( 5, Д)</code>, <code>внутри( 3, Д)</code>, <code>внутри( 8, Д)</code>. (b) Дерево, полученное при другом порядке целей: <code>внутри( 5, Д)</code>, <code>внутри( 3, Д)</code>, <code>внутри( 8, Д)</code>.</p>
     <p>Здесь уместно сделать несколько замечаний относительно эффективности поиска в справочниках. Вообще говоря, поиск элемента в справочнике эффективнее, чем поиск в списке. Но насколько? Пусть <emphasis>n</emphasis> — число элементов множества. Если множество представлено списком, то ожидаемое время поиска будет пропорционально его длине <emphasis>n</emphasis>. В среднем нам придется просмотреть примерно половину списка. Если множество представлено двоичным деревом, то время поиска будет пропорционально глубине дерева. Глубина дерева — это длина самого длинного пути между корнем и листом дерева. Однако следует помнить, что глубина дерева зависит от его формы.</p>
     <p>Мы говорим, что дерево (приближенно) сбалансировано, если для каждой вершины дерева соответствующие два поддерева содержат примерно равное число элементов. Если дерево хорошо сбалансировано, то его глубина пропорциональна log <emphasis>n</emphasis>. В этом случае мы говорим, что дерево имеет логарифмическую сложность. Сбалансированный справочник лучше списка настолько же, насколько log <emphasis>n</emphasis> меньше <emphasis>n</emphasis>. К сожалению, это верно только для приближенно сбалансированного дерева. Если происходит разбалансировка дерева, то производительность падает. В случае полностью разбалансированных деревьев, дерево фактически превращается в список. Глубина дерева в этом случае равна <emphasis>n</emphasis>, а производительность поиска оказывается столь же низкой, как и в случае списка. В связи с этим мы всегда заинтересованы в том, чтобы справочники были сбалансированы. Методы достижения этой цели мы обсудим в гл. 10.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>9.9.</strong> Определите предикаты</p>
     <p><code>двдерево( Объект)</code></p>
     <p><code>справочник( Объект)</code></p>
     <p>распознающие, является ли <code>Объект</code> двоичным деревом или двоичным справочником соответственно. Используйте обозначения, введенные в данном разделе.</p>
     <p><strong>9.10.</strong> Определите процедуру</p>
     <p><code>глубина( ДвДерево, Глубина)</code></p>
     <p>вычисляющую глубину двоичного дерева в предположении, что глубина пустого дерева равна 0, а глубина одноэлементного дерева равна 1.</p>
     <p><strong>9.11.</strong> Определите отношение</p>
     <p><code>линеаризация( Дерево, Список)</code></p>
     <p>соответствующее "выстраиванию" всех вершин дерева в список.</p>
     <p><strong>9.12.</strong> Определите отношение</p>
     <p><code>максэлемент( Д, Элемент)</code></p>
     <p>таким образом, чтобы переменная <code>Элемент</code> приняла значение наибольшего из элементов, хранящихся в дереве <code>Д</code>.</p>
     <p><strong>9.13.</strong> Внесите изменения в процедуру</p>
     <p><code>внутри( Элемент, ДвСправочник)</code></p>
     <p>добавив в нее третий аргумент <code>Путь</code> таким образом, чтобы можно было бы получить путь между корнем справочника и указанным элементом.</p>
    </section>
    <section>
     <title>
      <p>9.3. Двоичные справочники: добавление и удаление элемента</p>
     </title>
     <p>Если мы имеем дело с динамически изменяемым множеством элементов данных, то нам может понадобиться внести в него новый элемент или удалить из него один из старых. В связи с этим набор основных операций, выполняемых над множеством S, таков:</p>
     <p><code>внутри( X, S)       % X  содержится в  S</code></p>
     <p><code>добавить( S, X, S1) % Добавить  X  к  S,  результат -  S1</code></p>
     <p><code>удалить( S, X, S1)  % Удалить  X  из  S,  результат -  S1</code></p>
     <image l:href="#_58.png"/>
     <p><strong>Рис. 9.9.</strong> Введение в двоичный справочник нового элемента на уровне листьев. Показанные деревья соответствуют следующей последовательности вставок: <code>добавить( Д1, 6, Д2)</code><strong>, </strong><code>добавить( Д2, 6, Д3)</code><strong>, </strong><code>добавить( Д3, 6, Д4)</code></p>
     <empty-line/>
     <p><code>доблист( nil, X, дер( nil, X, nil) ).</code></p>
     <p><code>доблист( дер( Лев, X, Прав), X, дер( Лев, X, Прав) ). </code></p>
     <p><code>доблист( дер( Лев, Кор, Прав), X, дер( Лев1, Кор, Прав)) :- </code></p>
     <p><code> больше( Кор, X), </code></p>
     <p><code>доблист( Лев, X, Лев1)). </code></p>
     <p><code>доблист( дер( Лев, Кор, Прав), X, дер( Лев, Кор, Прав1)) :- </code></p>
     <p><code> больше( X, Кор), </code></p>
     <p><code> доблист( Прав, X, Прав1). </code></p>
     <p><strong>Рис. 9.10.</strong> Вставление в двоичный справочник нового элемента в качестве листа.</p>
     <empty-line/>
     <p>Определим отношение <emphasis>добавить</emphasis>. Простейший способ: ввести новый элемент на самый нижний уровень дерева, так что он станет его листом. Место, на которое помещается новый элемент, выбрать таким образом, чтобы не нарушить упорядоченность дерева. На рис. 9.9 показано, какие изменения претерпевает дерево в процессе введения в него новых элементов. Назовем такой метод вставления элемента в множество</p>
     <p><code>доблист( Д, X, Д1)</code></p>
     <p>Правила добавления элемента на уровне листьев таковы:</p>
     <p>• Результат добавления элемента X к пустому дереву есть дерево <code>дер( nil, X, nil)</code>.</p>
     <p>• Если X совпадает с корнем дерева Д, то Д1 = Д (в множестве не допускается дублирования элементов).</p>
     <p>• Если корень дерева Д больше, чем X, то X вносится в левое поддерево дерева Д; если корень меньше, чем X, то X вносится в правое поддерево.</p>
     <p>На рис. 9.10 показана соответствующая программа.</p>
     <p>Теперь рассмотрим операцию <emphasis>удалить</emphasis>. Лист дерева удалить легко, однако удалить какую-либо внутреннюю вершину — дело не простое. Удаление листа можно на самом деле определить как операцию, обратную операции добавления листа:</p>
     <p><code>удлист( Д1, X, Д2) :-</code></p>
     <p><code> доблист( Д2, X, Д1).</code></p>
     <image l:href="#_59.png"/>
     <p><strong>Рис. 9.11.</strong> Удаление X из двоичного справочника. Возникает проблема наложения "заплаты" на место удаленного элемента X.</p>
     <p>К сожалению, если X — это внутренняя вершина, то такой способ не работает, поскольку возникает проблема, иллюстрацией к которой служит рис. 9.11. Вершина X имеет два поддерева <code>Лев</code> и <code>Прав</code>. После удаления вершины X в дереве образуется "дыра", и поддеревья <code>Лев</code> и <code>Прав</code> теряют свою связь с остальной частью дерева. К вершине А оба эти поддерева присоединить невозможно, так как вершина А способна принять только одно из них.</p>
     <p>Если одно из поддеревьев <strong>Лев</strong> и <strong>Прав</strong> пусто, то существует простое решение: подсоединить к А непустое поддерево. Если же оба поддерева непусты, то можно использовать следующую идею (рис. 9.12): если самую левую вершину Y поддерева <code>Прав</code> переместить из ее текущего положения вверх и заполнить ею пробел, оставшийся после X, то упорядоченность дерева не нарушится. Разумеется, та же идея сработает и в симметричном случае, когда перемещается самая правая вершина поддерева <code>Лев</code>.</p>
     <image l:href="#_60.png"/>
     <p><strong>Рис. 9. 2.</strong> Заполнение пустого места после удаления X.</p>
     <p>На рис. 9.13 показана программа, реализующая операцию удаления элементов в соответствии с изложенными выше соображениями. Основную работу по перемещению самой левой вершины выполняет отношение</p>
     <p><code>удмин( Дер, Y, Дер1)</code></p>
     <p>Здесь Y — минимальная (т.е. самая левая) вершина дерева <code>Дер</code>, а <code>Дер1</code> — то, во что превращается дерево <code>Дер</code> после удаления вершины Y.</p>
     <p>Существует другой, элегантный способ реализация операции <emphasis>добавить</emphasis> и <emphasis>удалить</emphasis>. Отношение <emphasis>добавить</emphasis> можно сделать недетерминированным в том смысле, что новый элемент вводится на произвольный уровень дерева, а не только на уровень листьев. Правила таковы:</p>
     <cite>
      <p>Для того, чтобы добавить X в двоичный справочник Д, необходимо одно из двух:</p>
      <p>• добавить X на место корня дерева (так, что X станет новым корнем) или</p>
      <p>• если корень больше, чем X, то внести X в левое поддерево, иначе — в правое поддерево.</p>
     </cite>
     <empty-line/>
     <p><code>уд( дер( nil, X, Прав), X, Прав).</code></p>
     <p><code>уд( дер( Лев, X, nil), X, Лев).</code></p>
     <p><code>уд( дер( Лев, X, Прав), X, дер( Лев,Y, Прав1) ) :-</code></p>
     <p><code> удмин( Прав, Y, Прав1).</code></p>
     <p><code>уд( дер( Лев, Кор, Прав), X, дер( Лев1, Кор, Прав) ) :-</code></p>
     <p><code> больше( Кор, X),</code></p>
     <p><code> уд( Лев, X, Лев1).</code></p>
     <p><code>уд( дер( Лев, Кор, Прав), X, дер( Лев, Кор, Прав1) ) :-</code></p>
     <p><code> больше( X, Кор),</code></p>
     <p><code> уд( Прав, X, Прав1).</code></p>
     <empty-line/>
     <p><code>удмин( дер( nil, Y, Прав), Y, Прав).</code></p>
     <p><code>удмин( дер( Лев, Кор, Прав), Y, дер( Лев1, Кор, Прав) ) :-</code></p>
     <p><code> удмин( Лев, Y, Лев1).</code></p>
     <p><strong>Рис. 9.13.</strong> Удаление элемента из двоичного справочника.</p>
     <empty-line/>
     <p>Трудным моментом здесь является введение X на место корня. Сформулируем эту операций в виде отношения</p>
     <p><code>добкор( Д, X, X1)</code></p>
     <p>где X — новый элемент, вставляемый вместо корня в Д, а Д1 — новый справочник с корнем X. На рис. 9.14 показано, как соотносятся X, Д и Д1. Остается вопрос: что из себя представляют поддеревья L1 и L2 (или, соответственно, R1 и R2) на рис. 9.14?</p>
     <image l:href="#_61.png"/>
     <p><strong>Рис. 9.14.</strong> Внесение X в двоичный справочник в качестве корня.</p>
     <p>Ответ мы получим, если учтем следующие ограничения на L1, L2:</p>
     <p>• L1 и L2 — двоичные справочники;</p>
     <p>• множество всех вершин, содержащихся как в L1, так и в L2, совпадает с множеством вершин справочника L;</p>
     <p>• все вершины из L1 меньше, чем X; все вершены из L2 больше, чем X.</p>
     <p>Отношение, которое способно наложить все эти ограничения на L1, L2, — это как раз и есть наше отношение <code>добкор</code>. Действительно, если бы мы вводили X в L на место корня, то поддеревьями результирующего дерева как раз и оказались бы L1 и L2. В терминах Пролога L1 и L2 должны быть такими, чтобы достигалась цель</p>
     <p><code>добкор( L, X, дер( L1, X, L2) ).</code></p>
     <p>Те же самые ограничения применимы к R1, R2:</p>
     <p><code>добкор( R, X, дер( R1, X, R2) ).</code></p>
     <p>На рис. 9.15 показана программа для "недетерминированного" добавления элемента в двоичный справочник.</p>
     <empty-line/>
     <p><code>добавить( Д, X, Д1) :-               % Добавить X на место корня</code></p>
     <p><code> добкор( Д, X, Д1).</code></p>
     <p><code>добавить( дер( L, Y, R), X, дер( L1, Y, R) ) :-</code></p>
     <p><code> больше( Y, X),                      % Ввести X в левое поддерево</code></p>
     <p><code> добавить( L, X, L1).</code></p>
     <p><code>добавить( дер( L, Y, R), X, дер( L, Y, R1) ) :-</code></p>
     <p><code> больше( X, Y),                      % Ввести X в правое поддерево</code></p>
     <p><code> добавить( R, X, R1).</code></p>
     <empty-line/>
     <p><code>добкор( nil, X, дер( nil, X, nil) ). % Ввести X в пустое дерево</code></p>
     <p><code>добкор( дер( L, Y, R), X, дер( L1, X, дер( L2, Y, R) )) :-</code></p>
     <p><code> больше( Y, X),</code></p>
     <p><code> добкор( L, X, дер( L1, X, L2) ).</code></p>
     <p><code>добкор( дep( L, Y, R), X, дep( дep( L, Y, R1), X, R2) ) :-</code></p>
     <p><code> больше( X, Y),</code></p>
     <p><code> добкор( R, X, дер( R1, X, R2) ).</code></p>
     <p><strong>Рис. 9.15.</strong> Внесение элемента на произвольный уровень двоичного справочника.</p>
     <empty-line/>
     <p>Эта процедура обладает тем замечательным свойством, что в нее не заложено никаких ограничений на уровень дерева, в который вносится новый элемент. В связи с этим операцию <emphasis>добавить</emphasis> можно использовать "в обратном направлении" для удаления элемента из справочника. Например, приведенная ниже последовательность целей строит справочник Д, содержащий элементы 3, 5, 1, 6, а затем удаляет из него элемент 5, после чего получается справочник ДД:</p>
     <p><code>добавить( nil, 3, Д1), добавить( Д1, 5, Д2),</code></p>
     <p><code>добавить( Д2, 1, Д3), добавить( Д3, 6, Д),</code></p>
     <p><code>добавить( ДД, 5, Д).</code></p>
    </section>
    <section>
     <title>
      <p>9.4. Отображение деревьев</p>
     </title>
     <p>Так же, как и любые объекты данных в Прологе, двоичное дерево T может быть непосредственно выведено на печать при помощи встроенной процедуры <code>write</code>. Однако цель</p>
     <p><code>write( T)</code></p>
     <p>хотя и отпечатает всю информацию, содержащуюся в дереве, но действительная структура дерева никак при этом не будет выражена графически. Довольно утомительная работа — пытаться представить себе структуру дерева, рассматривая прологовский терм, которым она представлена. Поэтому во многих случаях желательно иметь возможность отпечатать дерево в такой форме, которая графически соответствует его структуре.</p>
     <p>Существует относительно простой способ это сделать. Уловка состоит в том, чтобы изображать дерево растущим слева направо, а не сверху вниз, как обычно. Дерево нужно повернуть влево таким образом, чтобы корень стал его крайним слева элементом, а листья сдвинулись вправо (рис. 9.16).</p>
     <image l:href="#_62.png"/>
     <p><strong>Рис. 9.16.</strong> (а) Обычное изображение дерева. (b) То же дерево, отпечатанное процедурой <code>отобр</code> (дуги добавлены для ясности).</p>
     <p>Давайте определим процедуру</p>
     <p><code>отобр( T)</code></p>
     <p>так, чтобы она отображала дерево в форме, показанной на рис. 9.16. Принцип работы этой процедуры:</p>
     <cite>
      <p>Для того, чтобы отобразить непустое дерево T, необходимо:</p>
      <p>(1) отобразить правое поддерево дерева T с отступом вправо на расстояние H;</p>
      <p>(2) отпечатать корень дерева T;</p>
      <p>(3) отобразить левое поддерево дерева T с отступом вправо на расстояние H.</p>
     </cite>
     <p>Величина отступа H, которую можно выбирать по желанию, — это дополнительный параметр при отображении деревьев. Введем процедуру</p>
     <p><code>отобр2( T, H)</code></p>
     <p>печатающую дерево T с отступом на H пробелов от левого края листа. Связь между процедурами <code>отобр</code> и <code>отобр2</code> такова:</p>
     <p><code>отобр( T) :- отобр2( T, 0).</code></p>
     <p>На рис. 9.17 показана программа целиком. В этой программе предусмотрен сдвиг на 2 позиции для каждого уровня дерева. Описанный принцип отображения можно легко приспособить для деревьев других типов.</p>
     <empty-line/>
     <p><code>отобр( T) :-</code></p>
     <p><code> отобр2( T, 0).</code></p>
     <empty-line/>
     <p><code>отобр2( nil, _ ).</code></p>
     <p><code>отобр2( дер( L, X, R), Отступ) :-</code></p>
     <p><code> Отступ2 is Отступ + 2,</code></p>
     <p><code> отобр2( R, Отступ2),</code></p>
     <p><code> tab( Отступ), write( X), nl,</code></p>
     <p><code> отобр( L, Отступ2).</code></p>
     <p><strong>Рис. 9.17.</strong> Отображение двоичного дерева.</p>
     <empty-line/>
     <subtitle>Упражнение</subtitle>
     <p><strong>9.14.</strong> Наша процедура изображает дерево, ориентируя его необычным образом: корень находится слева, а листья — справа. Напишите (более сложную) процедуру для отображения дерева, ориентированного обычным образом, т.е. с корнем наверху и листьями внизу. </p>
    </section>
    <section>
     <title>
      <p>9.5. Графы </p>
     </title>
     <section>
      <title>
       <p>9.5.1. Представление графов</p>
      </title>
      <p>Графы используются во многих приложениях, например для представления отношений, ситуаций или структур задач. Граф определяется как множество <emphasis>вершин</emphasis> вместе с множеством <emphasis>ребер</emphasis>, причем каждое ребро задается парой вершин. Если ребра направлены, то их также называют <emphasis>дугами</emphasis>. Дуги задаются <emphasis>упорядоченными</emphasis> парами. Такие графы называются <emphasis>направленными</emphasis>. Ребрам можно приписывать стоимости, имена или метки произвольного вида, в зависимости от конкретного приложения. На рис. 9.18 показаны примеры графов.</p>
      <p>В Прологе графы можно представлять различными способами. Один из них — каждое ребро записывать в виде отдельного предложения. Например, графы, показанные на рис. 9.18, можно представить в виде следующего множества предложений:</p>
      <p><code>связь( а, b).</code></p>
      <p><code>связь( b, с).</code></p>
      <p><code>...</code></p>
      <p><code>дуга( s, t, 3).</code></p>
      <p><code>дуга( t, v, 1).</code></p>
      <p><code>дуга( u, t, 2).</code></p>
      <p><code>...</code></p>
      <p>Другой способ — весь граф представлять как один объект. В этом случае графу соответствует пара множеств — множество вершин и множество ребер. Каждое множество можно задавать при помощи списка, каждое ребро — парой вершин. Для объединения двух множеств в пару будем применять функтор <code>граф</code>, а для записи ребра — функтор <code>p</code>. Тогда (ненаправленный) граф рис. 9.18 примет вид:</p>
      <p><code>G1 = граф( [a, b, c, d],</code></p>
      <p><code> [p( а, b), p( b, d), p( b, с), p( c, d)] )</code></p>
      <image l:href="#_63.png"/>
      <p><strong>Рис. 9.18.</strong> (а) Граф. (b) Направленный граф. Каждой дуге приписана ее стоимость.</p>
      <p>Для представления направленного графа (рис. 9.18), применив функторы <code>диграф</code> и <code>д</code> (для дуг), получим</p>
      <p><code>G2 = диграф( [s, t, u, v],</code></p>
      <p><code> [д( s, t, 3), д( t, v, 1), д( t, u, 5), д( u, t, 2),</code></p>
      <p><code>  д( v, u, 2) ] )</code></p>
      <p>Если каждая вершина графа соединена ребром еще по крайней мере с одной вершиной, то в представлении графа можно опустить множество вершин, поскольку оно неявным образом содержится в списке ребер.</p>
      <p>Еще один способ представления графа — связать с каждой вершиной список смежных с ней вершин. В этом случае граф превращается в список пар, каждая из которых состоит из вершины- плюс ее список смежности. Наши графы (рис. 9.18), например, можно представить как</p>
      <p><code>G1 = [ a-&gt;[b1, b-&gt;[a, c, d], c-&gt;[b, d], d-&gt;[b, c] ]</code></p>
      <p><code>G2 = [s-&gt;[t/3], t-&gt;[u/5, v/l], u-&gt;[t/2], v-&gt;[u/2]]</code></p>
      <p>Здесь символы '<code>-&gt;</code>' и '<code>/</code>' — инфиксные операторы.</p>
      <p>Какой из способов представления окажется более удобным, зависит от конкретного приложения, а также от того, какие операции имеется в виду выполнять над графами. Вот типичные операции:</p>
      <p>• найти путь между двумя заданными вершинами;</p>
      <p>• найти подграф, обладающий некоторыми заданными свойствами.</p>
      <p>Примером последней операции может служить построение основного дерева графа. В последующих разделах, мы рассмотрим некоторые простые программы для поиска пути в графе и построения основного дерева. </p>
     </section>
     <section>
      <title>
       <p>9.5.2. Поиск пути в графе</p>
      </title>
      <p>Пусть G — граф, а А и Z — две его вершины. Определим отношение</p>
      <p><code>путь( А, Z, G, P)</code></p>
      <p>где P — ациклический путь между А и Z в графе G. Если G — граф, показанный в левой части рис. 9.18, то верно:</p>
      <p><code>путь( a, d, G, [a, b, d] )</code></p>
      <p><code>путь( а, d, G, [a, b, c, d] )</code></p>
      <p>Поскольку путь не должен содержать циклов, любая вершина может присутствовать в пути не более одного раза. Вот один из методов поиска пути:</p>
      <cite>
       <p>Для того, чтобы найти ациклический путь P между А и Z в графе G, необходимо:</p>
       <p>Если А = Z , то положить P = [А], иначе найти ациклический путь P1 из произвольной вершины Y в Z, а затем найти путь из А в Y, не содержащий вершин из P1.</p>
      </cite>
      <p>В этой формулировке неявно предполагается, что существует еще одно отношение, соответствующее поиску пути со следующий ограничением: путь не должен проходить через вершины из некоторого подмножества (в данном случае P1) множества всех вершин графа. В связи с этим мы определим ещё одну процедуру:</p>
      <p><code>путь1( А, P1, G, P)</code></p>
      <p>Аргументы в соответствии с рис. 9.19 имеют следующий смысл:</p>
      <p>• А — некоторая вершина,</p>
      <p>• G — граф,</p>
      <p>• P1 — путь в G,</p>
      <p>• P — ациклический путь в G, идущий из А в начальную вершину пути P1, а затем — вдоль пути P1 вплоть до его конца.</p>
      <image l:href="#_64.png"/>
      <p><strong>Pис. 9.19.</strong> Отношение <code>путь1</code>: <code>Путь</code> — это путь между <code>А</code> и <code>Z</code>, в своей заключительной части он перекрывается с <code>Путь1</code>.</p>
      <p>Между <code>путь</code> и <code>путь1</code> имеется следующее соотношение:</p>
      <p><code>путь( А, Z, G, P) :- путь1( А, [Z], G, P).</code></p>
      <p>На рис. 9.19 показана идея рекурсивного определения отношения <code>путь1</code>. Существует "граничный" случай, когда начальная вершина пути P1 (Y на рис. 9.19) совпадает с начальной вершиной А пути P. Если же начальные вершины этих двух путей не совпадают, то должна существовать такая вершина X, что</p>
      <p>(1) Y — вершина, смежная с X,</p>
      <p>(2) X не содержится в P1 и</p>
      <p>(3) для P выполняется отношение <code>путь1( А, [X | P1], G, P)</code>.</p>
      <empty-line/>
      <p><code>путь( A, Z, Граф, Путь) :-</code></p>
      <p><code> путь1( А, [Z], Граф, Путь).</code></p>
      <empty-line/>
      <p><code>путь1( А, [А | Путь1, _, [А | Путь1] ).</code></p>
      <p><code>путь1( А, [Y | Путь1], Граф, Путь) :-</code></p>
      <p><code> смеж( X, Y, Граф),</code></p>
      <p><code> принадлежит( X, Путь1), % Условие отсутствия цикла</code></p>
      <p><code> путь1( А, [ X, Y | Путь1], Граф, Путь).</code></p>
      <p><strong>Рис. 9.20.</strong> Поиск в графе <code>Граф</code> ациклического пути <code>Путь</code> из А в Z.</p>
      <empty-line/>
      <p>На рис. 9.20 программа показана полностью. Здесь <code>принадлежит</code> — отношение принадлежности элемента списку. Отношение</p>
      <p><code>смеж( X, Y, G)</code></p>
      <p>означает, что в графе G существует дуга, ведущая из X в Y. Определение этого отношения зависит от способа представления графа. Если G представлен как пара множеств (вершин и ребер)</p>
      <p><code>G = граф( Верш, Реб)</code></p>
      <p>то</p>
      <p><code>смеж( X, Y, граф( Верш, Реб) ) :-</code></p>
      <p><code> принадлежит( p( X, Y), Реб);</code></p>
      <p><code> принадлежит( p( Y, X), Реб).</code></p>
      <p>Классическая задача на графах — поиск Гамильтонова цикла, т.е. ациклического пути, проходящего через все вершины графа. Используя отношение <code>путь</code>, эту задачу можно решить так:</p>
      <p><code>гамильтон( Граф, Путь) :-</code></p>
      <p><code> путь( _, _, Граф, Путь),</code></p>
      <p><code> всевершины( Путь, Граф).</code></p>
      <empty-line/>
      <p><code>всевершины( Путь, Граф) :-</code></p>
      <p><code> not (вершина( В, Граф),</code></p>
      <p><code> not принадлежит( В, Путь) ).</code></p>
      <p>Здесь <code>вершина( В, Граф)</code> означает: <code>В</code> — вершина графа <code>Граф</code>.</p>
      <p>Каждому пути можно приписать его стоимость. Стоимость пути равна сумме стоимостей входящих в него дуг. Если дугам не приписаны стоимости, то тогда, вместо стоимости, говорят о длине пути.</p>
      <p>Для того, чтобы наши отношения <code>путь</code> и <code>путь1</code> могли работать со стоимостями, их нужно модифицировать, введя дополнительный аргумент для каждого пути:</p>
      <p><code>путь( А, Z, G, P, С)</code></p>
      <p><code>путь1( A, P1, C1, G, P, С)</code></p>
      <p>Здесь С — стоимость пути P, a C1 — стоимость пути P1. В отношении <code>смеж</code> также появится дополнительный аргумент, стоимость дуги. На рис. 9.21 показана программа поиска пути, которая строит путь и вычисляет его стоимость.</p>
      <empty-line/>
      <p><code>путь( А, Z, Граф, Путь, Ст) :-</code></p>
      <p><code> путь1( A, [Z], 0, Граф, Путь, Ст).</code></p>
      <empty-line/>
      <p><code>путь1( А, [А | Путь1], Ст1, Граф, [А | Путь1], Ст).</code></p>
      <p><code>путь1( А, [Y | Путь1], Ст1, Граф, Путь, Ст) :-</code></p>
      <p><code> смеж( X, Y, СтXY, Граф),</code></p>
      <p><code> not принадлежит( X, Путь1),</code></p>
      <p><code> Ст2 is Ст1 + СтXY,</code></p>
      <p><code> путь1( А, [ X, Y | Путь1], Ст2, Граф, Путь, Ст).</code></p>
      <p><strong>Рис. 9.21.</strong> Поиск пути в графе: <code>Путь</code> — путь между А и Z в графе <code>Граф</code> стоимостью Ст.</p>
      <empty-line/>
      <p>Эту процедуру можно использовать для нахождения пути минимальной стоимости. Мы можем построить путь минимальной стоимости между вершинами <code>Верш1</code>, <code>Верш2</code> графа <code>Граф</code>, задав цели</p>
      <p><code>путь( Bepш1, Верш2, Граф, МинПуть, МинСт),</code></p>
      <p><code> not( путь( Верш1, Верш2, Граф, _, Ст), Ст&lt;МинСт )</code></p>
      <p>Аналогично можно среди всех путей между вершинами графа найти путь максимальной стоимости, задав цели</p>
      <p><code>путь( _, _, Граф, МаксПуть, МаксСт),</code></p>
      <p><code> not( путь( _, _, Граф, _, Ст), Ст &gt; МаксСт)</code></p>
      <p>Заметим, что приведенный способ поиска максимальных и минимальных путей крайне неэффективен, так как он предполагает просмотр всех возможных путей и потому не подходит для больших графов из-за своей высокой временной сложности. В искусственном интеллекте задача поиска пути возникает довольно часто. В главах 11 и 12 мы изучим более сложные методы нахождения оптимальных путей. </p>
     </section>
     <section>
      <title>
       <p>9.5.3. Построение остовного дерева</p>
      </title>
      <p>Граф называется <emphasis>связным</emphasis>, если между любыми двумя его вершинами существует путь. Пусть G = (V, E) — связный граф с множеством вершин V и множеством ребep E. <emphasis>Остовное дерево</emphasis> графа G — это связный граф T = ( V,  E'), где E' — подмножество E такое, что</p>
      <p>(1) T — связный граф, </p>
      <p>(2) в T нет циклов.</p>
      <p>Выполнение этих двух условий гарантирует то, что T — дерево. Для графа, изображенного в левой части рис. 9.18, существует три остовных дерева, соответствующих следующим трем спискам ребер:</p>
      <p><code>Дер1 = [а-b, b-c, c-d]</code></p>
      <p><code>Дер2 = [а-b, b-d, d-с]</code></p>
      <p><code>Дер3 = [а-b, b-d, b-c]</code></p>
      <p>Здесь каждый терм вида X-Y обозначает ребро, соединяющее вершины X и Y. В качестве корня можно взять любую из вершин, указанных в списке. Остовные деревья представляют интерес, например в задачах проектирования сетей связи, поскольку они позволяют, имея минимальное число линий, установить связь между любыми двумя узлами, соответствующими вершинам графа.</p>
      <p>Определим процедуру</p>
      <p><code>остдерево( G, T)</code></p>
      <p>где T — остовное дерево графа G. Будем предполагать, что G — связный граф. Можно представить себе алгоритмический процесс построения остовного дерева следующим образом. Начать с пустого множества ребер и постепенно добавлять новые ребра, постоянно следя за тем, чтобы не образовывались циклы. Продолжать этот процесс до тех пор, пока не обнаружится, что нельзя присоединить ни одного ребра, поскольку любое новое ребро порождает цикл. Полученное множество ребер будет остовным деревом. Отсутствие циклов можно обеспечить, если придерживаться следующего простого правила: ребро присоединяется к дереву только в том случае, когда одна из его вершин уже содержится в строящемся дереве, а другая пока еще не включена в него. Программа, реализующая эту идею, показана на рис. 9.22. Основное отношение, используемое в этой программе, — это</p>
      <p><code>расширить( Дер1, Дер, G)</code></p>
      <p>Здесь все три аргумента — множества ребер. <code>G</code> — связный граф; <code>Дер1</code> и <code>Дер</code> — два подмножества <code>G</code>, являющиеся деревьями. <code>Дер</code> — остовное дерево графа <code>G</code>, полученное добавлением некоторого (может быть пустого) множества ребер из <code>G</code> к <code>Дер1</code>. Можно сказать, что "<code>Дер1</code> расширено до <code>Дер</code>".</p>
      <empty-line/>
      <p><code>% Построение остовного дерева графа</code></p>
      <p><code>%</code></p>
      <p><code>% Деревья и графы представлены списками</code></p>
      <p><code>% своих ребер, например:</code></p>
      <p><code>% Граф = [а-b, b-с, b-d, c-d]</code></p>
      <p><code>остдерево( Граф, Дер) :- % Дер - остовное дерево Граф'а</code></p>
      <p><code> принадлежит( Ребро, Граф),</code></p>
      <p><code> расширить( [Ребро], Дер, Граф).</code></p>
      <empty-line/>
      <p><code>расширить( Дер1, Дер, Граф) :-</code></p>
      <p><code> добребро( Дер1, Дер2, Граф),</code></p>
      <p><code> расширить( Дер2, Дер, Граф).</code></p>
      <p><code>расширить( Дер, Дер, Граф) :-</code></p>
      <p><code> not добребро( Дер, _, Граф).</code></p>
      <p><code>  % Добавление любого ребра приводит к циклу</code></p>
      <empty-line/>
      <p><code>добребро( Дер, [А-В | Дер], Граф) :-</code></p>
      <p><code> смеж( А, В, Граф),      % А и В - смежные вершины</code></p>
      <p><code> вершина( А, Дер).       % А содержится в Дер</code></p>
      <p><code> not вершина( В, Дер).   % А-В не порождает цикла</code></p>
      <empty-line/>
      <p><code>смеж( А, В, Граф) :-</code></p>
      <p><code> принадлежит ( А-В, Граф);</code></p>
      <p><code> принадлежит ( В-А, Граф).</code></p>
      <empty-line/>
      <p><code>вершина( А, Граф) :-     % А содержится в графе, если</code></p>
      <p><code> смеж( А, _, Граф).      % А смежна какой-нибудь вершине</code></p>
      <p><strong>Pис. 9.22.</strong> Построение остовного дерева: алгоритмический подход. Предполагается, что <code>Граф</code> — связный граф.</p>
      <empty-line/>
      <p>Интересно, что можно написать программу построения остовного дерева совершенно другим, полностью декларативным способом, просто формулируя на Прологе некоторые математические определения. Допустим, что как графы, так и деревья задаются списками своих ребер, как в программе рис. 9.22. Нам понадобятся следующие определения:</p>
      <p>(1) T является остовным деревом графа G, если</p>
      <p> • T — это подмножество графа G и</p>
      <p> • T — дерево и</p>
      <p> • T "накрывает" G, т.е. каждая вершина из G содержится также в T.</p>
      <p>(2) Множество ребер T есть дерево, если</p>
      <p> • T — связный граф и</p>
      <p> • T не содержит циклов.</p>
      <p>Эти определения можно сформулировать на Прологе (с использованием нашей программы <code>путь</code> из предыдущего раздела) так, как показано на рис. 9.23. Следует, однако, заметить, что эта программа в таком ее виде не представляет практического интереса из-за своей неэффективности.</p>
      <empty-line/>
      <p><code>% Построение остовного дерева</code></p>
      <p><code>% Графы и деревья представлены списками ребер.</code></p>
      <p><code>остдерево( Граф, Дер) :-</code></p>
      <p><code> подмнож( Граф, Дер),</code></p>
      <p><code> дерево( Дер),</code></p>
      <p><code> накрывает( Дер, Граф).</code></p>
      <empty-line/>
      <p><code>дерево( Дер) :-</code></p>
      <p><code> связи( Дер),</code></p>
      <p><code> not имеетцикл( Дер).</code></p>
      <empty-line/>
      <p><code>связи( Дер) :-</code></p>
      <p><code> not ( вершина( А, Дер), вершина( В, Дер),</code></p>
      <p><code> not путь( А, А, Дер, _ ) ).</code></p>
      <empty-line/>
      <p><code>имеетцикл( Дер) :-</code></p>
      <p><code> смеж( А, В, Дер),</code></p>
      <p><code> путь( А, В, Дер, [А, X, Y | _ ). % Длина пути &gt; 1</code></p>
      <empty-line/>
      <p><code>накрывает( Дер, Граф) :-</code></p>
      <p><code> not ( вершина( А, Граф), not вершина( А, Дер) ).</code></p>
      <empty-line/>
      <p><code>подмнож( [], []).</code></p>
      <p><code>подмнож( [ X | L], S) :-</code></p>
      <p><code> подмнож( L, L1),</code></p>
      <p><code> ( S = L1; S = [ X | L1] ).</code></p>
      <p><strong>Рис. 9.23.</strong> Построение остовного дерева: "декларативный подход".</p>
      <empty-line/>
      <p>Отношения <code>вершина</code> и <code>смеж</code> см. на рис. 9. 22.</p>
      <subtitle>Упражнение</subtitle>
      <p><strong>9.15.</strong> Рассмотрите остовные деревья в случае, когда каждому ребру графа приписана его стоимость. Пусть <emphasis>стоимость</emphasis> остовного дерева определена как сумма стоимостей составляющих его ребер. Напишите программу построения для заданного графа его остовного дерева минимальной стоимости.</p>
     </section>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>В данной главе мы изучали реализацию на Прологе некоторых часто используемых структур данных и соответствующих операций над ними. В том числе</p>
     <p>• Списки:</p>
     <p>  варианты представления списков</p>
     <p>  сортировка списков:</p>
     <p>    сортировка методом "пузырька"</p>
     <p>    сортировка со вставками</p>
     <p>    быстрая сортировка</p>
     <p>    эффективность этих процедур</p>
     <p>• Представление множеств двоичными деревьями и двоичными справочниками:</p>
     <p>   поиск элемента в дереве</p>
     <p>   добавление элемента</p>
     <p>   удаление элемента</p>
     <p>   добавление в качестве листа или корня</p>
     <p>   сбалансированность деревьев и его связь с эффективностью этих операций</p>
     <p>   отображение деревьев</p>
     <p>• Графы:</p>
     <p>   представление графов</p>
     <p>   поиск пути в графе</p>
     <p>   построение остовного дерева</p>
     <subtitle>Литература</subtitle>
     <p>В этой главе мы занимались такими важными темами, как сортировка и работа со структурами данных для представления множеств. Общее описание структур данных, а также алгоритмов, запрограммированных в данной главе, можно найти, например, в Aho, Hopcroft and Ullman (1974, 1983) или Baase (1978). В литературе рассматривается также поведение этих алгоритмов, особенно их временная сложность. Хороший и краткий обзор соответствующих алгоритмов и результатов их математического анализа можно найти в Gonnet (1984).</p>
     <p>Прологовская программа для внесения нового элемента на произвольный уровень дерева (раздел 9.3) была впервые показана автору М. Ван Эмденом (при личном общении).</p>
     <empty-line/>
     <p>Aho А. V., Hopcroft J. E. and Ullman J. D. (1974). <emphasis>The Design and Analysis of Computer Algorithms.</emphasis> Addison-Wesley. [Имеется перевод: Ахо А., Хопкрофт Дж. Построение и анализ вычислительных алгоритмов. Пер. с англ. — М.: Мир, 1979.]</p>
     <p>Aho А. V., Hopcroft J. E. and Ullman J. D. (1983). <emphasis>Data Structures and Algorithms.</emphasis> Addison-Wesley.</p>
     <p>Baase S. (1978). <emphasis>Computer Algorithms.</emphasis> Addison-Wesley.</p>
     <p>Gonnet G. H. (1984). <emphasis>Handbook of Algorithms and Data Structures.</emphasis> Addison-Wesley.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 10</p>
     <p>Усовершенствованные методы представления множеств деревьями</p>
    </title>
    <section>
     <p>В данной главе мы рассмотрим усовершенствованные методы представления множеств при помощи деревьев. Основная идея состоит в том, чтобы поддерживать сбалансированности или приближенную сбалансированность дерева, с тем чтобы избежать вырождения его в список. Механизмы балансировки деревьев гарантируют, даже в худшем случае, относительно быстрый доступ к элементам данных, хранящихся в дереве, при логарифмическом порядке времени доступа. В этой главе изложено два таких механизма: двоично-троичные (кратко, 2-3) деревья и AVL-деревья. (Для изучения остальных глав понимание данной главы не обязательно.)</p>
    </section>
    <section>
     <title>
      <p>10.1. Двоично-троичные справочники</p>
     </title>
     <p>Двоичное дерево называют хорошо сбалансированным, если оба его поддерева имеют примерно одинаковую глубину (или размер) и сами сбалансированы. Глубина сбалансированного дерева приближенно равна log <emphasis>n</emphasis>, где <emphasis>n</emphasis> — число вершин дерева. Время, необходимое для вычислений, производимых отношениями <code>внутри</code>, <code>добавить</code> и <code>удалить</code> над двоичными справочниками, пропорционально глубине дерева. Таким образом, в случае двоичных справочников это время имеет порядок log <emphasis>n</emphasis>. Логарифмический рост сложности алгоритма, проверяющего принадлежность элемента множеству, — это определенное достижение по сравнению со списковым представлением, поскольку в последнем случае мы имеем линейный рост сложности с ростом размера множества. Однако плохая сбалансированность дерева ведет к деградации производительности алгоритмов, работающие со справочником. В крайнем случае, двоичный справочник вырождается в список, как показано на рис. 10.1. Форма справочника зависит от той последовательности, а которой в всего записываются элементы данных. В лучшей случае мы получаем хорошую балансировку и производительность порядка log <emphasis>n</emphasis>, а в худшем — производительность будет порядка <emphasis>n</emphasis>. Анализ показывает, что в среднем сложность алгоритмов <code>внутри</code>, <code>добавить</code> и <code>удалить</code> сохраняет порядок log <emphasis>n</emphasis> в допущении, что все возможные входные последовательности равновероятны. Таким образом, средняя производительность, к счастью, оказывается ближе к лучшему случаю, чек к худшему. Существует, однако, несколько довольно простых механизмов, которые поддерживают хорошую сбалансированность дерева, вне зависимости от входной последовательности, формирующей дерево. Эти механизмы гарантируют производительность алгоритмов <code>внутри</code>, <code>добавить</code> и <code>удалить</code> порядка log <emphasis>n</emphasis> даже <emphasis>в худшем случае</emphasis>. Один из этих механизмов - двоично-троичные деревья (кратко, 2-3 деревья), а другой — AVL-деревья.</p>
     <image l:href="#_65.png"/>
     <p><strong>Рис. 10.1.</strong> Полностью разбалансированный двоичный справочник. Производительность его та же, что и у списка.</p>
     <p>2-3 дерево определяется следующим образом: оно или пусто, или состоит из единственной вершины, или удовлетворяет следующим условиям:</p>
     <p>• каждая внутренняя вершина имеет две или три дочерних вершины, и</p>
     <p>• все листья дерева находятся на одном и том же уровне.</p>
     <p>Двоично-троичным (2-3) справочником называется 2-3 дерево, все элементы данных которого хранятся в листьях и упорядочены слева направо. На рис. 10.2 показан пример. Внутренние вершины содержат метки, равные минимальным элементам тех или иных своих поддеревьев, в соответствии со следующими правилами:</p>
     <p>• если внутренняя вершина имеет два поддерева, то она содержит минимальный элемент второго из них;</p>
     <p>• если внутренняя вершина имеет три поддерева, то она содержит минимальные элементы второго и третьего поддеревьев.</p>
     <image l:href="#_66.png"/>
     <p><strong>Рис. 10.2.</strong> 2-3 справочник. Отмеченный путь показывает процесс поиска элемента 10.</p>
     <p>При поиске элемента X в 2-3 справочнике мы начинаем с корня и двигаемся в направлении самого нижнего уровня, руководствуясь при этом метками внутренних вершин дерева. Пусть корень содержит метки M1 и M2, тогда</p>
     <p>• если X &lt; M1, то поиск продолжается в левом поддереве, иначе</p>
     <p>• если X &lt; M2, то поиск продолжается в среднем поддереве, иначе —</p>
     <p>• в правом поддереве.</p>
     <p>Если в корне находится только одна метка М, то переходим к левому поддереву при X &lt; M и к правому поддереву — в противоположном случае. Продолжаем применять сформулированные выше правила, пока не окажемся на самом нижнем уровне дерева, где и выяснится, найден ли элемент X, или же поиск потерпел неудачу.</p>
     <p>Так как все листья 2-3 дерева находятся на одном и том же уровне, 2-3 дерево идеально сбалансировано с точки зрения глубины составляющих его поддеревьев. Все пути от корня до листа, которые мы проходим при поиске, имеют одну и ту же длину порядка log<emphasis> n</emphasis>, где <emphasis>n</emphasis> — число элементов, хранящихся в дереве.</p>
     <p>При добавлении нового элемента данных 2-3 дерево может расти не только в глубину, но и в ширину. Каждая внутренняя вершина, имеющая два поддерева, может приобрести новое поддерево, что приводит к росту вширь. Если же, с другой стороны, у вершины уже есть три поддерева, и она должна принять еще одно, то она расщепляется на две вершины, каждая из которых берет на себя по два из имеющихся четырех поддеревьев. Образовавшаяся при этом новая вершина передается вверх по дереву для присоединения к одной из выше расположенных вершин. Если же эта ситуация возникает на самом высоком уровне, то дерево вынуждено "вырасти" на один уровень вверх. Рис. 10.3 иллюстрирует описанный принцип.</p>
     <image l:href="#_67.png"/>
     <p><strong>Рис. 10.3.</strong> Вставление нового элемента в 2-3 справочник. Дерево растет сначала вширь, а затем уже вглубь.</p>
     <p>Включение нового элемента в 2-3 справочник мы запрограммируем как отношение</p>
     <p><code>доб23( Дер, X, НовДер)</code></p>
     <p>где дерево <code>НовДер</code> получено введением элемента <code>X</code> в дерево <code>Дер</code>. Основную работу мы поручим двум дополнительным отношениям, которые мы назовем <code>встав</code>. Первое из них имеет три аргумента:</p>
     <p><code>встав( Дер, X, НовДер).</code></p>
     <p>Здесь <code>НовДер</code> — результат вставления элемента <code>X</code> в <code>Дер</code>. Деревья <code>Дер</code> и <code>НовДер</code> имеют <emphasis>одну и ту же глубину</emphasis>. Разумеется, не всегда возможно сохранить ту же глубину дерева. Поэтому существует еще одно отношение с пятью аргументами специально для этого случая:</p>
     <p><code>встав( Дер, X, НДа, Mб, НДб).</code></p>
     <p>Имеется в виду, что при вставления <code>X</code> в <code>Дер</code> дерево <code>Дер</code> разбивается на два дерева <code>НДа</code> и <code>НДб</code>, имеющих ту же глубину, что и <code>Дер</code>. <code>Мб</code> — это минимальный элемент из <code>НДб</code>. Пример показан на рис. 10.4.</p>
     <image l:href="#_68.png"/>
     <p><strong>Рис. 10.4.</strong> Объекты, показанные на рисунке, удовлетворяют отношению <code>встав( Дер, 6, НДа, Мб, НДб)</code>.</p>
     <p>2-3 деревья мы будем представлять в программе следующим образом:</p>
     <p>• <code>nil</code> представляет пустое дерево;</p>
     <p>• <code>л( X)</code> представляет дерево, состоящее из одной вершины — листа с элементом X;</p>
     <p>• <code>в2( Д1, М, Д2)</code> представляет дерево с двумя поддеревьями Д1 и Д2; M — минимальный элемент из Д2;</p>
     <p>• <code>в3( Д1, M2, Д2, М3, Д3)</code> представляет дерево с тремя поддеревьями Д1, Д2 и Д3; M2 — минимальный элемент из Д2; М3 — минимальный элемент из Д3; Д1, Д2 и Д3 — 2-3 деревья.</p>
     <p>Между <code>доб23</code> и <code>встав</code> существует следующая связь: если после вставления нового элемента дерево не "вырастает", то</p>
     <p><code>доб23( Дер, X, НовДер) :-</code></p>
     <p><code> встав( Дер, X, НовДер).</code></p>
     <p>Однако если после вставления элемента глубина дерева увеличивается, то <code>встав</code> порождает два поддерева Д1 и Д2, а затем составляет из них дерево большей глубины:</p>
     <p><code>доб23( Дер, X, в2( Д1, М, Д2) ) :-</code></p>
     <p><code> встав( Дер, X, Д1, М, Д2).</code></p>
     <p>Отношение <code>встав</code> устроено более сложным образом, поскольку ему приходится иметь дело со многими случаями, а именно вставление в пустое дерево, в дерево, состоящее из одного листа, и в деревья типов в2 и в3. Возникают также дополнительные подслучаи, так как новый элемент можно вставить в первое, либо во второе, либо в третье поддерево. В связи с этим мы определим <code>встав</code> как набор правил таким образом, чтобы каждое предложение процедуры <code>встав</code> имело дело с одним из этих случаев. На рис. 10.5 показаны некоторые из возможных случаев. На Пролог они транслируются следующим образом:</p>
     <p><emphasis>Случай а</emphasis></p>
     <p><code> встав( в2( Д1, M, Д2), X, в2( НД1, M, Д2) ) :-</code></p>
     <p><code>  больше( M, X), % M больше, чем X</code></p>
     <p><code>  встав( Д1, X, НД1).</code></p>
     <p><emphasis>Случай b</emphasis></p>
     <p><code> встав( в2( Д1, M, Д2), X, в3( НД1а, Мб, НД1б, M, Д2) ) :-</code></p>
     <p><code>  больше( M, X),</code></p>
     <p><code>  встав( Д1, X, НД1а, Мб, НД1б).</code></p>
     <p><emphasis>Случай с</emphasis></p>
     <p><code> встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code>  в2( НД1а, Мб, НД1б), M2, в2(Д2, М3, Д3) ) :-</code></p>
     <p><code>  больше( M2, X),</code></p>
     <p><code>  встав( Д1, X, НД1а, Мб, НД1б).</code></p>
     <image l:href="#_69.png"/>
     <p><strong>Рис. 10.5.</strong> Некоторые из случаев работы отношения <code>встав</code><strong>. </strong>(a) <code>встав( в2( Д1, М, Д2), X, в2( НД1, М, Д2) )</code>; (b) <code>встав( в2( Д1, М, Д2), X, в3( НД1а, Мб, НД1б, М, Д2) )</code>; (c) <code>встав( в3( Д1, M2, Д2, М3, Д3), X, в2( НД1а, Мб, НД1б), M2, в2( Д2, М3, Д3) )</code>. </p>
     <empty-line/>
     <p><code>% Вставление элемента в 2-3 справочник</code></p>
     <p><code>доб23( Дер, X, Дер1) :-      % Вставить X в Дер, получить Дер1</code></p>
     <p><code> встав( Дер, X, Дер1).       % Дерево растет вширь</code></p>
     <p><code>доб23( Дер, X, в2( Д1, M2, Д2) ) :-</code></p>
     <p><code> встав( Дер, X, Д1, M2, Д2). % Дерево растет вглубь</code></p>
     <p><code>доб23( nil, X, л( X) ).</code></p>
     <empty-line/>
     <p><code>встав( л( А), X, л( А), X, л( X) ) :-</code></p>
     <p><code> больше( X, А).</code></p>
     <p><code>встав( л( А), X, л( X), А, л( А) ) :-</code></p>
     <p><code> больше( А, X).</code></p>
     <p><code>встав( в2( Д1, М, Д2), X, в2( НД1, М, Д2) ) :-</code></p>
     <p><code> больше( М, X),</code></p>
     <p><code> встав( Д1, X, НД1).</code></p>
     <p><code>встав( в2( Д1, М, Д2), X, в3( НД1а, Мб, НД1б, М, Д2) ) :-</code></p>
     <p><code> больше( М, X),</code></p>
     <p><code> встав( Д1, X, НД1а, Мб, НД1б).</code></p>
     <p><code>встав( в2( Д1, М, Д2), X, в2( Д1, М, НД2) ) :-</code></p>
     <p><code> больше( X, М),</code></p>
     <p><code> встав( Д2, X, НД2).</code></p>
     <p><code>встав( в2( Д1, М, Д2), X, в3( Д1, М, НД2а, Мб, НД2б) ) :-</code></p>
     <p><code> больше( X, М),</code></p>
     <p><code> встав( Д2, X, НД2а, Мб, НД2б).</code></p>
     <p><code>встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code> в3( НД1, M2, Д2, М3, Д3) :-</code></p>
     <p><code> больше( M2, X),</code></p>
     <p><code> встав( Д1, X, НД1).</code></p>
     <p><code>встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code> в2( НД1а, Мб, НД1б), M2, в2( Д2, М3, Д3) ) :-</code></p>
     <p><code> больше( M2, X),</code></p>
     <p><code> встав( Д1, X, НД1а, Мб, НД1б).</code></p>
     <p><code>встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code> в3( Д1, M2, НД2, М3, Д3) ) :-</code></p>
     <p><code> больше( X, M2), больше( М3, X),</code></p>
     <p><code> встав( Д2, X, НД2).</code></p>
     <p><code>встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code> в2( Д1, M2, НД2а), Мб, в2( НД2б, М3, Д3) ) :-</code></p>
     <p><code> больше( X, M2), больше( М3, X),</code></p>
     <p><code> встав( Д2, X, НД2а, Мб, НД2б).</code></p>
     <p><code>встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code> в3( Д1, M2, Д2, М3, НД3) ) :-</code></p>
     <p><code> больше( X, М3),</code></p>
     <p><code> встав( Д3, X, НД3).</code></p>
     <p><code>встав( в3( Д1, M2, Д2, М3, Д3), X,</code></p>
     <p><code> в2( Д1, M2, Д2), М3, в2( НД3а, Мб, НД3б) ) :-</code></p>
     <p><code> больше( X, М3),</code></p>
     <p><code> встав( Д3, X, НД3а, Мб, НД3б).</code></p>
     <p><strong>Рис. 10.6.</strong> Вставление элемента в 2-3 справочник. В этой программе предусмотрено, что попытка повторного вставления элемента терпит неудачу.</p>
     <empty-line/>
     <p>Программа для вставления нового элемента в 2-3 справочник показана полностью на рис. 10.6. На рис. 10.7 показана программа вывода на печать 2-3 деревьев.</p>
     <p>Наша программа иногда выполняет лишние возвраты. Так, если <code>встав</code> с тремя аргументами терпит неудачу, то вызывается процедура <code>встав</code> с пятью аргументами, которая часть работы делает повторно. Можно устранить источник неэффективности, если, например, переопределить <code>встав</code> как</p>
     <p><code>встав2( Дер, X, Деревья)</code></p>
     <p>где <code>Деревья</code> — список, состоящий либо из одного, либо из трех аргументов:</p>
     <p> <code>Деревья = [ НовДер]</code><strong>, </strong>если <code>встав( Дер, X, НовДер)</code></p>
     <p><code>Деревья = [ НДа, Мб, НДб]</code>, </p>
     <p> если <code>встав( Дер, X, НДа, Мб, НДб)</code></p>
     <p>Теперь отношение <code>доб23</code> можно переопределить так:</p>
     <p><code>доб23( Д, X, Д1) :-</code></p>
     <p><code> встав( Д, X, Деревья),</code></p>
     <p><code> соединить( Деревья, Д1).</code></p>
     <p>Отношение <code>соединить</code> формирует одно дерево Д1 из деревьев, находящихся в списке <code>Деревья</code>.</p>
     <empty-line/>
     <p><code>% Отображение 2-3 справочников</code></p>
     <p><code>отобр(Д) :- </code></p>
     <p><code> отобр( Д, 0).</code></p>
     <p><code>отобр( nil, _ ).</code></p>
     <p><code>отобр( л(А), H) :-</code></p>
     <p><code> tab( H), write( A), nl.</code></p>
     <p><code>отобр( в2( Д1, М, Д2), H) :-</code></p>
     <p><code> H1 is H + 5,</code></p>
     <p><code> отобр( Д2, H1),</code></p>
     <p><code> tab( H), write( --), nl,</code></p>
     <p><code> tab( H), write( M), nl,</code></p>
     <p><code> tab( H), write( --), nl,</code></p>
     <p><code> отобр( Д1, H1).</code></p>
     <p><code>отобр( в3( Д1, M2, Д2, М3, Д3), H) :-</code></p>
     <p><code> H1 is H + 5</code></p>
     <p><code> отобр( Д3, H1),</code></p>
     <p><code> tab( H), write( --), nl,</code></p>
     <p><code> tab( H), write( M3), nl,</code></p>
     <p><code> отобр( Д2, H1),</code></p>
     <p><code> tab( H), write( M2), nl,</code></p>
     <p><code> tab( H), write( --), nl,</code></p>
     <p><code> отобр( Д1, H1).</code></p>
     <p>(a)</p>
     <p><code>      15</code></p>
     <p><code>    --</code></p>
     <p><code>    15</code></p>
     <p><code>    --</code></p>
     <p><code>      13</code></p>
     <p><code>  --</code></p>
     <p><code>  13</code></p>
     <p><code>  --</code></p>
     <p><code>      12</code></p>
     <p><code>    --</code></p>
     <p><code>    12</code></p>
     <p><code>      10</code></p>
     <p><code>    10</code></p>
     <p><code>    --</code></p>
     <p><code>       8</code></p>
     <p><code>--</code></p>
     <p><code> 8</code></p>
     <p><code>--</code></p>
     <p><code>       7</code></p>
     <p><code>    --</code></p>
     <p><code>     7</code></p>
     <p><code><code>    --</code></code></p>
     <p><code>  --</code></p>
     <p><code>   5</code></p>
     <p><code>  --</code></p>
     <p><code>       4</code></p>
     <p><code>    --</code></p>
     <p><code>     4</code></p>
     <p><code>       3</code></p>
     <p><code>     3</code></p>
     <p><code>    --</code></p>
     <p><code>       1</code></p>
    </section>
    <section>
     <title>
      <p>10.2. AVL-дерево: приближенно сбалансированное дерево</p>
     </title>
     <p>AVL-дерево — это дерево, обладающее следующими свойствами:</p>
     <p>(1) Левое и правое поддеревья отличаются по глубине не более чем на 1.</p>
     <p>(2) Оба поддерева являются AVL-деревьями.</p>
     <p>Деревья, удовлетворяющие этому определению, могут быть слегка разбалансированными. Однако можно показать, что даже в худшем случае глубина AVL-дерева примерно пропорциональна log <emphasis>n</emphasis>, где <emphasis>n</emphasis> — число вершин дерева. Таким образом гарантируется логарифмический порядок производительности операций <code>внутри</code>, <code>добавить</code> и <code>удалить</code>.</p>
     <p>Операции над AVL-деревом работают по существу так же, как и над двоичным справочником. В них только сделаны добавления, связанные с поддержанием приближенной сбалансированности дерева. Если после вставления или удаления дерево перестает быть приближенно сбалансированным, то специальные механизмы возвращают ему требуемую степень сбалансированности. Для того, чтобы эффективно реализовать этот механизм, нам придется сохранять некоторую дополнительную информацию относительно степени сбалансированности дерева. На самом деле, нам нужно знать только разность между глубинами поддеревьев, которая может принимать значения -1, 0 или +1. Тем не менее для простоты мы предпочтем сохранять сами величины глубин поддеревьев, а не разности между ними.</p>
     <p>Мы определим отношение вставления элемента как</p>
     <p><code>доб_avl( Дер, X, НовДер)</code></p>
     <p>где оба дерева <code>Дер</code> и <code>НовДер</code> — это AVL-деревья, причем <code>НовДер</code> получено из <code>Дер</code> вставлением элемента <code>X</code>. AVL-деревья будем представлять как термы вида</p>
     <p><code>д( Лев, А, Прав)/Глуб</code></p>
     <p>где <code>А</code> — корень, <code>Лев</code> и <code>Прав</code> — поддеревья, а <code>Глуб</code> — глубина дерева. Пустое дерево изображается как <code>nil/0</code>. Теперь рассмотрим вставление элемента X в непустой AVL-справочник</p>
     <p><code>Дер = д( L, A, R)/H</code></p>
     <image l:href="#_70.png"/>
     <p><strong>Рис. 10.8.</strong> Задача вставления элемента в AVL-справочник (a) AVL-дерево перед вставлением X, X &gt; А; (b) AVL-дерево после вставления X в R; (с) составные части, из которых следует построить новое дерево.</p>
     <p>Начнем со случая, когда X больше А. X необходимо вставить в R, поэтому имеем следующее отношение:</p>
     <p><code>доб_аv1( R, X, д( R1, В, R2)/Hb)</code></p>
     <p>На рис. 10.8 показаны составные части, из которых строится дерево <code>НовДер</code>:</p>
     <p><code>L, А, R1, В, R2</code></p>
     <p>Какова глубина деревьев L, R, R1 и R2?  L и R могут отличаться по глубине не более, чем на 1. На рис. 10.8 видно, какую глубину могут иметь R1 и R2. Поскольку в R был добавлен только один элемент X, только одно из поддеревьев R1, R2 может иметь глубину h+1.</p>
     <image l:href="#_71.png"/>
     <p><strong>Рис. 10.9.</strong> Три правила построения нового AVL-дepевa.</p>
     <p>В случае, когда X меньше, чем А, имеем аналогичную ситуацию, причем левое и правое поддеревья меняются местами. Таким образом, в любом случае мы должны построить дерево <code>НовДер</code>, используя три дерева (назовем их <code>Дер1</code>, <code>Дер2</code> и <code>Дер3</code>) и два отдельных элемента А и В. Теперь рассмотрим вопрос: как соединить между собой эти пять составных частей, чтобы дерево <code>НовДер</code> было AVL-справочником? Ясно, что они должны располагаться внутри <code>НовДер</code> в следующем порядке (слева направо):</p>
     <p><code>Дер1, А, Дер2, В, Дер3</code></p>
     <p>Рассмотрим три случая:</p>
     <p>(1) Среднее дерево <code>Дер2</code> глубже остальных двух деревьев.</p>
     <p>(2) <code>Дер1</code> имеет глубину не меньше, чем <code>Дер2</code> и <code>Дер3</code>.</p>
     <p>(3) <code>Дер3</code> имеет глубину не меньше, чем <code>Дер2</code> и <code>Дер1</code>.</p>
     <p>На рис. 10.9 видно, как можно построить дерево <code>НовДер</code> в каждом из этих трех случаев. Например, в случае 1 среднее дерево <code>Дер2</code> следует разбить на два части, а затем включить их в состав <code>НовДер</code>. Три правила, показанные на pис.10.9, нетрудно запасать на Прологе в виде отношения</p>
     <p><code>соединить( Дер, А, Дер2, В, Дер3, НовДер)</code></p>
     <p>Последний аргумент <code>НовДер</code> — это AVL-дерево, построенное из пяти составных частей, пяти первых аргументов. Правило 1, например, принимает вид:</p>
     <p><code>соединить( Д1/Н1, А, д( Д21, В, Д22)/Н2, С, Д3/Н3,</code></p>
     <p><code>  % Пять частей</code></p>
     <p><code> д( д( Д1/Н1, А, Д21)/На, В, д( Д22, С, Д3/Н3)/Нс)/Нb) :-</code></p>
     <p><code>  % Результат</code></p>
     <p><code> H2 &gt; H1, H2 &gt; Н3, % Среднее дерево глубже остальных</code></p>
     <p><code> На is Н1 + 1,     % Глубина левого поддерева</code></p>
     <p><code> Нс is Н3 + 1,     % Глубина правого поддерева</code></p>
     <p><code> Hb is На + 1,     % Глубина всего дерева</code></p>
     <p>Программа <code>доб_аvl</code>, вычисляющая также глубину дерева и его поддеревьев, показана полностью на рис. 10.10.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>10.3.</strong> Определите отношение</p>
     <p><code>avl( Дер)</code></p>
     <p>для проверки того, является ли <code>Дер</code> AVL-деревом, т.е. верно ли, что любые два его поддерева, подсоединенные к одной и той же вершине, отличаются по глубине не более чем на 1. Двоичные деревья представляйте в виде термов <code>д( Лев, Кор, Прав) </code>или <code>nil</code><strong>.</strong></p>
     <empty-line/>
     <p><code>% Вставление элемента в AVL-справочник</code></p>
     <p><code>доб_аvl( nil/0, X, д( nil/0, X, nil/0)/1).</code></p>
     <p><code>  % Добавить X к пустому дереву</code></p>
     <p><code>доб_аvl( д( L, Y, R)/Ну, X, НовДер) :-</code></p>
     <p><code>  % Добавить X к непустому дереву</code></p>
     <p><code> больше( Y, X),</code></p>
     <p><code> доб_аvl( L, X, д( L1, Z, L2)/ _ ),</code></p>
     <p><code>  % Добавить к левому поддереву</code></p>
     <p><code> соединить( L1, Z, L2, Y, R, НовДер).</code></p>
     <p><code>  % Сформировать новое дерево</code></p>
     <p><code>доб_avl( д( L, Y, R)/Ну, X, НовДер) :-</code></p>
     <p><code> больше( X, Y),</code></p>
     <p><code> доб_avl( R, X, д( R1, Z, R2)/ _ ),</code></p>
     <p><code>  % Добавить к правому поддереву</code></p>
     <p><code> соединить( L1, Y, Rl, Z, R2, НовДер).</code></p>
     <empty-line/>
     <p><code>соединить( Д1/Н1, А, д( Д21, В, Д22)/Н2, С, Д3/Н3,</code></p>
     <p><code> д( д( Д1/Н1, А, Д21)/На, В, д( Д22, С, L3/Н3)/Нс)/Нb) :-</code></p>
     <p><code> Н2 &gt; H1, H2 &gt; Н3,     % Среднее дерево глубже остальных</code></p>
     <p><code> На is H1 + 1,</code></p>
     <p><code> Hс is Н3 + 1,</code></p>
     <p><code> Нb is На + 1.</code></p>
     <p><code>соединить( Д1/Н1, А, д( Д2/Н2, С, Д3/Н3,</code></p>
     <p><code> д( Д1/Н1, А, д( Д2/Н2, С, Д3/Н3)/Нс)/На) :-</code></p>
     <p><code> H1 &gt;= H2, H1 &gt;= Н3,   % "Глубокое" левое дерево</code></p>
     <p><code> max1( H2, Н3, Нс),</code></p>
     <p><code> max1( H1, Нс, На).</code></p>
     <p><code>соединить( Д1/Н1, А, Д2/Н2, С, Д3/Н3,</code></p>
     <p><code> д( д( Д1/Н1, А, Д2/Н2)/На, С, Д3/Н3)/Нс) :-</code></p>
     <p><code> Н3 &gt;= H2, Н3 &gt;= H1,   % "Глубокое" правое дерево</code></p>
     <p><code> max1( H1, H2, На),</code></p>
     <p><code> max1( На, Н3, Нс).</code></p>
     <empty-line/>
     <p><code>max1( U, V, М) :-</code></p>
     <p><code> U &gt; V, !, М is U + 1; % М равно 1 плюс max( U, V)</code></p>
     <p><code> М is V + 1.</code></p>
     <p><strong>Рис. 10.10.</strong> Вставление элемента в AVL-справочник. В этой программе предусмотрено, что попытка повторного вставления элемента терпит неудачу. По поводу процедуры <code>соединить</code> см. рис. 10.9.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• 2-3 деревья и AVL-деревья, представленные в настоящей главе, — это примеры <emphasis>сбалансированных</emphasis> деревьев.</p>
     <p>• Сбалансированные или приближенно сбалансированные деревья гарантируют эффективное выполнение трех основных операций над деревьями: поиск, добавление и удаление элемента. Время выполнения этих операций пропорционально log <emphasis>n</emphasis>, где <emphasis>n</emphasis> — число вершин дерева.</p>
     <subtitle>Литература</subtitle>
     <p>2-3 деревья детально описаны, например, в Aho, Hopcroft and Ullman (1974, 1983). В книге этих авторов, вышедшей в 1983 г., дается также реализация соответствующих алгоритмов на языке Паскаль. H.Вирт (см. Wirth (1976)) приводит программу на Паскале для работы с AVL-деревьями. 2-3 деревья являются частным случаем более общего понятия В-деревьев. В-деревья, а также несколько других вариантов структур данных, имеющих отношение к 2-3 деревьям в AVL-деревьям, рассматриваются в книге Gonnet (1984). В этой книге, кроме того, даны результаты анализа поведения этих структур.</p>
     <p>Программа вставления элемента в AVL-дерево, использующая только величину "перекоса" дерева (т.е. значение разности глубин поддеревьев, равной -1, 0 или 1, вместо самой глубины) опубликована ван Эмденом (1981).</p>
     <empty-line/>
     <p>Aho А. V., Hopcroft J. E. and Ullman J. D. (1974). <emphasis>The Design and Analysis of Computer Algorithms.</emphasis> Addison-Wesley. [Имеется перевод: Ахо А., Хопкрофт Дж. Построение и анализ вычислительных алгоритмов. Пер. с англ. — М.: Мир, 1979.]</p>
     <p>Aho А. V., Hopcroft J. E. and Ullman J. D. (1983). <emphasis>Data Structures and Algorithms.</emphasis> Addison-Wesley.</p>
     <p>Gonnet G. H. (1984). <emphasis>Handbook of Algorithms + Data Structures.</emphasis> Addison-Wesley.</p>
     <p>van Emden M. (1981). <emphasis>Logic Programming Newsletter 2.</emphasis></p>
     <p>Wirth N. (1976). <emphasis>Algorithms + Data Structures = Programs.</emphasis> Prentice-Hall. [Имеется перевод: Вирт H. Алгоритмы + структуры данных = программы. — M.: Мир, 1985.] </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 11.</p>
     <p>Основные стратегии решения задач</p>
    </title>
    <section>
     <p>В данной главе мы сосредоточим свое внимание на одной общей схеме для представления задач, называемой <emphasis>пространством состояний</emphasis>. Пространство состояний — это граф, вершины которого соответствуют ситуациям, встречающимся в задаче ("проблемные ситуации"), а решение задачи сводится к поиску пути в этом графе. Мы изучим на примерах, как формулируются задачи в терминах пространства состояний, а также обсудим общие методы решения задач, представленных в рамках этого формализма. Процесс решения задачи включает в себя поиск в графе, при этом, как правило, возникает проблема, как обрабатывать альтернативные пути поиска. В этой главе будут представлены две основные стратегии перебора альтернатив, а именно поиск в глубину и поиск в ширину.</p>
    </section>
    <section>
     <title>
      <p>11.1. Предварительные понятия и примеры</p>
     </title>
     <p>Рассмотрим пример, представленный на рис. 11.1. Задача состоит в выработке плана переупорядочивания кубиков, поставленных друг на друга, как показано на рисунке. На каждом шагу разрешается переставлять только один кубик. Кубик можно взять только тогда, когда его верхняя поверхность свободна. Кубик можно поставить либо на стол, либо на другой кубик. Для того, чтобы построить требуемый план, мы должны отыскать последовательность ходов, реализующую заданную трансформацию.</p>
     <p>Эту задачу можно представлять себе как задачу выбора среди множества возможных альтернатив. В исходной ситуации альтернатива всего одна: поставить кубик С на стол. После того как кубик С поставлен на стол, мы имеем три альтернативы:</p>
     <p>• поставить А на стол или</p>
     <p>• поставить А на С, или</p>
     <p>• поставить С на А.</p>
     <image l:href="#_72.png"/>
     <p><strong>Рис. 11.1.</strong> Задача перестановки кубиков.</p>
     <p>Ясно, что альтернативу "поставить С на стол" не имело смысла рассматривать всерьез, так как этот ход никак не влияет на ситуацию.</p>
     <p>Как показывает рассмотренный пример, с задачами такого рода связано два типа понятий:</p>
     <p>(1) Проблемные ситуации.</p>
     <p>(2) Разрешенные ходы или действия, преобразующие одни проблемные ситуации в другие.</p>
     <p>Проблемные ситуации вместе с возможными ходами образуют направленный граф, называемый <emphasis>пространством состояний</emphasis>. Пространство состояний для только что рассмотренного примера дано на рис. 11.2. Вершины графа соответствуют проблемным ситуациям, дуги — разрешенным переходам из одних состояний в другие. Задача отыскания плана решения задачи эквивалентна задаче построения пути между заданной начальной ситуацией ("стартовой" вершиной) и некоторой указанной заранее конечной ситуацией, называемой также <emphasis>целевой вершиной</emphasis>.</p>
     <p>На рис. 11.3 показан еще один пример задачи: головоломка "игра в восемь" в ее представление в виде задачи поиска пути. В головоломке используется восемь перемещаемых фишек, пронумерованных цифрами от 1 до 8. Фишки располагаются в девяти ячейках, образующих матрицу 3 на 3. Одна из ячеек всегда пуста, и любая смежная с ней фишка может быть передвинута в эту пустую ячейку. Можно сказать и по-другому, что пустой ячейке разрешается перемещаться, меняясь местами с любой из смежных с ней фишек. Конечная ситуация — это некоторая заранее заданная конфигурация фишек, как показано на рис. 11.3.</p>
     <image l:href="#_73.png"/>
     <p><strong>Рис. 11.2.</strong> Графическое представление задачи манипулирования кубиками. Выделенный путь является решением задачи рис. 11.1.</p>
     <p>Нетрудно построить аналогичное представление в виде графа и для других популярных головоломок. Наиболее очевидные примеры — это задача о "ханойской башне" и задача о перевозке через реку волка, козы и капусты. Во второй из этих задач предполагается, что вместе с человекам в лодке помещается только один объект и что человеку приходится охранять козу от волка и капусту от козы. С описанной парадигмой согласуются также многие задачи, имеющие практическое значение. Среди них — задача о коммивояжере, которая может служить моделью для многих практических оптимизационных задач. В задаче дается карта с <emphasis>n</emphasis> городами в указываются расстояния, которые надо преодолеть по дорогам при переезде из города в город. Необходимо найти маршрут, начинающийся в некотором городе, проходящий через все города и заканчивающиеся в том же городе. Ни один город, за исключением начального, не разрешается посещать дважды.</p>
     <image l:href="#_74.png"/>
     <p><strong>Рис. 11.3.</strong> "Игра в восемь" и ее представление в форме графа.</p>
     <p>Давайте подытожим те понятия, которые мы ввели, рассматривая примеры. Пространство состояний некоторой задачи определяет "правила игры": вершины пространства состояния соответствуют ситуациям, а дуги — разрешенным ходам или действиям, или шагам решения задачи. Конкретная задача определяется</p>
     <p>• пространством состояний</p>
     <p>• стартовой вершиной</p>
     <p>• целевым условием (т.е. условием, к достижению которого следует стремиться); "целевые вершины" — это вершины, удовлетворяющие этим условиям.</p>
     <p>Каждому разрешенному ходу или действию можно приписать его стоимость. Например, в задаче манипуляции кубиками стоимости, приписанные тем или иным перемещениям кубиков, будут указывать нам на то, что некоторые кубики перемещать труднее, чем другие. В задаче о коммивояжере ходы соответствуют переездам из города в город. Ясно, что в данном случае стоимость хода — это расстояние между соответствующими городами.</p>
     <p>В тех случаях, когда каждый ход имеет стоимость, мы заинтересованы в отыскании решения минимальной стоимости. Стоимость решения — это сумма стоимостей дуг, из которых состоит "решающий путь" — путь из стартовой вершины в целевую. Даже если стоимости не заданы, все равно может возникнуть оптимизационная задача: нас может интересовать кратчайшее решение.</p>
     <p>Прежде тем будут рассмотрены некоторые программы, реализующие классический алгоритм поиска в пространстве состоянии, давайте сначала обсудим. как пространство состояний может быть представлено в прологовской программе.</p>
     <p>Мы будем представлять пространство состояний при помощи отношения</p>
     <p><code>после( X, Y)</code></p>
     <p>которое истинно тогда, когда в пространстве состояний существует разрешенный ход из вершины X в вершину Y. Будем говорить, что Y — это <emphasis>преемник</emphasis> вершины X. Если с ходами связаны их стоимости, мы добавим третий аргумент, стоимость хода:</p>
     <p><code>после( X, Y, Ст)</code></p>
     <p>Эти отношения можно задавать в программе явным образом при помощи набора соответствующих фактов. Однако такой принцип оказывается непрактичным и нереальным для тех типичных случаев, когда пространство состояний устроено достаточно сложно. Поэтому отношение следования <code>после</code> обычно определяется неявно, при помощи правил вычисления вершин-преемников некоторой заданной вершины. Другим вопросом, представляющим интерес с самой общей точки зрения, является вопрос о способе представления состояний, т.е. самих вершин. Это представление должно быть компактным, но в то же время оно должно обеспечивать эффективное выполнение необходимых операций, в частности операции вычисления вершин-преемников, а возможно и стоимостей соответствующих ходов.</p>
     <p>Рассмотрим в качестве примера задачу манипулирования кубиками, проиллюстрированную на рис. 11.1. Мы будем рассматривать более общий случай, когда имеется произвольное число кубиков, из которых составлены столбики, — один или несколько. Число столбиков мы ограничим некоторым максимальным числом, чтобы задача была интереснее. Такое ограничение, кроме того, является вполне реальным, поскольку рабочее пространство, которым располагает робот, манипулирующий кубиками, ограничено.</p>
     <p>Проблемную ситуацию можно представить как список столбиков. Каждый столбик в свою очередь представляется списком кубиков, из которых он составлен. Кубики упорядочены в списке таким образом, что самый верхний кубик находится в голове списка. "Пустые" столбики изображаются как пустые списки. Таким образом, исходную ситуацию рис. 11.1 можно записать как терм</p>
     <p><code>[ [с, а, b], [], [] ]</code></p>
     <p>Целевая ситуация — это любая конфигурация кубиков, содержащая, столбик, составленный из всех имеющихся кубиков в указанном порядке. Таких ситуаций три:</p>
     <p><code>[ [a, b, c], [], [] ]</code></p>
     <p><code>[ [], [а, b, с], [] ]</code></p>
     <p><code>[ [], [], [a, b, c] ]</code></p>
     <p>Отношение следования можно запрограммировать, исходя из следующего правила: ситуация <code>Сит2</code> есть преемник ситуации <code>Сит1</code>, если в <code>Сит1</code> имеется два столбика <code>Столб1</code> и <code>Столб2</code>, такие, что верхний кубик из <code>Столб1</code> можно поставить сверху на <code>Столб2</code> и получить тем самым <code>Сит2</code>. Поскольку все ситуации - это списки столбиков, правило транслируется на Пролог так:</p>
     <p><code>после( Столбы, [Столб1, [Верх1 | Столб2], Остальные]) :-</code></p>
     <p><code>  % Переставить Верх1 на Столб2</code></p>
     <p><code> удалить( [Верх1 | Столб1], Столб1, Столб1),</code></p>
     <p><code>  % Найти первый столбик</code></p>
     <p><code> удалить( Столб2, Столбы1, Остальные).</code></p>
     <p><code>  % Найти второй столбик</code></p>
     <empty-line/>
     <p><code>удалить( X, [X | L], L).</code></p>
     <p><code>удалить( X, [Y | L], [Y | L1] ) :-</code></p>
     <p><code> удалить( L, X, L1).</code></p>
     <p>В нашем примере целевое условие имеет вид:</p>
     <p><code>цель( Ситуация) :-</code></p>
     <p><code> принадлежит [а,b,с], Ситуация)</code></p>
     <p>Алгоритм поиска мы запрограммируем как отношение</p>
     <p><code>решить( Старт, Решение)</code></p>
     <p>где <code>Старт</code> — стартовая вершина пространства состояний, а <code>Решение</code> — путь, ведущий из вершины <code>Старт</code> в любую целевую вершину. Для нашего конкретного примера обращение к пролог-системе имеет вид:</p>
     <p><code>?- решить( [ [с, а, b], [], [] ], Решение).</code></p>
     <p>В результате успешного поиска переменная <code>Решение</code> конкретизируется и превращается в список конфигураций кубиков. Этот список представляет собой план преобразования исходного состояния в состояние, в котором все три кубика поставлены друг на друга в указанном порядке <code>[а, b, с]</code>.</p>
    </section>
    <section>
     <title>
      <p>11.2. Стратегия поиска в глубину</p>
     </title>
     <p>Существует много различных подходов к проблеме поиска решающего пути для задач, сформулированных в терминах пространства состояний. Основные две стратегии поиска — это поиск <emphasis>в глубину</emphasis> и <emphasis>поиск в ширину</emphasis>. В настоящем разделе мы реализуем первую из них.</p>
     <p>Мы начнем разработку алгоритма и его вариантов со следующей простой идеи:</p>
     <cite>
      <p>Для того, чтобы найти решающий путь <code>Реш</code> из заданной вершины <code>В</code> в некоторую целевую вершину, необходимо:</p>
      <p>• если <code>В</code> — это целевая вершина, то положить <code>Реш = [В]</code>, или</p>
      <p>• если для исходной вершины <code>В</code> существует вершина-преемник <code>В1</code>, такая, что можно провести путь <code>Реш1</code> из <code>В1</code> в целевую вершину, то положить <code>Реш = [В | Peш1]</code>.</p>
     </cite>
     <image l:href="#_75.png"/>
     <p><strong>Рис. 11.4.</strong> Пример простого пространства состояний: <emphasis>а</emphasis> — стартовая вершина,<emphasis> f</emphasis> и<emphasis> j</emphasis> — целевые вершины. Порядок, в которой происходит проход по вершинам пространства состояний при поиске в глубину: <emphasis>а</emphasis>, <emphasis>b</emphasis>, <emphasis>d</emphasis>, <emphasis>h</emphasis>, <emphasis>e</emphasis>,<emphasis> i</emphasis>, <emphasis>j</emphasis>. Найдено решение <code>[a, b, e, j]</code>. После возврата обнаружено другое решение: <code>[а, с, f]</code>.</p>
     <p>На Пролог это правило транслируется так:</p>
     <p><code>решить( В, [В] ) :-</code></p>
     <p><code> цель( В).</code></p>
     <p><code>решить( В, [В | Реш1] ) :-</code></p>
     <p><code> после( В, В1 ),</code></p>
     <p><code> решить( В1, Реш1).</code></p>
     <p>Эта программа и есть реализация поиска в глубину. Мы говорим "в глубину", имея в виду тот порядок, в котором рассматриваются альтернативы в пространстве состояний. Всегда, когда алгоритму поиска в глубину надлежит выбрать из нескольких вершин ту, в которую следует перейти для продолжения поиска, он предпочитает самую "глубокую" из них. Самая глубокая вершина — это вершина, расположенная дальше других от стартовой вершины. На рис. 11.4 мы видим на примере, в каком порядке алгоритм проходит по вершинам. Этот порядок в точности соответствует результату трассировки процесса вычислений в пролог-системе при ответе на вопрос</p>
     <p><code>?- решить( а, Реш).</code></p>
     <p>Поиск в глубину наиболее адекватен рекурсивному стилю программирования, принятому в Прологе. Причина этого состоит в том, что, обрабатывая цели, пролог-система сама просматривает альтернативы именно в глубину.</p>
     <p>Поиск в глубину прост, его легко программировать и он в некоторых случаях хорошо работает. Программа для решения задачи о восьми ферзях (см. гл. 4) фактически была примером поиска в глубину. Для того, чтобы можно было применить к этой задаче описанную выше процедуру <code>решить</code>, необходимо сформулировать задачу в терминах пространства состояний. Это можно сделать так:</p>
     <p>• вершины пространства состояний — позиции, в которых поставлено 0 или более ферзей на нескольких последовательно расположенных горизонтальных линиях доски;</p>
     <p>• вершина-преемник данной вершины может быть получена из нее после того, как в соответствующей позиции на следующую горизонтальную линию доски будет поставлен еще один ферзь, причем таким образом, чтобы ни один из уже поставленных ферзей не оказался под боем;</p>
     <p>• стартовая вершина — пустая доска (представляется пустым списком);</p>
     <p>• целевая вершина — любая позиция с восемью ферзями (правило получения вершины-преемника гарантирует, что ферзи не бьют друг друга).</p>
     <p>Позицию на доске будем представлять как список Y-координат поставленных ферзей. Получаем программу:</p>
     <p><code>после( Ферзи, [Ферзь | Ферзи] ) :-</code></p>
     <p><code> принадлежит( Ферзь, [1, 2, 3, 4, 5, 6, 7, 8] ),</code></p>
     <p><code>  % Поместить ферзя на любую вертикальную линию</code></p>
     <p><code> небьет( Ферзь, Ферзи).</code></p>
     <empty-line/>
     <p><code>цель( [ _, _, _, _, _, _, _, _ ] )</code></p>
     <p><code> % Позиция с восемью ферзями</code></p>
     <p>Отношение <code>небьет</code> означает, что <code>Ферзь</code> не может поразить ни одного ферзя из списка <code>Ферзи</code>. Эту процедуру можно легко запрограммировать так же, как это сделано в гл. 4. Ответ на вопрос</p>
     <p><code>?- решить( [], Решение)</code></p>
     <p>будет выглядеть как список позиций с постепенно увеличивающимся количеством поставленных ферзей. Список завершается "безопасной" конфигурацией из восьми ферзей. Механизм возвратов позволит получить и другие решения задачи.</p>
     <p>Поиск в глубину часто работает хорошо, как в рассмотренном примере, однако наша простая процедура <code>решить</code> может попасть в затруднительное положение, причем многими способами. Случится ли это или нет — зависит от структуры пространства состояний. Для того, чтобы затруднить работу процедуры решить в примере рис. 11.4, достаточно внести в задачу совсем небольшое изменение: добавить дугу, ведущую из <emphasis>h </emphasis>в <emphasis>d</emphasis>, чтобы получился цикл (рис. 11.5). В этом случае поиск будет выглядеть так: начиная с вершины <emphasis>а</emphasis>, спускаемся вплоть до <emphasis>h</emphasis>, придерживаясь самой левой ветви графа. На этот раз, в отличие от рис. 11.4, у вершины <emphasis>h </emphasis>будет преемник <emphasis>d</emphasis>. Поэтому произойдет <emphasis>не возврат</emphasis> из <emphasis>h</emphasis>, а <emphasis>переход</emphasis> к <emphasis>d</emphasis>. Затем мы найдем преемника вершины <emphasis>d</emphasis>, т.е. вершину <emphasis>h</emphasis>, и т.д., в результате программа зациклится между <emphasis>h</emphasis> и <emphasis>d</emphasis>.</p>
     <image l:href="#_76.png"/>
     <p><strong>Рис. 11.5.</strong> Начинаясь в <emphasis>а</emphasis>, поиск в глубину заканчивается бесконечным циклом между <emphasis>d</emphasis> и <emphasis>h</emphasis>: <emphasis>a</emphasis>, <emphasis>b</emphasis>, <emphasis>d</emphasis>, <emphasis>h</emphasis>, <emphasis>d</emphasis>, <emphasis>h</emphasis>, <emphasis>d</emphasis> ….</p>
     <p>Очевидное усовершенствование нашей программы поиска в глубину — добавление к ней механизма обнаружения циклов. Ни одну из вершин, уже содержащихся в пути, построенном из стартовой вершины в текущую вершину, не следует вторично рассматривать в качестве возможной альтернативы продолжения поиска. Это правило можно сформулировать в виде отношения</p>
     <p><code>вглубину( Путь, Верш, Решение)</code></p>
     <p>Как видно из рис. 11.6, <code>Верш</code> — это состояние, из которого необходимо найти путь до цели; <code>Путь</code> — путь (список вершин) между стартовой вершиной и <code>Верш</code>; <code>Решение</code> — <code>Путь</code>, продолженный до целевой вершины.</p>
     <image l:href="#_77.png"/>
     <p><strong>Рис. 11.6.</strong> Отношение <code>вглубину( Путь, В, Решение)</code>.</p>
     <p>Для облегчения программирования вершины в списках, представляющих пути, будут расставляться в обратном порядке. Аргумент <code>Путь</code> нужен для того,</p>
     <p>(1) чтобы не рассматривать тех преемников вершины <code>Верш</code>, которые уже встречались раньше (обнаружение циклов);</p>
     <p>(2) чтобы облегчить построение решающего пути <code>Решение</code>. Соответствующая программа поиска в глубину показана на рис. 11.7.</p>
     <empty-line/>
     <p><code>решить( Верш, Решение) :-</code></p>
     <p><code> вглубину( [], Верш, Решение).</code></p>
     <empty-line/>
     <p><code>вглубину( Путь, Верш, [Верш | Путь] ) :-</code></p>
     <p><code> цель( Верш).</code></p>
     <p><code>вглубину( Путь, Верш, Реш) :-</code></p>
     <p><code> после( Верш, Верш1),</code></p>
     <p><code> not принадлежит( Верш1, Путь), % Цикл?</code></p>
     <p><code> вглубину( [Верш | Путь], Верш1, Реш).</code></p>
     <p><strong>Рис. 11.7.</strong> Программа поиска в глубину без зацикливания.</p>
     <empty-line/>
     <p>Теперь наметим один вариант этой программы. Аргументы <code>Путь</code> и <code>Верш</code> процедуры <code>вглубину</code> можно объединить в один список <code>[Верш | Путь]</code>. Тогда, вместо вершины-кандидата <code>Верш</code>, претендующей на то, что она находится на пути, ведущем к цели, мы будем иметь <emphasis>путь</emphasis>-кандидат <code>П = [Верш | Путь]</code>, который претендует на то, что его можно продолжить вплоть до целевой вершины. Программирование соответствующего предиката</p>
     <p><code>вглубину( П, Решение)</code></p>
     <p>оставим читателю в качестве упражнения.</p>
     <p>Наша процедура поиска в глубину, снабженная механизмом обнаружения циклов, будет успешно находить решающие пути в пространствах состояний, подобных показанному на рис. 11.5. Существуют, однако, такие пространства состоянии, в которых наша процедура не дойдет до цели. Дело в том, что многие пространства состояний бесконечны. В таком пространстве алгоритм поиска в глубину может "потерять" цель, двигаясь вдоль бесконечной ветви графа. Программа будет бесконечно долго обследовать эту бесконечную область пространства, так и не приблизившись к цели. Пространство состояний задачи о восьми ферзях, определенное так, как это сделано в настоящем разделе, на первый взгляд содержит ловушку именно такого рода. Но оказывается, что оно все-таки конечно, поскольку Y-координаты выбираются из ограниченного множества, и поэтому на доску можно поставить "безопасным образом" не более восьми ферзей.</p>
     <empty-line/>
     <p><code>вглубину2( Верш, [Верш], _ ) :-</code></p>
     <p><code> цель( Верш).</code></p>
     <p><code>вглубину2( Верш, [Верш | Реш], МаксГлуб) :-</code></p>
     <p><code> МаксГлуб &gt; 0,</code></p>
     <p><code> после( Верш, Верш1),</code></p>
     <p><code> Maкс1 is МаксГлуб - 1,</code></p>
     <p><code> вглубину2( Верш1, Реш, Maкс1).</code></p>
     <p><strong>Рис. 11.8.</strong> Программа поиска в глубину с ограничением по глубине.</p>
     <empty-line/>
     <p>Для того, чтобы предотвратить бесцельное блуждание по бесконечным ветвям, мы можем добавить в базовую процедуру поиска в глубину еще одно усовершенствование, а именно, ввести ограничение на глубину поиска. Процедура поиска в глубину будет тогда иметь следующие аргументы:</p>
     <p><code>вглубину2( Верш, Решение, МаксГлуб)</code></p>
     <p>Не разрешается вести поиск на глубине большей, чем <code>МаксГлуб</code>. Программная реализация этого ограничения сводится к уменьшению на единицу величины предела глубины при каждом рекурсивном обращений к <code>вглубину2</code> и к проверке, что этот предел не стал отрицательным. В результате получаем программу, показанную на рис. 11.8.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>11.1.</strong> Напишите процедуру поиска в глубину (с обнаружением циклов)</p>
     <p><code>вглубину1( ПутьКандидат, Решение)</code></p>
     <p>отыскивающую решающий путь <code>Решение</code> как продолжение пути <code>ПутьКандидат</code>. Оба пути представляйте списками вершин, расположенных в обратном порядке так, что целевая вершина окажется в голове списка <code>Решение</code>.</p>
     <p><strong>11.2.</strong> Напишите процедуру поиска в глубину, сочетающую в себе обнаружение циклов с ограничением глубины, используя рис. 11.7 и 11.8.</p>
     <p><strong>11.3.</strong> Проведите эксперимент по применению программы поиска в глубину к задаче планирования в "мире кубиков" (рис. 11.1).</p>
     <p><strong>11.4.</strong> Напишите процедуру</p>
     <p><code>отобр( Ситуация)</code></p>
     <p>для отображения состояния задачи "перестановки кубиков". Пусть <code>Ситуация</code> — это список столбиков, а столбик, в свою очередь, — список кубиков. Цель</p>
     <p><code>отобр( [ [a], [e, d], [с, b] ] )</code></p>
     <p>должна отпечатать соответствующую ситуацию, например так:</p>
     <p><code>      e      с</code></p>
     <p><code>a     d      b</code></p>
     <p><code>==============</code></p>
    </section>
    <section>
     <title>
      <p>11.3. Поиск в ширину</p>
     </title>
     <section>
      <p>В противоположность поиску в глубину стратегия поиска в ширину предусматривает переход в первую очередь к вершинам, ближайший к стартовой вершине. В результате процесс поиска имеет тенденцию развиваться более в ширину, чем в глубину, что иллюстрирует рис. 11.9.</p>
      <image l:href="#_78.png"/>
      <p><strong>Рис. 11.9.</strong> Простое пространство состояний: а — стартовая вершина, f и j — целевые вершины. Применение стратегии поиска в ширину дает следующий порядок прохода по вершинам: а, b, c, d, e, f. Более короткое решение <code>[a, c, f]</code> найдено раньше, чем более длинное <code>[а, b, e, j]</code></p>
      <p>Поиск в ширину программируется не так легко, как поиск в глубину. Причина состоят в том, что нам приходится сохранять все множество альтернативных вершин-кандидатов, а не только одну вершину, как при поиске в глубину. Более того, если мы желаем получить при помощи процесса поиска решающий путь, то одного множества вершин недостаточно. Поэтому мы будем хранить не множество вершин-кандидатов, а множество <emphasis>путей</emphasis>-кандидатов. Таким образом, цель</p>
      <p><code>вширину( Пути, Решения)</code></p>
      <p>истинна только тогда, когда существует путь из множества кандидатов <code>Пути</code>, который может быть продолжен вплоть до целевой вершины. Этот продолженный путь и есть <code>Решение</code>.</p>
     </section>
     <section>
      <title>
       <p>11.3.1. Списковое представление множества кандидатов</p>
      </title>
      <p>В нашей первой реализации этой идеи мы будем использовать следующее представление для множества путей-кандидатов. Само множество будет списком путей, а каждый путь - списком вершин, перечисленных в обратном порядке, т.е. головой списка будет самая последняя из порожденных вершин, а последним элементом списка будет стартовая вершина. Поиск начинается с одноэлементного множества кандидатов</p>
      <p><code>[ [СтартВерш] ]</code></p>
      <empty-line/>
      <p><code>решить( Старт, Решение) :-</code></p>
      <p><code> вширину( [ [Старт] ], Решение).</code></p>
      <empty-line/>
      <p><code>вширину( [ [Верш | Путь] | _ ], [Верш | Путь] ) :-</code></p>
      <p><code> цель( Верш).</code></p>
      <p><code>вширину( [ [В | Путь] | Пути], Решение ) :-</code></p>
      <p><code> bagof( [B1, В | Путь ],</code></p>
      <p><code> ( после( В, В1), not принадлежит( В1, [В | Путь])),</code></p>
      <p><code>   НовПути),</code></p>
      <p><code>    % НовПути - ациклические продолжения пути [В | Путь]</code></p>
      <p><code> конк( Пути, НовПути, Пути1), !,</code></p>
      <p><code> вширину( Путь1, Решение);</code></p>
      <p><code> вширину( Пути, Решение).</code></p>
      <p><code>  % Случай, когда у В нет преемника</code></p>
      <p><strong>Рис. 11.10.</strong> Реализации поиска в ширину.</p>
      <p>Общие принципы поиска в ширину таковы:</p>
      <p>Для того, чтобы выполнить поиск в ширину при заданном множестве путей-кандидатов, нужно:</p>
      <p>• если голова первого пути — это целевая вершина, то взять этот путь в качестве решения, иначе</p>
      <p>• удалить первый путь из множества кандидатов и породить множество всех возможных продолжений этого пути на один шаг; множество продолжений добавить в конец множества кандидатов, а затем выполнить поиск в ширину с полученным новым множеством.</p>
      <empty-line/>
      <p><code>решить( Старт, Решение) :-</code></p>
      <p><code> вширь( [ [Старт] | Z ]-Z, Решение).</code></p>
      <empty-line/>
      <p><code>вширь( [ [Верш | Путь] | _ ]-_, [Верш | Путь] ) :-</code></p>
      <p><code> цель( Верш).</code></p>
      <p><code>вширь( [ [В | Путь] | Пути]-Z, Решение ) :-</code></p>
      <p><code> bagof( [B1, В | Путь ],</code></p>
      <p><code> ( после( В, В1),</code></p>
      <p><code>   not принадлежит( В1, [В | Путь]) ),</code></p>
      <p><code>   Нов ),</code></p>
      <p><code> конк( Нов, ZZ, Z), !,</code></p>
      <p><code> вширь( Пути-ZZ, Решение);</code></p>
      <p><code> Пути \== Z, % Множество кандидатов не пусто</code></p>
      <p><code> вширь( Пути-Z, Решение).</code></p>
      <p><strong>Рис. 11.11.</strong> Программа поиска в ширину более эффективная, чем программа рис. 11.10. Усовершенствование основано на разностном представлении списка путей-кандидатов.</p>
      <empty-line/>
      <p>В случае примера рис.11.9 этот процесс будет развиваться следующим образом:</p>
      <p>(1) Начинаем с начального множества кандидатов:</p>
      <p><code>[ [а] ]</code></p>
      <p>(2) Порождаем продолжения пути <code>[а]</code>:</p>
      <p><code>[ [b, а], [с, а] ]</code></p>
      <p>(Обратите внимание, что пути записаны в обратном порядке.)</p>
      <p>(3) Удаляем первый путь из множества кандидатов и порождаем его продолжения:</p>
      <p><code>[ [d, b, a], [e, b, а] ]</code></p>
      <p>Добавляем список продолжений в конец списка кандидатов:</p>
      <p><code>[ [с, а], [d, b, a], [e, b, а] ]</code></p>
      <p>(4) Удаляем <code>[с, а]</code>, а затем добавляем все его продолжения в конец множества кандидатов. Получаем:</p>
      <p><code>[ [d, b, a], [e, b, а], [f, c, a], [g, c, a] ]</code></p>
      <p>Далее, после того, как пути <code>[d, b, a]</code> и <code>[e, b, а]</code> будут продолжены, измененный список кандидатов примет вид</p>
      <p><code>[[f, c, a], [g, c, a], [h, d, b, a], [i, e, b, a], [j, e, b, a]]</code></p>
      <p>В этот момент обнаруживается путь <code>[f, c, a]</code>, содержащий целевую вершину <code>f</code>. Этот путь выдается в качестве решения.</p>
      <p>Программа, порождающая этот процесс, показана на рис. 11.10. В этой программе все продолжения пути на один шаг генерируются встроенной процедурой <code>bagof</code>. Кроме того, делается проверка, предотвращающая порождение циклических путей. Обратите внимание на то, что в случае, когда путь продолжить невозможно, и цель <code>bagof</code> терпит неудачу, обеспечивается альтернативный запуск процедуры <code>вширину</code>. Процедуры <code>принадлежит</code> и <code>конк</code> реализуют отношения принадлежности списку и конкатенации списков соответственно.</p>
      <p>Недостатком этой программы является неэффективность операции <code>конк</code>. Положение можно исправить, применив разностное представление списков (см. гл. 8). Тогда множество путей-кандидатов будет представлено парой списков <code>Пути</code> и <code>Z</code>, записанной в виде</p>
      <p><code>Пути-Z</code></p>
      <p>При введении этого представления в программу рис. 11.10 ее можно постепенно преобразовать в программу, показанную на рис. 11.11. Оставим это преобразование читателю в качестве упражнения.</p>
     </section>
     <section>
      <title>
       <p>11.3.2. Древовидное представление множества кандидатов</p>
      </title>
      <p>Рассмотрим теперь еще одно изменение нашей программы поиска в ширину. До сих пор мы представляли множества путей-кандидатов как списки путей. Это расточительный способ, поскольку начальные участки путей являются общими для нескольких из них. Таким образом, эти общие части путей приходится хранить во многих экземплярах. Избежать избыточности помогло бы более компактное представление множества кандидатов. Таким более компактным представлением является дерево, в котором общие участки путей хранятся в его верхней части без дублирования. Будем использовать в программе следующее представление дерева. Имеется два случая:</p>
      <p><emphasis>Случай 1:</emphasis> Дерево состоит только из одной вершины В; В этом случае оно имеет вид терма <code>л( В)</code>; Функтор <code>л</code> указывает на то, что В — это лист дерева.</p>
      <p><emphasis>Случай 2:</emphasis> Дерево состоит из корневой вершины В и множества поддеревьев Д1, Д2, …. Такое дерево представляется термом</p>
      <p><code>д( В, Пд)</code></p>
      <p>где <code>Пд</code> — список поддеревьев:</p>
      <p><code>Пд = [ Д1, Д2, ...]</code></p>
      <p>В качестве примера рассмотрим ситуацию, которая возникает после того, как порождены три уровня дерева рис. 11.9. Множество путей-кандидатов в случае спискового представления имеет вид:</p>
      <p><code>[ [d, b, a], [e, b, а], [f, c, a], [g, c, a] ]</code></p>
      <p>В виде дерева это множество выглядит так:</p>
      <p><code>д( а, [д( b, [л( d), л( e)] ), д( с, [л( f), л( g)] )] )</code></p>
      <p>На первый взгляд древовидное представление кажется еще более расточительным, чем списковое, однако это всего лишь поверхностное впечатление, связанное с компактностью прологовской нотации для списков.</p>
      <p>В случае спискового представления множества кандидатов эффект распространения процесса в ширину достигался за счет перемещения продолженных путей в конец списка. В нашем случае мы уже не можем использовать этот прием, поэтому программа несколько усложняется. Ключевую роль в нашей программе будет играть отношение</p>
      <p>расширить( Путь, Дер, Дер1, ЕстьРеш, Решение)</p>
      <p>На рис. 11.12 показано, как связаны между собой аргументы отношения <code>расширить</code>. При каждом обращении к <code>расширить</code> переменные <code>Путь</code> и <code>Дер</code> будут уже конкретизированы. <code>Дер</code> — поддерево всего дерева поиска, одновременно оно служит для представления множества путей-кандидатов внутри этого поддерева. <code>Путь</code> — это путь, ведущий из стартовой вершины в корень поддерева <code>Дер</code>. Самая общая идея алгоритма — получить поддерево <code>Дер1</code> как результат расширения <code>Дер</code> на один уровень. Но в случае, когда в процессе расширения поддерева <code>Дер</code> встретится целевая вершина, процедура <code>расширить</code> должна сформировать соответствующий решающий путь.</p>
      <image l:href="#_79.png"/>
      <p><strong>Рис. 11.12.</strong> Отношение <code>paсширить( Путь, Дер, Дер1, ЕстьРеш, Решение)</code>:  <code>s</code> — стартовая вершина, <code>g</code> — целевая вершина. <code>Решение</code> — это <code>Путь</code>, продолженный вплоть до <code>g</code>. <code>Дер1</code> — результат расширения дерева <code>Дер</code> на один уровень вниз.</p>
      <p>Итак, процедура <code>расширить</code> будет порождать два типа результатов. На конкретный вид результата будет указывать значение переменной <code>ЕстьРеш</code>:</p>
      <p>(1) <code>ЕстьРеш</code> = да</p>
      <p><code>Решение</code> = решающий путь, т.е. <code>Путь</code>, продолженный до целевой вершины.</p>
      <p><code>Дер1</code> = неконкретизировано.</p>
      <p>Разумеется, такой тип результата получится только в том случае, когда <code>Дер</code> будет содержать целевую вершину. Добавим также, что эта целевая вершина обязана быть листом поддерева <code>Дер</code>.</p>
      <p>(2) <code>ЕстьРеш</code> = нет</p>
      <p><code>Дер1</code> = результат расширения поддерева <code>Дер</code> на один уровень вниз от своего "подножья". <code>Дер1</code> не содержит ни одной "тупиковой" ветви из <code>Дер</code>, т.е. такой ветви, что она либо не может быть продолжена из-за отсутствия преемников, либо любое ее продолжение приводит к циклу.</p>
      <p><code>Решение</code> = неконкретизировано.</p>
      <p>Если в дереве <code>Дер</code> нет ни одной целевой вершины и, кроме того, оно не может быть расширено, то процедура <code>расширить</code> терпит неудачу.</p>
      <p>Процедура верхнего уровня для поиска в ширину</p>
      <p><code>вширину( Дер, Решение)</code></p>
      <p>отыскивает <code>Решение</code> либо среди множества кандидатов <code>Дер</code>, либо в его расширении. На рис. 11.3 показано, как выглядит программа целиком. В этой программе имеется вспомогательная процедура <code>расширитьвсе</code>. Она расширяет все деревья из некоторого <emphasis>списка</emphasis>, и затем, выбросив все "тупиковые" деревья", собирает все полученные расширенные деревья в один новый список. Используя механизм возвратов, она также порождает все решения, обнаруженные в деревьях из списка. Имеется одна дополнительная деталь: по крайней мере одно из деревьев должно "вырасти". Если это не так, то процедуре <code>расширитьвсе</code> не удается получить ни одного расширенного дерева - все деревья из списка оказываются "тупиковыми".</p>
      <empty-line/>
      <p><code>% ПОИСК В ШИРИНУ</code></p>
      <p><code>% Множество кандидатов представлено деревом</code></p>
      <p><code>решить( Старт, Решение) :-</code></p>
      <p><code> вширину( л( Старт), Решение).</code></p>
      <empty-line/>
      <p><code>вширину( Дер, Решение) :-</code></p>
      <p><code> расширить( [], Дер, Дер1, ЕстьРеш, Решение),</code></p>
      <p><code> ( ЕстьРеш = да;</code></p>
      <p><code>   ЕстьРеш = нет, вширину( Дер1, Решение) ).</code></p>
      <empty-line/>
      <p><code>расширить( П, Л( В), _, да, [В | П] ) :-</code></p>
      <p><code> цель( В).</code></p>
      <p><code>расширить( П, Л( В), д( В, Пд), нет, _ ) :-</code></p>
      <p><code> bagof( л( B1),</code></p>
      <p><code> ( после( В, B1), not принадлежит( В1, П)), Пд).</code></p>
      <p><code>расширить( П, д( В, Пд), д( В, Пд1), ЕстьРеш, Реш) :-</code></p>
      <p><code> расширитьвсе( [В | П], Пд, [ ], Пд1, ЕстьРеш, Реш).</code></p>
      <empty-line/>
      <p><code>расширитьвсе( _, [ ], [Д | ДД], [Д | ДД], нет, _ ).</code></p>
      <p><code>  % По крайней мере одно дерево должно вырасти</code></p>
      <p><code>расширитьвсе( П, [Д | ДД], ДД1, Пд1, ЕстьРеш, Реш) :-</code></p>
      <p><code> расширить ( П, Д, Д1, ЕстьРеш1, Реш),</code></p>
      <p><code> ( ЕстьРеш 1= да, ЕстьРеш = да;</code></p>
      <p><code>   ЕстьРеш1 = нет, !,</code></p>
      <p><code>   расширитьвсе( П, ДД, [Д1 | ДД1], Пд1, ЕстьРеш, Реш));</code></p>
      <p><code> расширитьвсе( П, ДД, ДД1, Пд1, ЕстьРеш, Реш ).</code></p>
      <p><strong>Рис. 11.13.</strong> Реализация поиска в ширину с использованием древовидного представления множества путей-кандидатов.</p>
      <empty-line/>
      <p>Мы разработали эту более сложную реализацию поиска в ширину не только для того, чтобы получать программу более экономичную по сравнению с предыдущей версией, но также и потому, что такое решение задачи может послужить хорошим стартом для перехода к усложненным программам поиска, управляемым эвристиками, таким как программа поиска с предпочтением из гл. 12.</p>
      <subtitle>Упражнения</subtitle>
      <p><strong>11.5.</strong> Перепишите программу поиска в ширину рис. 11.10, используя разностное представление для списка путей-кандидатов и покажите, что в результате получится программа, приведенная на рис. 11.11. Зачем в программу рис. 11.11 включена цель</p>
      <p><code>Пути \== Z</code></p>
      <p>Проверьте, что случится при поиске в пространстве состояний рис. 11.9, если эту цель опустить. Различие в выполнении программы, возникнет только при попытке найти новые решения в ситуации, когда не осталось больше ни одного решения.</p>
      <p><strong>11.6.</strong> Как программы настоящего раздела можно использовать для поиска, начинающегося от <emphasis>стартового множества</emphasis> вершин, вместо одной стартовой вершины?</p>
      <p><strong>11.7.</strong> Как программы этой главы можно использовать для поиска в обратном направлении, т.е. от целевой вершины к стартовой вершине (или к одной из стартовых вершин, если их несколько). Указание: переопределите отношение <code>после</code>. В каких ситуациях обратный поиск будет иметь преимущества перед прямым поиском?</p>
      <p><strong>11.8.</strong> Иногда выгодно сделать поиск <emphasis>двунаправленным</emphasis>, т.е. продвигаться одновременно с двух сторон от стартовой и целевой вершин. Поиск заканчивается, когда оба пути "встречаются". Определите пространство поиска (отношение <code>после</code>) и целевое отношение для заданного графа таким образом, чтобы наши процедуры поиска в действительности выполняли двунаправленный поиск.</p>
      <p><strong>11.9.</strong> Проведите эксперименты с различными методами поиска применительно к задаче планирования в "мире кубиков".</p>
     </section>
    </section>
    <section>
     <title>
      <p>11.4.  Замечания относительно поиска в графах, оптимальности к сложности</p>
     </title>
     <p>Сейчас уместно сделать ряд замечаний относительно программ поиска, разработанных к настоящему моменту: во-первых, о поиске в графах, во-вторых, об оптимальности полученных решений и, в-третьих, о сложности поиска.</p>
     <p>Приведенные примеры могли создать ложное впечатление, что наши программы поиска в ширину способны работать только в пространствах состояний, являющихся деревьями, а не графами общего вида. На самом деле, тот факт, что в одной из версий множество путей-кандидатов представлялось деревом, совсем не означает, что и само пространство состояний должно было быть деревом. Когда поиск проводится в графе, граф фактически разворачивается в дерево, причем некоторые пути, возможно, дублируются в разных частях этого дерева (см. рис. 11.14).</p>
     <p>Наши программы поиска в ширину порождают решающие пути один за другим в порядке увеличения их длин — самые короткие решения идут первыми. Это является важным обстоятельством, если нам необходима оптимальность (в отношении длины решения). Стратегия поиска в ширину гарантирует получение кратчайшего решения первым. Разумеется, это неверно для поиска в глубину.</p>
     <image l:href="#_80.png"/>
     <p><strong>Рис. 11.14.</strong> (а) Пространство состояний; а — стартовая вершина. (b) Дерево всех возможных ациклических путей, ведущих из а, порожденное программой поиска в ширину.</p>
     <p>Наши программы, однако, не учитывают стоимости, приписанные дугам в пространстве состояний. Если критерием оптимальности является минимум стоимости решающего пути (а не его длина), то в этом случае поиска в ширину недостаточно. Поиск с предпочтением из гл. 12 будет направлен на оптимизацию стоимости.</p>
     <p>Еще одна типичная проблема, связанная с задачей поиска, — это проблема <emphasis>комбинаторной сложности</emphasis>. Для нетривиальных предметных областей число альтернатив столь велико, что проблема сложности часто принимает критический характер. Легко понять, почему это происходит: если каждая вершина имеет b преемников, то число путей длины l, ведущих из стартовой вершины, равно b<sup>l</sup> (в предположении, что циклов нет). Таким образом, вместе с увеличением длин путей наблюдается <emphasis>экспоненциальный</emphasis> рост объема множества путей-кандидатов, что приводит к ситуации, называемой <emphasis>комбинаторным взрывом</emphasis>. Стратегии поиска в глубину и ширину недостаточно "умны" для борьбы с такой степенью комбинаторной сложности: отсутствие селективности приводит к тому, что все пути рассматриваются как одинаково перспективные.</p>
     <p>По-видимому, более изощренные процедуры поиска должны использовать какую-либо информацию, отражающую специфику данной задачи, с тем чтобы на каждой стадии поиска принимать решения о наиболее перспективных путях поиска. В результате процесс будет продвигаться к целевой вершине, обходя бесполезные пути. Информация, относящаяся к конкретной решаемой задаче и используемая для управления поиском, называется <emphasis>эвристикой</emphasis>. Про алгоритмы, использующие эвристики, говорят, что они <emphasis>руководствуются эвристиками</emphasis>: они выполняют <emphasis>эвристический поиск</emphasis>. Один из таких методов изложен в следующей главе.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• <emphasis>Пространство состояний</emphasis> есть формализм для представления задач.</p>
     <p>• Пространство состояний — это направленный граф, вершины которого соответствуют проблемным ситуациям, а дуги — возможным ходам. Конкретная задача определяется <emphasis>стартовой вершиной</emphasis> и <emphasis>целевым условием</emphasis>. Решению задачи соответствует путь в графе. Таким образом, решение задачи сводится к поиску пути в графе.</p>
     <p>• Оптимизационные задачи моделируются приписыванием каждой дуге пространства состояний некоторой стоимости.</p>
     <p>• Имеются две основных стратегии поиска в пространстве состояний — <emphasis>поиск в глубину</emphasis> и <emphasis>поиск в ширину</emphasis>.</p>
     <p>• Поиск в глубину программируется наиболее легко, однако подвержен зацикливаниям. Существуют два простых метода предотвращения зацикливания: ограничить глубину поиска и не допускать дублирования вершин.</p>
     <p>• Реализация поиска в ширину более сложна, поскольку требуется сохранять множество кандидатов. Это множество может быть с легкостью представлено списком списков, но более экономное представление — в виде дерева.</p>
     <p>• Поиск в ширину всегда первым обнаруживает самое короткое решение, что не верно в отношении стратегии поиска в глубину.</p>
     <p>• В случае обширных пространств состояний существует опасность <emphasis>комбинаторного взрыва</emphasis>. Обе стратегии плохо приспособлены для борьбы с этой трудностью. В таких случаях необходимо руководствоваться эвристиками.</p>
     <p>• В этой главе были введены следующие понятия:</p>
     <p>  пространство состояний</p>
     <p>  стартовая вершина, целевое условие,</p>
     <p>  решающий путь</p>
     <p>  стратегия поиска</p>
     <p>  поиск в глубину, поиск в ширину</p>
     <p>  эвристический поиск.</p>
     <subtitle>Литература</subtitle>
     <p>Поиск в глубину и поиск в ширину — базовые стратегии поиска, они описаны в любом учебнике по искусственному интеллекту, см., например, Nilsson (1971, 1980) или Winston (1984). P. Ковальский в своей книге Kowalski (1980) показывает, как можно использовать аппарат математической логики для реализации этих принципов.</p>
     <empty-line/>
     <p>Kowalski R. (1980). <emphasis>Logic for Problem Solving.</emphasis> North-Holland.</p>
     <p>Nilsson N. J. (1971). <emphasis>Problem Solving Methods in Artificial Intelligence.</emphasis> McGraw-Hill.</p>
     <p>Nilsson N. J. (1980). <emphasis>Principles of Artificial Intelligence.</emphasis> Tioga; also Springer-Verlag, 1981.</p>
     <p>Winston P. H. (1984). <emphasis>Artificial Intelligence (second edition).</emphasis> Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — М.: Мир, 1980.]</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 12</p>
     <p>Поиск с предпочтением: эвристический поиск</p>
    </title>
    <section>
     <p>Поиск в графах при решении задач, как правило, невозможен без решения проблемы комбинаторной сложности, возникающей из-за быстрого роста числа альтернатив. Эффективным средством борьбы с этим служит эвристический поиск.</p>
     <p>Один из путей использования эвристической информации о задаче — это получение численных <emphasis>эвристических оценок</emphasis> для вершин пространства состояний. Оценка вершины указывает нам, насколько данная вершина перспективна с точки зрения достижения цели. Идея состоит в том, чтобы всегда продолжать поиск, начиная с наиболее перспективной вершины, выбранной из всего множества кандидатов. Именно на этом принципе основана программа поиска с предпочтением, описанная в данной главе. </p>
    </section>
    <section>
     <title>
      <p>12.1. Поиск с предпочтением</p>
     </title>
     <p>Программу поиска с предпочтением можно получить как результат усовершенствования программы поиска в ширину (рис. 11.13). Подобно поиску в ширину, поиск с предпочтением начинается со стартовой вершины и использует множество путей-кандидатов. В то время, как поиск в ширину всегда выбирает для продолжения самый короткий путь (т.е. переходит в вершины наименьшей глубины), поиск с предпочтением вносит в этот принцип следующее усовершенствование: для каждого кандидата вычисляется оценка и для продолжения выбирается кандидат с наилучшей оценкой.</p>
     <image l:href="#_81.png"/>
     <p><strong>Рис. 12.1.</strong> Построение эвристической оценки <emphasis>f</emphasis>(<emphasis>n</emphasis>) стоимости самого дешевого пути из <emphasis>s</emphasis> в <emphasis>t</emphasis>, проходящего через <emphasis>n</emphasis>: <emphasis>f</emphasis>(<emphasis>n</emphasis>) = <emphasis>g</emphasis>(<emphasis>n</emphasis>) <emphasis>+ h</emphasis>(<emphasis>n</emphasis>).</p>
     <p>Мы будем в дальнейшем предполагать, что для дуг пространства состояний определена функция стоимости <emphasis>с</emphasis>(<emphasis>n</emphasis>, <emphasis>n'</emphasis>) — стоимость перехода из вершины <emphasis>n</emphasis>  к вершине-преемнику <emphasis>n'</emphasis>.</p>
     <p>Пусть <emphasis>f</emphasis> — это эвристическая оценочная функция, при помощи которой мы получаем для каждой вершины <emphasis>n</emphasis> оценку <emphasis>f</emphasis>(<emphasis>n</emphasis>) трудности" этой вершины. Тогда наиболее перспективной вершиной-кандидатом следует считать вершину, для которой <emphasis>f</emphasis> принимает минимальное значение. Мы будем использовать здесь функцию <emphasis>f</emphasis> специального вида, приводящую к хорошо известному А*-алгоритму. Функция <emphasis>f</emphasis>(<emphasis>n</emphasis>) будет построена таким образом, чтобы давать оценку стоимости оптимального решающего пути из стартовой вершины <emphasis>s</emphasis> к одной из целевых вершин при условии, что этот путь проходит через вершину <emphasis>n</emphasis>. Давайте предположим, что такой путь существует и что <emphasis>t</emphasis> — это целевая вершина, для которой этот путь минимален. Тогда оценку <emphasis>f</emphasis>(<emphasis>n</emphasis>) можно представить в виде суммы из двух слагаемых (рис. 12.1):</p>
     <p><emphasis> f</emphasis>(<emphasis>n</emphasis>) = <emphasis>g</emphasis>(<emphasis>n</emphasis>) + <emphasis>h</emphasis>(<emphasis>n</emphasis>)</p>
     <p>Здесь <emphasis>g</emphasis>(<emphasis>n</emphasis>) — оценка оптимального пути из <emphasis>s</emphasis> в <emphasis>n</emphasis>; <emphasis>h</emphasis>(<emphasis>n</emphasis>) — оценка оптимального пути из <emphasis>n</emphasis> в <emphasis>t</emphasis>.</p>
     <p>Когда в процессе поиска мы попадаем в вершину <emphasis>n</emphasis>, мы оказываемся в следующей ситуация: путь из <emphasis>s</emphasis> в <emphasis>n</emphasis> уже найден, и его стоимость может быть вычислена как сумма стоимостей составляющих его дуг. Этот путь не обязательно оптимален (возможно, существует более дешевый, еще не найденный путь из <emphasis>s</emphasis> в <emphasis>n</emphasis>), однако стоимость этого пути можно использовать в качестве оценки <emphasis>g</emphasis>(<emphasis>n</emphasis>) минимальной стоимости пути из <emphasis>s</emphasis> в <emphasis>n</emphasis>. Что же касается второго слагаемого <emphasis>h</emphasis>(<emphasis>n</emphasis>), то о нем трудно что-либо сказать, поскольку к этому моменту область пространства состояний, лежащая между <emphasis>n</emphasis> и <emphasis>t</emphasis>, еще не "изучена" программой поиска. Поэтому, как правило, о значении <emphasis>h</emphasis>(<emphasis>n</emphasis>) можно только строить догадки на основании эвристических соображений, т.е. на основании тех знаний о конкретной задаче, которыми обладает алгоритм. Поскольку значение <emphasis>h</emphasis> зависит от предметной области, универсального метода для его вычисления не существует. Конкретные примеры того, как строят эти "эвристические догадки", мы приведем позже. Сейчас же будем считать, что тем или иным способом функция <emphasis>h</emphasis> задана, и сосредоточим свое внимание на деталях нашей программы поиска с предпочтением.</p>
     <p>Можно представлять себе поиск с предпочтением следующим образом. Процесс поиска состоит из некоторого числа конкурирующих между собой подпроцессов, каждый из которых занимается своей альтернативой, т.е. просматривает свое поддерево. У поддеревьев есть свои поддеревья, их просматривают подпроцессы подпроцессов и т.д. В каждый данный момент среди всех конкурирующих процессов активен только один — тот, который занимается наиболее перспективной к настоящему моменту альтернативой, т.е. альтернативой с наименьшим значением <emphasis>f</emphasis>. Остальные процессы спокойно ждут того момента, когда <emphasis>f</emphasis>-оценки изменятся и в результате какая-нибудь другая альтернатива станет наиболее перспективной. Тогда производится переключение активности на эту альтернативу. Механизм активации-дезактивации процессов функционирует следующим образом: процесс, работающий над текущей альтернативой высшего приоритета, получает некоторый "бюджет" и остается активным до тех пор, пока его бюджет не исчерпается. Находясь в активном состоянии, процесс продолжает углублять свое поддерево. Встретив целевую вершину, он выдает соответствующее решение. Величина бюджета, предоставляемого процессу на данный конкретный запуск, определяется эвристической оценкой конкурирующей альтернативы, ближайшей к данной.</p>
     <image l:href="#_82.png"/>
     <p><strong>Рис. 12.2.</strong> Поиск кратчайшего маршрута из <emphasis>s</emphasis> в <emphasis>t</emphasis>. (а) Карта со связями между городами; связи помечены своими длинами; в квадратиках указаны расстояния по прямой до цели <emphasis>t</emphasis>. (b) Порядок, в котором при поиске с предпочтением происходит обход городов. Эвристические оценки основаны на расстояниях по прямой. Пунктирной линией показано переключение активности между альтернативными путями. Эта линия задает тот порядок, в котором вершины принимаются для <emphasis>продолжения</emphasis> пути, а не тот порядок, в котором они порождаются.</p>
     <p>На рис. 12.2 показан пример поведения конкурирующих процессов. Дана карта, задача состоит в том, чтобы найти кратчайший маршрут из стартового города <emphasis>s</emphasis> в целевой город <emphasis>t</emphasis>. В качестве оценки стоимости остатка маршрута из города <emphasis>X</emphasis> до цели мы будем использовать расстояние по прямой <emphasis>расст( X, t)</emphasis> от <emphasis>X</emphasis> до <emphasis>t</emphasis>. Таким образом,</p>
     <p><emphasis> f( X) = g( X) + h( X) = g( X) + расст( X, t)</emphasis></p>
     <p>Мы можем считать, что в данном примере процесс поиска с предпочтением состоит из двух процессов. Каждый процесс прокладывает свой путь — один из двух альтернативных путей: Процесс 1 проходит через <emphasis>а</emphasis>. Процесс 2 — через <emphasis>e</emphasis>. Вначале Процесс 1 более активен, поскольку значения <emphasis>f</emphasis> вдоль выбранного им пути меньше, чем вдоль второго пути. Когда Процесс 1 достигает города <emphasis>с</emphasis>, а Процесс 2 все еще находится в <emphasis>e</emphasis>, ситуация меняется:</p>
     <p><emphasis> f( с) = g( c) + h( c) = 6 + 4 = 10</emphasis></p>
     <p><emphasis> f( e) = g( e) + h( e) = 2 + 7 = 9</emphasis></p>
     <p>Поскольку <emphasis>f( e) &lt; f( c)</emphasis>, Процесс 2 переходит к <emphasis>f</emphasis>, a Процесс 1 ждет. Однако</p>
     <p><emphasis> f( f) = 7 + 4 = 11</emphasis></p>
     <p><emphasis> f( c) = 10</emphasis></p>
     <p><emphasis> f( c) &lt; f( f)</emphasis></p>
     <p>Поэтому Процесс 2 останавливается, а Процессу 1 дается разрешение продолжать движение, но только до <emphasis>d</emphasis>, так как <emphasis>f( d) = 12 &gt; 11</emphasis>. Происходит активация Процесса 2, после чего он, уже не прерываясь, доходит до цели <emphasis>t</emphasis>.</p>
     <p>Мы реализуем этот механизм программно при помощи усовершенствования программы поиска в ширину (рис. 11.13). Множество путей-кандидатов представим деревом. Дерево будет изображаться в программе в виде терма, имеющего одну из двух форм:</p>
     <p>(1) <code>л( В, F/G)</code> — дерево, состоящее из одной вершины (листа); <code>В</code> — вершина пространства состояний, <code>G</code> — <emphasis><code><emphasis>g</emphasis>( B)</code></emphasis> (стоимость уже найденного пути из стартовой вершины в <code>В</code>); <code>F - <emphasis>f</emphasis>( В)</code> = <code>G + <emphasis>h</emphasis>( В)</code>.</p>
     <p>(2) <code>д( В, F/G, Пд)</code> — дерево с непустыми поддеревьями; <code>В</code> — корень дерева, <code>Пд</code> — список поддеревьев; <code>G</code> — <emphasis><code><emphasis>g</emphasis>( B)</code></emphasis>; <code>F</code> —  <emphasis>уточненное</emphasis> значение <emphasis><code><emphasis>f</emphasis>( В)</code></emphasis>, т.е. значение <emphasis>f</emphasis> для наиболее перспективного преемника вершины <code>В</code>; список <code>Пд</code> упорядочен в порядке возрастания <emphasis>f</emphasis>-оценок поддеревьев.</p>
     <p>Уточнение значения <emphasis>f</emphasis> необходимо для того, чтобы дать программе возможность распознавать наиболее перспективное поддерево (т.е. поддерево, содержащее наиболее перспективную концевую вершину) на любом уровне дерева поиска. Эта модификация <emphasis>f</emphasis>-оценок на самом деле приводит к обобщению, расширяющему область определения функции <emphasis>f</emphasis>. Теперь функция <emphasis>f</emphasis> определена не только на вершинах, но и на деревьях. Для одновершинных деревьев (листов) <emphasis>n</emphasis> остается первоначальное определение</p>
     <p><emphasis> f( n) = g( n) + h( n)</emphasis></p>
     <p>Для дерева <emphasis>T</emphasis> с корнем <emphasis>n</emphasis>, имеющем преемников <emphasis>m</emphasis><sub>1</sub>, <emphasis>m</emphasis><sub>2</sub>, …, получаем</p>
     <p> <image l:href="#img_0.png"/></p>
     <p>Программа поиска с предпочтением, составленная в соответствии с приведенными выше общими соображениями, показана на рис 12.3. Ниже даются некоторые дополнительные пояснения.</p>
     <p>Так же, как и в случае поиска в ширину (рис. 11.13), ключевую роль играет процедура <code>расширить</code>, имеющая на этот раз шесть аргументов:</p>
     <p><code>расширить( Путь, Дер, Предел, Дер1, ЕстьРеш, Решение)</code></p>
     <p>Эта процедура расширяет текущее (под)дерево, пока  <emphasis>f</emphasis>-оценка остается равной либо меньшей, чем <code>Предел</code>.</p>
     <empty-line/>
     <p><code>% Поиск с предпочтением</code></p>
     <p><code>эврпоиск( Старт, Решение) :-</code></p>
     <p><code> макс_f( Fмакс).         % Fмакс &gt; любой  f-оценки</code></p>
     <empty-line/>
     <p><code>расширить( [], л( Старт, 0/0), Fмакс, _, да, Решение).</code></p>
     <p><code>расширить( П, л( В, _ ), _, _, да, [В | П] ) :-</code></p>
     <p><code> цель( В).</code></p>
     <p><code>расширить( П, л( В, F/G), Предел, Дер1, ЕстьРеш, Реш) :-</code></p>
     <p><code> F &lt;= Предел,</code></p>
     <p><code> ( bagof( B1/C, ( после( В, В1, С), not принадлежит( В1, П)),</code></p>
     <p><code>   Преемники), !,</code></p>
     <p><code> преемспис( G, Преемники, ДД),</code></p>
     <p><code> опт_f( ДД, F1),</code></p>
     <p><code> расширить( П, д( В, F1/G, ДД), Предел, Дер1,</code></p>
     <p><code>  ЕстьРеш, Реш);</code></p>
     <p><code> ЕстьРеш = никогда).     % Нет преемников - тупик</code></p>
     <p><code>расширить( П, д( В, F/G, [Д | ДД]), Предел, Дер1,</code></p>
     <p><code> ЕстьРеш, Реш) :-</code></p>
     <p><code> F &lt;= Предел,</code></p>
     <p><code> опт_f( ДД, OF), мин( Предел, OF, Предел1),</code></p>
     <p><code> расширить( [В | П], Д, Предел1, Д1, ЕстьРеш1, Реш),</code></p>
     <p><code> продолжить( П, д( В, F/G, [Д1, ДД]), Предел, Дер1,</code></p>
     <p><code> ЕстьРеш1, ЕстьРеш, Реш).</code></p>
     <p><code>расширить( _, д( _, _, []), _, _, никогда, _ ) :- !.</code></p>
     <p><code>  % Тупиковое дерево - нет решений</code></p>
     <p><code>расширить( _, Дер, Предел, Дер, нет, _ ) :-</code></p>
     <p><code> f( Дер, F), F &gt; Предел. % Рост остановлен</code></p>
     <empty-line/>
     <p><code>продолжить( _, _, _, _, да, да, Реш).</code></p>
     <p><code>продолжить( П, д( В, F/G, [Д1, ДД]), Предел, Дер1,</code></p>
     <p><code> ЕстьРеш1, ЕстьРеш, Реш) :-</code></p>
     <p><code> ( ЕстьРеш1 = нет, встав( Д1, ДД, НДД);</code></p>
     <p><code>   ЕстьРеш1 = никогда, НДД = ДД),</code></p>
     <p><code> опт_f( НДД, F1),</code></p>
     <p><code> расширить( П, д( В, F1/G, НДД), Предел, Дер1,</code></p>
     <p><code>  ЕстьРеш, Реш).</code></p>
     <empty-line/>
     <p><code>преемспис( _, [], []).</code></p>
     <p><code>преемспис( G0, [В/С | ВВ], ДД) :-</code></p>
     <p><code> G is G0 + С,</code></p>
     <p><code> h( В, H),               % Эвристика h(B)</code></p>
     <p><code> F is G + H,</code></p>
     <p><code> преемспис( G0, ВВ, ДД1),</code></p>
     <p><code> встав( л( В, F/G), ДД1, ДД).</code></p>
     <empty-line/>
     <p><code>% Вставление дерева Д в список деревьев ДД с сохранением</code></p>
     <p><code>% упорядоченности по f-оценкам</code></p>
     <p><code>встав( Д, ДД, [Д | ДД] ) :-</code></p>
     <p><code> f( Д, F), опт_f( ДД, F1),</code></p>
     <p><code> F =&lt; F1, !.</code></p>
     <p><code>встав( Д, [Д1 | ДД], [Д1 | ДД1] ) ) :-</code></p>
     <p><code> встав( Д, ДД, ДД1).</code></p>
     <empty-line/>
     <p><code>% Получение f-оценки</code></p>
     <p><code>f( л( _, F/_ ), F).      % f-оценка листа</code></p>
     <p><code>f( д( _, F/_, _ ) F).    % f-оценка дерева</code></p>
     <empty-line/>
     <p><code>опт_f( [Д | _ ], F) :-   % Наилучшая f-оценка для</code></p>
     <p><code> f( Д, F).               % списка деревьев</code></p>
     <p><code>опт_f( [], Fмакс) :-     % Нет деревьев:</code></p>
     <p><code> мaкс_f( Fмакс).         % плохая f-оценка</code></p>
     <empty-line/>
     <p><code>мин( X, Y, X) :-</code></p>
     <p><code> X =&lt; Y, !.</code></p>
     <p><code>мин( X, Y, Y).</code></p>
     <p><strong>Рис. 12.3.</strong> Программа поиска с предпочтением.</p>
     <empty-line/>
     <p>Аргументы процедуры <code>расширить</code> имеют следующий смысл:</p>
     <table>
      <tr>
       <td><code>Путь</code></td>
       <td>Путь между стартовой вершиной и корнем дерева <code>Дер</code>.</td>
      </tr>
      <tr>
       <td><code>Дер</code></td>
       <td>Текущее (под)дерево поиска.</td>
      </tr>
      <tr>
       <td><code>Предел</code></td>
       <td>Предельное значение <emphasis>f</emphasis>-оценки, при котором допускается расширение.</td>
      </tr>
      <tr>
       <td><code>Дер1</code></td>
       <td>Дерево <code>Дер</code>, расширенное в пределах ограничения <code>Предел</code>; <emphasis>f</emphasis>-оценка дерева <code>Дер1</code> больше, чем <code>Предел</code> (если только при расширении не была обнаружена целевая вершина).</td>
      </tr>
      <tr>
       <td><code>ЕстьРеш</code></td>
       <td>Индикатор, принимающий значения "да", "нет" и "никогда".</td>
      </tr>
      <tr>
       <td><code>Решение</code></td>
       <td>Решающий путь, ведущий из стартовой вершины через дерево <code>Дер1</code> к целевой вершине и имеющий стоимость, не превосходящую ограничение <code>Предел</code> (если такая целевая вершина была обнаружена).</td>
      </tr>
     </table>
     <p>Переменные <code>Путь</code>, <code>Дер</code>, и <code>Предел</code> — это "входные" параметры процедуры <code>расширить</code> в том смысле, что при каждом обращении к <code>расширить</code> они всегда конкретизированы. Процедура <code>расширить</code> порождает результаты трех видов. Какой вид результата получен, можно определить по значению индикатора <code>ЕстьРеш</code> следующим образом:</p>
     <p>(1) <code>ЕстьРеш = да</code></p>
     <p><code>Решение</code> = решающий путь, найденный при расширении дерева <code>Дер</code> с учетом ограничения <code>Предел</code>.</p>
     <p><code>Дер1</code> = неконкретизировано.</p>
     <p>(2) <code>ЕстьРеш = нет</code></p>
     <p><code>Дер1</code> = дерево <code>Дер</code>, расширенное до тех пор, пока его <emphasis>f</emphasis>-оценка не превзойдет <code>Предел</code> (см. рис. 12.4).</p>
     <p><code>Решение</code> = неконкретизировано.</p>
     <p>(3) <code>ЕстьРеш = никогда</code></p>
     <p><code>Дер1</code> и <code>Решение</code> = неконкретизированы.</p>
     <p>В последнем случае <code>Дер</code> является "тупиковой" альтернативой, и соответствующий процесс никогда не будет реактивирован для продолжения просмотра этого дерева. Случай этот возникает тогда, когда <emphasis>f</emphasis>-оценка дерева <code>Дер</code> не превосходит ограничения <code>Предел</code>, однако дерево не может "расти" потому, что ни один его лист не имеет преемников, или же любой преемник порождает цикл.</p>
     <p>Некоторые предложения процедуры <code>расширить</code> требуют пояснений. Предложение, относящееся к наиболее сложному случаю, когда <code>Дер</code> имеет поддеревья, т.е.</p>
     <p><code>Дер = д( В, F/G, [Д | ДД ] )</code></p>
     <p>означает следующее. Во-первых, расширению подвергается наиболее перспективное дерево <code>Д</code>. В качестве ограничения этому дереву выдается не <code>Предел</code>, а некоторое, возможно, меньшее значение <code>Предел1</code>, зависящее от <emphasis>f</emphasis>-оценок других конкурирующих поддеревьев <code>ДД</code>. Тем самым гарантируется, что "растущее" дерево — это всегда наиболее перспективное дерево, а переключение активности между поддеревьями происходит в соответствии с их  <emphasis>f</emphasis>-оценками. После того, как самый перспективный кандидат расширен, вспомогательная процедура <code>продолжить</code> решает, что делать дальше, а это зависит от типа результата, полученного после расширения. Если найдено решение, то оно и выдается, в противном случае процесс расширения деревьев продолжается.</p>
     <image l:href="#_83.png"/>
     <p><strong>Рис. 12.4.</strong> Отношение <code>расширить</code>: расширение дерева <code>Дер</code> до тех пор, пока <emphasis>f</emphasis>-оценка не превзойдет <code>Предел</code>, приводит к дереву <code>Дер1</code>.</p>
     <p>Предложение, относящееся к случаю</p>
     <p><code>Дер = л( В, F/G)</code></p>
     <p>порождает всех преемников вершины <code>В</code> вместе со стоимостями дуг, ведущих в них из <code>В</code>. Процедура <code>преемспис</code> формирует список поддеревьев, соответствующих вершинам-преемникам, а также вычисляет их <emphasis>g-</emphasis> и <emphasis>f-</emphasis>оценки, как показано на рис. 12.5. Затем полученное таким образом дерево подвергается расширению с учетом ограничения <code>Предел</code>. Если преемников нет, то переменной <code>ЕстьРеш</code> придается значение "никогда" и в результате лист <code>В</code> покидается навсегда.</p>
     <p>Другие отношения:</p>
     <table>
      <tr>
       <td><code>после( В, В1, С)</code></td>
       <td><code>В1</code> — преемник вершины <code>В</code>; <code>С</code> — стоимость дуги, ведущей из <code>В</code> в <code>В1</code>.</td>
      </tr>
      <tr>
       <td><code>h( В, H)</code></td>
       <td><code>H</code> — эвристическая оценка стоимости оптимального пути из вершины <code>В</code> в целевую вершину.</td>
      </tr>
      <tr>
       <td><code>макс_f( Fмакс)</code></td>
       <td><code>Fмакс</code> — некоторое значение, задаваемое пользователем, про которое известно, что оно больше любой возможной <emphasis>f</emphasis>-оценки.</td>
      </tr>
     </table>
     <image l:href="#_84.png"/>
     <p><strong>Рис. 12.5.</strong> Связь между <emphasis>g-</emphasis>оценкой вершины <emphasis>В</emphasis> и <emphasis>f-</emphasis> и <emphasis>g-</emphasis>оценками ее "детей" в пространстве состояний.</p>
     <p>В следующих разделах мы покажем на примерах, как можно применить нашу программу поиска с предпочтением к конкретным задачам. А сейчас сделаем несколько заключительных замечаний общего характера относительно этой программы. Мы реализовали один из вариантов эвристического алгоритма, известного в литературе как А*-алгоритм (ссылки на литературу см. в конце главы). А*-алгоритм привлек внимание многих исследователей. Здесь мы приведем один важный результат, полученный в результате математического анализа А*-алгоритма:</p>
     <cite>
      <p>Алгоритм поиска пути называют <emphasis>допустимым</emphasis>, если он всегда отыскивает оптимальное решение (т.е. путь минимальной стоимости) при условии, что такой путь существует. Наша реализация алгоритма поиска, пользуясь механизмом возвратов, выдает все существующие решения, поэтому, в нашем случае, условием допустимости следует считать оптимальность <emphasis>первого</emphasis> из найденных решений. Обозначим через <emphasis>h*(n)</emphasis> стоимость оптимального пути из произвольной вершины <emphasis>n</emphasis> в целевую вершину. Верна следующая теорема о допустимости А*-алгоритма: А*-алгоритм, использующий эвристическую функцию <emphasis>h</emphasis>, является допустимым, если</p>
      <p><emphasis> h</emphasis>(<emphasis>n</emphasis>) &#8804; <emphasis>h</emphasis>*(<emphasis>n</emphasis>)</p>
      <p>для всех вершин <emphasis>n</emphasis> пространства состояний.</p>
     </cite>
     <p>Этот результат имеет огромное практическое значение. Даже если нам не известно точное значение <emphasis>h</emphasis>*, нам достаточно найти какую-либо нижнюю грань <emphasis>h</emphasis>* и использовать ее в качестве <emphasis>h</emphasis> в А*-алгоритме — оптимальность решения будет гарантирована.</p>
     <p>Существует тривиальная нижняя грань, а именно:</p>
     <p><emphasis>h</emphasis>(<emphasis>n</emphasis>) = 0,   для всех вершин <emphasis>n</emphasis> пространства состояний.</p>
     <p>И при таком значении <emphasis>h</emphasis> допустимость гарантирована. Однако такая оценка не имеет никакой эвристической силы и ничем не помогает поиску. А*-алгоритм при <emphasis>h</emphasis>=0 ведет себя аналогично поиску в ширину. Он, действительно, превращается в поиск в ширину, если, кроме того, положить <emphasis>с</emphasis>(<emphasis>n</emphasis>, <emphasis>n'</emphasis>)=1 для всех дуг (<emphasis>n</emphasis>, <emphasis>n'</emphasis>) пространства состояний. Отсутствие эвристической силы оценки приводит к большой комбинаторной сложности алгоритма. Поэтому хотелось бы иметь такую оценку <emphasis>h</emphasis>, которая была бы нижней гранью <emphasis>h</emphasis>* (чтобы обеспечить допустимость) и, кроме того, была бы как можно ближе к <emphasis>h</emphasis>* (чтобы обеспечить эффективность). В идеальном случае, если бы нам была известна сама точная оценка <emphasis>h</emphasis>*, мы бы ее и использовали: А*-алгоритм, пользующийся <emphasis>h</emphasis>*, находит оптимальное решение сразу, без единого возврата.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>12.1.</strong> Определите отношения <code>после</code>, <code>цель</code> и <code>h</code> для задачи поиска маршрута рис. 12.2. Посмотрите, как наш алгоритм поиска с предпочтением будет вести себя при решении этой задачи. </p>
    </section>
    <section>
     <title>
      <p>12.2. Поиск c предпочтением применительно к головоломке "игра в восемь"</p>
     </title>
     <p>Если мы хотим применить программу поиска с предпочтением, показанную на  рис. 12.3, к какой-нибудь задаче, мы должны добавить к нашей программе отношения, отражающие специфику этой конкретной задачи. Эти отношения определяют саму задачу ("правила игры"), а также вносят в алгоритм эвристическую информацию о методе ее решения. Эвристическая информация задается в форме эвристической функции.</p>
     <empty-line/>
     <p><code>/* Процедуры, отражающие специфику головоломки</code></p>
     <p><code>"игра в восемь".</code></p>
     <p><code>Текущая ситуация представлена списком положений фишек;</code></p>
     <p><code>первый элемент списка соответствует пустой клетке.</code></p>
     <p><code>Пример:</code></p>
     <p><code> &#9484;&#9472;&#9472;&#9472;&#9488;</code></p>
     <p><code>3&#9474;123&#9474; Эта позиция представляется так:</code></p>
     <p><code>2&#9474;8 4&#9474; [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2]</code></p>
     <p><code>1&#9474;765&#9474;</code></p>
     <p><code> &#9492;&#9472;&#9472;&#9472;&#9496;</code></p>
     <p><code>  123</code></p>
     <p><code>"Пусто" можно перемещать в любую соседнюю клетку,</code></p>
     <p><code>т.е. "Пусто" меняется местами со своим соседом.</code></p>
     <p><code>*/</code></p>
     <empty-line/>
     <p><code>после( [Пусто | Спис], [Фшк | Спис1], 1) :-</code></p>
     <p><code>  % Стоимости всех дуг равны 1</code></p>
     <p><code> перест( Пусто, Фшк, Спис, Спис1).</code></p>
     <p><code>  % Переставив Пусто и Фшк, получаем СПИС1</code></p>
     <empty-line/>
     <p><code>перест( П, Ф, [Ф | С], [П | С] ) :-</code></p>
     <p><code> расст( П, Ф, 1).</code></p>
     <p><code>перест( П, Ф, [Ф1 | С], [Ф1 | C1] ) :-</code></p>
     <p><code> перест( П, Ф, С, C1).</code></p>
     <empty-line/>
     <p><code>расст( X/Y, X1/Y1, P) :-</code></p>
     <p><code>  % Манхеттеновское расстояние между клетками</code></p>
     <p><code> расст1( X, X1, Рx),</code></p>
     <p><code> расст1( Y, Y1, Рy),</code></p>
     <p><code> P is Рх + Py.</code></p>
     <p><code>расст1( А, В, P) :-</code></p>
     <p><code> P is А-В, P &gt;= 0, ! ;</code></p>
     <p><code> P is B-A.</code></p>
     <empty-line/>
     <p><code>% Эвристическая оценка h равна сумме расстояний фишек</code></p>
     <p><code>% от их "целевых" клеток плюс "степень упорядоченности",</code></p>
     <p><code>% умноженная на 3</code></p>
     <p><code>h( [ Пусто | Спис], H) :-</code></p>
     <p><code> цель( [Пусто1 | Цспис] ),</code></p>
     <p><code> сумрасст( Спис, ЦСпис, P),</code></p>
     <p><code> упоряд( Спис, Уп),</code></p>
     <p><code> H is P + 3*Уп.</code></p>
     <empty-line/>
     <p><code>сумрасст( [], [], 0).</code></p>
     <p><code>сумрасст( [Ф | С], [Ф1 | C1], P) :-</code></p>
     <p><code> расст( Ф, Ф1, P1),</code></p>
     <p><code> сумрасст( С, Cl, P2),</code></p>
     <p><code> P is P1 + Р2.</code></p>
     <empty-line/>
     <p><code>упоряд( [Первый | С], Уп) :-</code></p>
     <p><code> упоряд( [Первый | С], Первый, Уп).</code></p>
     <p><code>упоряд( [Ф1, Ф2 | С], Первый, Уп) :-</code></p>
     <p><code> очки( Ф1, Ф2, Уп1),</code></p>
     <p><code> упоряд( [Ф2 | С], Первый, Уп2),</code></p>
     <p><code> Уп is Уп1 + Уп2.</code></p>
     <p><code>упоряд( [Последний], Первый, Уп) :-</code></p>
     <p><code> очки( Последний, Первый, Уп).</code></p>
     <empty-line/>
     <p><code>очки( 2/2, _, 1) :- !. % Фишка в центре - 1 очко</code></p>
     <p><code>очки( 1/3, 2/3, 0) :- !.</code></p>
     <p><code>  % Правильная последовательность - 0 очков</code></p>
     <p><code>очки( 2/3, 3/3, 0) :- !.</code></p>
     <p><code>очки( 3/3, 3/2, 0) :- !.</code></p>
     <p><code>очки( 3/2, 3/1, 0) :- !.</code></p>
     <p><code>очки( 3/1, 2/1, 0) :- !.</code></p>
     <p><code>очки( 2/1, 1/1, 0) :- !.</code></p>
     <p><code>очки( 1/1, 1/2, 0) :- !.</code></p>
     <p><code>очки( 1/2, 1/3, 0) :- !.</code></p>
     <p><code>очки( _, _, 2).        % Неправильная последовательность</code></p>
     <empty-line/>
     <p><code>цель( [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2] ).</code></p>
     <empty-line/>
     <p><code>% Стартовые позиции для трех головоломок</code></p>
     <p><code>старт1( [2/2, 1/3, 3/2, 2/3, 3/3, 3/1, 2/1, 1/1, 1/2] ).</code></p>
     <p><code>  % Требуется для решения 4 шага</code></p>
     <p><code>старт2( [2/1, 1/2, 1/3, 3/3, 3/2, 3/1, 2/2, 1/1, 2/3] ).</code></p>
     <p><code>  % 5 шагов</code></p>
     <p><code>старт3( [2/2, 2/3, 1/3, 3/1, 1/2, 2/1, 3/3, 1/1, 3/2] ).</code></p>
     <p><code>  % 18 шагов</code></p>
     <empty-line/>
     <p><code>% Отображение решающего пути в виде списка позиций на доске</code></p>
     <p><code>показреш( []).</code></p>
     <p><code>показреш( [ Поз | Спис] :-</code></p>
     <p><code> показреш( Спис),</code></p>
     <p><code> nl, write( '---'),</code></p>
     <p><code> показпоз( Поз).</code></p>
     <empty-line/>
     <p><code>% Отображение позиции на доске</code></p>
     <p><code>показпоз( [S0, S1, S2, S3, S4, S5, S6, S7, S8] ) :-</code></p>
     <p><code> принадлежит Y, [3, 2, 1] ),     % Порядок Y-координат</code></p>
     <p><code> nl, принадлежит X, [1, 2, 3] ), % Порядок X-координат</code></p>
     <p><code> принадлежит( Фшк-X/Y,</code></p>
     <p><code> [' '-S0, 1-S1, 2-S2, 3-S3, 4-S4, 5-S5, 6-S6, 7-S7, 8-S8]),</code></p>
     <p><code> write( Фшк),</code></p>
     <p><code> fail. %Возврат с переходом к следующей клетке</code></p>
     <p><code>показпоз(_).</code></p>
     <p><strong>Рис. 12.6.</strong> Процедуры для головоломки "игра в восемь", предназначенные для использования программой поиска с предпочтением рис. 12.3.</p>
     <empty-line/>
     <p>Существуют три отношения, отражающих специфику конкретной задачи:</p>
     <p><code>после( Верш, Верш1, Ст)</code></p>
     <p>Это отношение истинно, когда в пространстве состояний существует дуга стоимостью <code>Ст</code> между вершинами <code>Верш</code> и <code>Верш1</code>.</p>
     <p><code>цель( Верш)</code></p>
     <p>Это отношение истинно, если <code>Верш</code> — целевая вершина.</p>
     <p><code>h( Верш, H)</code></p>
     <p>Здесь <code>H</code> — эвристическая оценка стоимости самого дешевого пути из вершины <code>Верш</code> в целевую вершину.</p>
     <p>В данном и следующих разделах мы определим эти отношения для двух примеров предметных областей: для головоломки "игра в восемь" (описанной в разделе 11.1) и планирования прохождения задач в многопроцессорной системе.</p>
     <p>Отношения для "игры в восемь" показаны на рис. 12.6. Вершина пространства состояний — это некоторая конфигурация из фишек на игровой доске. В программе она задается списком текущих положений фишек. Каждое положение определяется парой координат <code>X/Y</code>. Элементы списка располагаются в следующем порядке:</p>
     <p>(1) текущее положение пустой клетки,</p>
     <p>(2) текущее положение фишки 1,</p>
     <p>(3) текущее положение фишки 2,</p>
     <p>…</p>
     <p>Целевая ситуация (см. рис. 11.3) определяется при помощи предложения</p>
     <p><code>цель( [2/2, 1/3, 2/3, 3/3, 3/2, 3/1, 2/1, 1/1, 1/2] ).</code></p>
     <p>Имеется вспомогательное отношение</p>
     <p><code>расст( K1, K2, P)</code></p>
     <p>P — это "манхеттеновское расстояние" между клетками K1 и K2, равное сумме двух расстояний между K1 и K2: расстояния по горизонтали и расстояния по вертикали.</p>
     <image l:href="#_85.png"/>
     <p><strong>Рис. 12.7.</strong> Три стартовых позиции для "игры в восемь": (а) решение требует 4 шага; (b) решение требует 5 шагов; (с) решение требует 18 шагов.</p>
     <p>Наша задача — минимизировать <emphasis>длину</emphasis> решения, поэтому мы положим стоимости всех дуг пространства состояний равными 1. В программе рис. 12. 6. даны также определения трех начальных позиций (см. рис. 12.7).</p>
     <p>Эвристическая функция <emphasis>h</emphasis>, запрограммирована как отношение</p>
     <p><code>h( Поз, H)</code></p>
     <p><code>Поз</code> — позиция на доске; <code>H</code> вычисляется как комбинация из двух оценок:</p>
     <p>(1) <code>сумрасст</code> — "суммарное расстояние" восьми фишек, находящихся в позиции <code>Поз</code>, от их положений в целевой позиции. Например, для начальной позиции, показанной на рис. 12.7(а), <code>сумрасст</code> = 4.</p>
     <p>(2) <code>упоряд</code> — степень упорядоченности фишек в текущей позиции по отношению к тому порядку, в котором они должны находиться в целевой позиции. Величина <code>упоряд</code> вычисляется как сумма очков, приписываемых фишкам, согласно следующим правилам:</p>
     <p> • фишка в центральной позиции — 1 очко;</p>
     <p> • фишка не в центральной позиции, и непосредственно за ней следует (по часовой стрелке) та фишка, какая и должна за ней следовать в целевой позиции — 0 очков.</p>
     <p> • то же самое, но за фишкой следует "не та" фишка — 2 очка.</p>
     <p>Например, для начальной позиции рис.12.7(а),</p>
     <p><code>упоряд</code> = 6.</p>
     <p>Эвристическая оценка <code>H</code> вычисляется как сумма</p>
     <p><code>H = сумрасст + 3 * упоряд</code></p>
     <p>Эта эвристическая функция хорошо работает в том смысле, что она весьма эффективно направляет поиск к цели. Например, при решении головоломок   рис. 12.7(а) и (b) первое решение обнаруживается без единого отклонения от кратчайшего решающего пути. Другими словами, кратчайшие решения обнаруживаются сразу, без возвратов. Даже трудная головоломка  рис. 12.7 (с) решается почти без возвратов. Но данная эвристическая функция страдает тем недостатком, что она не является допустимой: нет гарантии, что более короткие пути обнаруживаются раньше более длинных. Дело в том, что для функции <emphasis>h</emphasis> условие <emphasis>h </emphasis>&#8804;<emphasis> h</emphasis>* выполнено не для всех вершин пространства состояний. Например, для начальной позиции рис. 12.7 (а)</p>
     <p><emphasis>h</emphasis> = 4 + 3 * 6 = 22,    <emphasis>h</emphasis>* = 4</p>
     <p>С другой стороны, оценка "суммарное расстояние" допустима: для всех позиций</p>
     <p><code>сумрасст</code> &#8804;<emphasis> h</emphasis>*</p>
     <p>Доказать это неравенство можно при помощи следующего рассуждения: если мы ослабим условия задачи и разрешим фишкам взбираться друг на друга, то каждая фишка сможет добраться до своего целевого положения по траектории, длина которой в точности равна манхеттеновскому расстоянию между ее начальным и целевым положениями. Таким образом, длина оптимального решения упрощенной задачи будет в точности равна <code>сумрасст</code>. Однако в исходном варианте задачи фишки взаимодействуют друг с другом и мешают друг другу, так что им уже трудно идти по своим кратчайшим траекториям. В результате длина оптимального решения окажется больше либо равной <code>сумрасст</code>.</p>
     <subtitle>Упражнение</subtitle>
     <p><strong>12.2.</strong> Введите в программу поиска с предпочтением, приведенную на рис. 12.3, подсчет числа вершин, порожденных в процессе поиска. Один из простых способов это сделать — хранить текущее число вершин в виде факта, устанавливаемого при помощи <code>assert</code>. Всегда, когда порождаются новые вершины, уточнять это значение при помощи <code>retract</code> и <code>assert</code>. Проведите эксперименты с различными эвристическими функциями задачи "игра в восемь" с целью оценить их эвристическую силу. Используйте для этого вычисленное количество порожденных вершин. </p>
    </section>
    <section>
     <title>
      <p>12.3. Применение поиска с предпочтением к планированию выполнения задач</p>
     </title>
     <p>Рассмотрим следующую задачу планирования. Дана совокупность <emphasis>задач t</emphasis><sub>1</sub>, <emphasis>t</emphasis><sub>2</sub>, …, имеющих времена выполнения соответственно <emphasis>T1</emphasis>, <emphasis>Т2</emphasis>, …. Все эти задачи нужно решить на  <emphasis>m</emphasis>   идентичных процессорах. Каждая задача может быть решена на любом процессоре, но в каждый данный момент каждый процессор решает только одну из задач. Между задачами существует отношение предшествования, определяющее, какие задачи (если таковые есть) должны быть завершены, прежде чем данная задача может быть запущена. Необходимо распределить задачи между процессорами без нарушения отношения предшествования, причем таким образом, чтобы вся совокупность задач была решена за минимальное время. Время, когда последняя задача в соответствии с выработанным планом завершает свое решение, называется <emphasis>временем окончания</emphasis> плана. Мы хотим минимизировать время окончания по всем возможным планам.</p>
     <p>На рис. 12.8 показан пример задачи планирования, а также приведено два корректных плана, один из которых оптимален. Из примера видно, что оптимальный план обладает одним интересным свойством, а именно в нем может предусматриваться "время простоя" процессоров. В оптимальном плане рис. 12.8 процессор 1, выполнив задачу <emphasis>t</emphasis>, ждет в течение двух квантов времени, несмотря на то, что он мог бы начать выполнение задачи <emphasis>t</emphasis>.</p>
     <image l:href="#_86.png"/>
     <p><strong>Рис. 12.8.</strong> Планирование прохождения задач в многопроцессорной системе для 7 задач и 3 процессоров. Вверху показано предшествование задач и величины продолжительности их решения. Например, задача <emphasis>t</emphasis><sub>5</sub> требует 20 квантов времени, причем ее выполнение может начаться только после того, как будет завершено решение трех других задач <emphasis>t</emphasis><sub>1</sub>, <emphasis>t</emphasis><sub>2</sub> и <emphasis>t<sub>3</sub></emphasis>. Показано два корректных плана: оптимальный план с временем окончания 24 и субоптимальный — с временем окончания 33. В данной задаче любой оптимальный план должен содержать время простоя. Coffman/ Denning, <emphasis>Operating Systems Theory</emphasis>, © 1973, p.86. Приведено с разрешения Prentice-Hall, Englewood Cliffs, New Jersey.</p>
     <p>Один из способов построить план можно грубо сформулировать так. Начинаем с пустого плана (с незаполненными временными промежутками для каждого процессора) и постепенно включаем в него задачи одну за другой, пока все задачи не будут исчерпаны. Как правило, на каждом шагу мы будем иметь несколько различных возможностей, поскольку окажется, что одновременно несколько задач-кандидатов ждут своего выполнения. Таким образом, для составления плана потребуется перебор. Мы можем сформулировать задачу планирования в терминах пространства состояний следующим образом:</p>
     <p>• состояния — это частично составленные планы;</p>
     <p>• преемник частичного плана получается включением в план еще одной задачи; другая возможность — оставить процессор, только что закончивший свою задачу, в состоянии простоя;</p>
     <p>• стартовая вершина — пустой план;</p>
     <p>• любой план, содержащий все задачи, — целевое состояние;</p>
     <p>• стоимость решения (подлежащая минимизации) — время окончания целевого плана;</p>
     <p>• стоимость перехода от одного частичного плана к другому равна <emphasis>К</emphasis><sub>2</sub>–<emphasis>К</emphasis><sub>1</sub> где <emphasis>К</emphasis><sub>1</sub>, <emphasis>К</emphasis><sub>2</sub> — времена окончания этих планов.</p>
     <p>Этот грубый сценарий требует некоторых уточнений. Во-первых, мы решим заполнять план в порядке возрастания времен, так что задачи будут включаться в него слева направо. Кроме того, при добавлении каждой задачи следует проверять, выполнены ли ограничения, связанные с отношениями предшествования. Далее, не имеет смысла оставлять процессор бездействующим на неопределенное время, если имеются задачи, ждущие своего запуска. Поэтому мы разрешим процессору простаивать только до того момента, когда какой-нибудь другой процессор завершит выполнение своей задачи. В этот момент мы еще раз вернемся к свободному процессору с тем, чтобы рассмотреть возможность приписывания ему какой-нибудь задачи.</p>
     <p>Теперь нам необходимо принять решение относительно представления проблемных ситуаций, т.е. частичных планов. Нам понадобится следующая информация:</p>
     <p>(1) список ждущих задач вместе с их временами выполнения;</p>
     <p>(2) текущая загрузка процессоров задачами.</p>
     <p>Добавим также для удобства программирования</p>
     <p>(3) время окончания (частичного) плана, т.е. самое последнее время окончания задачи среди всех задач, приписанных процессорам.</p>
     <p>Список ждущих задач вместе с временами их выполнения будем представлять в программе при помощи списка вида</p>
     <p><code>[ Задача1/Т1, Задача2/Т2, ... ]</code></p>
     <p>Текущую загрузку процессоров будем представлять как список решаемых задач, т.е. список пар вида</p>
     <p><code>[ Задача/ВремяОкончания ]</code></p>
     <p>В списке <emphasis>m</emphasis> таких пар, по одной на каждый процессор. Новая задача будет добавляться к плану в момент, когда закончится первая задача из этого списка. В связи с этим мы должны постоянно поддерживать упорядоченность списка загрузки по возрастанию времен окончания. Эти три компоненты частичного плана (ждущие задачи, текущая загрузка и время окончания плана) будут объединены в одно выражение вида</p>
     <p><code>Ждущие * Активные * ВремяОкончания</code></p>
     <p>Кроме этой информации у нас есть ограничения, налагаемые отношениями предшествования, которые в программе будут выражены в форме отношения</p>
     <p><code>предш( ЗадачаX, ЗадачаY)</code></p>
     <p>Рассмотрим теперь эвристическую оценку. Мы будем использовать довольно примитивную эвристическую функцию, которая не сможет обеспечить высокую эффективность управления алгоритмом поиска. Эта функция допустима, так что получение оптимального плана будет гарантировано. Однако следует заметить, что для решения более серьезных задач планирования потребуется более мощная эвристика.</p>
     <p>Нашей эвристической функцией будет оптимистическая оценка времени окончания частичного плана с учетом всех ждущих задач. Оптимистическая оценка будет вычисляться в предположении, что два из ограничений, налагаемых на действительно корректный план, ослаблены:</p>
     <p>(1) не учитываются отношения предшествования;</p>
     <p>(2) делается (не реальное) допущение, что возможно распределенное выполнение задачи одновременно на нескольких процессорах, причем сумма времен выполнения задачи на процессорах равна исходному времени выполнения этой задачи на одном процессоре.</p>
     <p>Пусть времена выполнения ждущих задач равны <emphasis>Т</emphasis><sub>1</sub>, <emphasis>Т</emphasis><sub>2</sub>, …, а времена окончания задач, выполняемых на процессорах — <emphasis>К</emphasis><sub>1</sub>, <emphasis>К</emphasis><sub>2</sub>, …. Тогда оптимистическая оценка времени <emphasis>ОбщКон</emphasis> окончания всех активных к настоящему моменту, а также всех ждущих задач имеет вид:</p>
     <p> <image l:href="#img_1.png"/></p>
     <p>где <emphasis>m</emphasis> — число процессоров. Пусть время окончания текущего частичного плана равно</p>
     <p> <image l:href="#img_2.png"/></p>
     <p>Тогда эвристическая оценка <emphasis>H</emphasis> (дополнительное время для включения в частичный план ждущих задач) определяется следующим выражением:</p>
     <p>if <emphasis>ОбщКон&gt;Кон</emphasis> then <emphasis>H = ОбщКон-Кон</emphasis> else <emphasis>H=</emphasis>0</p>
     <p>Программа, содержащая определения отношений, связанных с пространством состояний нашей задачи планирования, приведена полностью на рис. 12.9. Эта программа включает в себя также спецификацию конкретной задачи планирования, показанной на рис. 12.3. Одно из оптимальных решений, полученных в процессе поиска с предпочтением в определенном таким образом пространстве состояний, показано на рис. 12.8.</p>
     <empty-line/>
     <p><code>/* Отношения для задачи планирования.</code></p>
     <p><code>Вершины пространства состояний - частичные планы,</code></p>
     <p><code>записываемые как</code></p>
     <p><code> [ Задача1/Т1, Задача2/Т2, ...]*</code></p>
     <p><code> [ Задача1/К1, Задача2/К2, ...]* ВремяОкончания</code></p>
     <p><code>В первом списке указываются ждущие задачи и продолжительности их выполнения; во втором - текущие решаемые задачи и их времена окончания, упорядоченные так, чтобы выполнялись неравенства K1&#8804;K2, K2&#8804;K3, ... .</code></p>
     <p><code>Время окончания плана - самое последнее по времени время окончания задачи.</code></p>
     <p><code>*/</code></p>
     <p><code>после( Задачи1*[ _ /К | Акт1]*Кон1,</code></p>
     <p><code> Задачи2*Акт2*Кон2, Ст):-</code></p>
     <p><code> удалить( Задача/T, Задачи1, Задачи2),</code></p>
     <p><code>  % Взять ждущую задачу</code></p>
     <p><code> not( принадлежит( Здч1/_, Задачи2),</code></p>
     <p><code> раньше( ЗДЧ, Задача) ),</code></p>
     <p><code>  % Проверить предшествование</code></p>
     <p><code> not( принадлежит( Здч1/К1, Акт1), К1&lt;К2,</code></p>
     <p><code> раньше( К1, Задача) ),    % Активные задачи</code></p>
     <p><code> Время is К + T,</code></p>
     <p><code>  % Время окончания работающей задачи</code></p>
     <p><code> встав( ЗадачаВремя, Акт1, Акт2, Кон1, Кон2),</code></p>
     <p><code> Ст is Кон2 - Кон1.</code></p>
     <p><code>после( Задачи*[ _ /К | Акт1]*Кон, Задачи2*Акт2*Кон, 0):-</code></p>
     <p><code> вставпростой( К, Акт1, Акт2).</code></p>
     <p><code>  % Оставить процессор бездействующим</code></p>
     <empty-line/>
     <p><code>раньше( Задача1, Задача2) :-</code></p>
     <p><code>  % В соответствии с предшествованием</code></p>
     <p><code> предш( Задача1, Задача2).</code></p>
     <p><code>  % Задача1 раньше, чем Задача2</code></p>
     <p><code>раньше( Здч1, Здч2) :-</code></p>
     <p><code> предш( Здч, Здч2),</code></p>
     <p><code> раньше( Здч1, Здч).</code></p>
     <empty-line/>
     <p><code>встав( Здч/А, [Здч1/В | Спис], [Здч/А, Здч1/В | Спис], К, К):-</code></p>
     <p><code>  % Список задач упорядочен</code></p>
     <p><code> А =&lt; В, !.</code></p>
     <p><code>встав( Здч/А, [Здч1/В | Спнс], [Здч1/В | Спис1], К1, К2) :-</code></p>
     <p><code> встав( Здч/А, Спис, Спис1, Kl, К2).</code></p>
     <p><code>встав( Здч/А, [ ], [Здч/А], _, А).</code></p>
     <empty-line/>
     <p><code>вставпростой( А, [Здч/В | Спис], [простой/В, Здч/В | Спис]):-</code></p>
     <p><code>           % Оставить процессор бездействующим</code></p>
     <p><code> А &lt; В, !. % До ближайшего времени окончания</code></p>
     <empty-line/>
     <p><code>вставпростой( А, [Здч/В | Спис], [Здч/В | Спис1]) :-</code></p>
     <p><code> вставпростой( А, Спис, Спис1 ).</code></p>
     <empty-line/>
     <p><code>удалить( А, [А | Спис], Спис ).</code></p>
     <p><code>  % Удалить элемент из списка</code></p>
     <p><code>удалить( А, [В | Спис], [В | Спис1] ):-</code></p>
     <p><code> удалить( А, Спис, Спис1 ).</code></p>
     <empty-line/>
     <p><code>цель( [] *_*_ ). % Целевое состояние: нет ждущих задач</code></p>
     <empty-line/>
     <p><code>% Эвристическая оценка частичного плана основана на</code></p>
     <p><code>% оптимистической оценке последнего времени окончания</code></p>
     <p><code>% этого частичного плана,</code></p>
     <p><code>% дополненного всеми остальными ждущими задачами.</code></p>
     <p><code>h( Задачи * Процессоры * Кон, H) :-</code></p>
     <p><code> сумвремя( Задачи, СумВремя),</code></p>
     <p><code>  % Суммарная продолжительность</code></p>
     <p><code>  % ждущих задач</code></p>
     <p><code> всепроц( Процессоры, КонВремя, N),</code></p>
     <p><code>  % КонВремя - сумма времен окончания</code></p>
     <p><code>  % для процессоров, N - их количество</code></p>
     <p><code> ОбщКон is ( СумВремя + КонВремя)/N,</code></p>
     <p><code> ( ОбщКон &gt; Кон, !, H is ОбщКон - Кон; H = 0).</code></p>
     <empty-line/>
     <p><code>сумвремя( [], 0).</code></p>
     <p><code>сумвремя( [ _ /T | Задачи], Вр) :-</code></p>
     <p><code> сумвремя( Задачи, Вр1),</code></p>
     <p><code> Вр is Bp1 + T.</code></p>
     <empty-line/>
     <p><code>всепроц( [], 0, 0).</code></p>
     <p><code>всепроц( [ _ /T | СписПроц], КонВр, N) :-</code></p>
     <p><code> всепроц( СписПроц, КонВр1, N1),</code></p>
     <p><code> N is N1 + 1,</code></p>
     <p><code> КонВр is КонВр1 + T.</code></p>
     <empty-line/>
     <p><code>% Граф предшествования задач</code></p>
     <p><code> предш( t1, t4). предш( t1, t5). предш( t2, t4).</code></p>
     <p><code> предш( t2, t5). предш( t3, t5). предш( t3, t6).</code></p>
     <p><code> предш( t3, t7).</code></p>
     <empty-line/>
     <p><code>% Стартовая вершина</code></p>
     <p><code>старт( [t1/4, t2/2, t3/2, t4/20, t5/20, t6/11, t7/11] *</code></p>
     <p><code> [простой/0, простой/0, простой/0] * 0 ).</code></p>
     <p><strong>Рис. 12.9.</strong> Отношения для задачи планирования. Даны также определения отношений для конкретной задачи планирования с рис. 12.8: граф предшествования и исходный (пустой) план в качестве стартовой вершины.</p>
     <empty-line/>
     <subtitle>Проект</subtitle>
     <p>Вообще говоря, задачи планирования характеризуются значительной комбинаторной сложностью. Наша простая эвристическая функция не обеспечивает высокой эффективности управления поиском. Предложите другие эвристические функции и проведите с ними эксперименты.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Для оценки степени удаленности некоторой вершины пространства состояний от ближайшей целевой вершины можно использовать эвристическую информацию. В этой главе были рассмотрены численные эвристические оценки.</p>
     <p>• Эвристический принцип поиска с предпочтением направляет процесс поиска таким образом, что для продолжения поиска всегда выбирается вершина, наиболее перспективная с точки зрения эвристической оценки.</p>
     <p>• В этой главе был запрограммирован алгоритм поиска, основанный на указанном принципе и известный в литературе как А*-алгоритм.</p>
     <p>• Для того, чтобы решить конкретную задачу при помощи А*-алгоритма, необходимо определить пространство состояний и эвристическую функцию. Для сложных задач наиболее трудным моментом является подбор хорошей эвристической функции.</p>
     <p>• <emphasis>Теорема о допустимости</emphasis> помогает установить, всегда ли А*-алгоритм, использующий некоторую конкретную эвристическую функцию, находит оптимальное решение.</p>
     <subtitle>Литература</subtitle>
     <p>Программа поиска с предпочтением, представленная в настоящей главе, — это один из многих вариантов похожих друг на друга программ, из которых А*-алгоритм наиболее популярен. Общее описание А*-алгоритма можно найти в книгах Nillson (1971, 1980) или Winston (1984). Теорема о допустимости впервые доказана авторами статьи Hart, Nilsson, and Raphael (1968). Превосходное и строгое изложение многих разновидностей алгоритмов поиска с предпочтением и связанных с ними математических результатов дано в книге Pearl (1984). В статье Doran and Michie (1966) впервые изложен поиск с предпочтением, управляемый оценкой расстояния до цели.</p>
     <p>Головоломка "игра в восемь" использовалась многими исследователями в области искусственного интеллекта в качестве тестовой задачи при изучении эвристических принципов (см., например, Doran and Michie (1966), Michie and Ross (1970) и Gaschnig (1979)).</p>
     <p>Задача планирования, рассмотренная в настоящей главе, также как и многие ее разновидности, возникает во многих прикладных областях в ситуации, когда необходимо спланировать обслуживание запросов на ресурсы. Один из примеров — операционные системы вычислительных машин. Задача планирования со ссылкой на это конкретное приложение изложена в книге Coffman and Denning (1973).</p>
     <p>Найти хорошую эвристику — дело важное и трудное, поэтому изучение эвристик — одна из центральных тем в искусственном интеллекте. Существуют, однако, некоторые границы, за которые невозможно выйти, двигаясь в направлении улучшения качества эвристик. Казалось бы, все, что необходимо для эффективного решения комбинаторной задачи — это найти мощную эвристику. Однако есть задачи (в том числе многие задачи планирования), для которых не существует универсальной эвристики, обеспечивающей во всех случаях как эффективность, так и допустимость. Многие теоретические результаты, имеющие отношение к этому ограничению, собраны в работе Garey and Johnson (1979).</p>
     <empty-line/>
     <p>Coffman E.G. and Denning P.J. (1973). <emphasis>Operating Systems Theory.</emphasis> Prentice-Hall.</p>
     <p>Doran J. and Michie D. (1966). Experiments with the graph traverser program. <emphasis>Proc. Royal Socieiy of London</emphasis> <strong>294(A)</strong>: 235-259.</p>
     <p>Garey M. R. and Johnson D. S. (1979). <emphasis>Computers and Intractability</emphasis>. W. H. Freeman. [Имеется перевод: Гэри M., Джонсон Д. С- Вычислительные машины и труднорешаемые задачи. — M.: Мир, 1982.]</p>
     <p>Gaschnig J. (1979). Performance measurement and analysis of certain search algorithms. Carnegie-Mellon University: Computer Science Department-Technical Report CMU-CS-79-124 (Ph. D. Thesis).</p>
     <p>Hart P.E., Nilsson N.J. and Raphael B. (1968). A formal basis for the heuristic determination of minimum cost paths. <emphasis>IEEE Transactions on Systems Sciences and Cybernetics</emphasis> <strong>SSC-4(2)</strong>:100-107</p>
     <p>Michie D. and Ross R. (1970). Experiments with the adaptive graph traverser. <emphasis>Machine Intelligence</emphasis> <strong>5</strong>: 301–308.</p>
     <p>Nilsson N.J. (1971). <emphasis>Problem — Solving Methods in Artificial Intelligence</emphasis>. McGraw-Hill. [Имеется перевод: Нильсон H. Искусственный интеллект. Методы поиска решений. — M: Мир, 1973.]</p>
     <p>Nilsson N. J. (1980). <emphasis>Principles of Artificial Intelligence</emphasis>. Tioga; also Springer-Verlag.</p>
     <p>Pearl J. (1984). <emphasis>Heuristics: Intelligent Search Strategies for Computer Problem Solving</emphasis>. Addison-Wesley.</p>
     <p>Winston P. H. (1984). <emphasis>Artificial Intelligence</emphasis> (second edition). Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — M.: Мир, 1980.]</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 13</p>
     <p>Сведение задач к подзадачам. И/ИЛИ-Графы</p>
    </title>
    <section>
     <p>Представление в виде И/ИЛИ-графов наиболее хорошо приспособлено для задач, которые естественным образом разбиваются на взаимно независимые подзадачи. Примерами таких задач могут служить поиск маршрута, символическое интегрирование, а также игровые задачи, доказательство теорем и т.п. В этой главе мы разработаем программы для поиска в И/ИЛИ-графах, в том числе программу поиска с предпочтением, управляемого эвристиками.</p>
    </section>
    <section>
     <title>
      <p>13.1. Представление задач в виде И/ИЛИ-графов</p>
     </title>
     <p>В главах 11 и 12, говоря о решении задач, мы сконцентрировали свое внимание на пространстве состояний как средстве представления этих задач. В соответствии с таким подходом решение задач сводилось к поиску пути в графе пространства состояний. Однако для некоторых категорий задач представление в форме И/ИЛИ-графа является более естественным. Такое представление основано на разбиении задач на подзадачи. Разбиение на подзадачи дает преимущества в том случае, когда подзадачи взаимно независимы, а, следовательно, и решать их можно независимо друг от друга.</p>
     <p>Проиллюстрируем это на примере. Рассмотрим задачу отыскания на карте дорог маршрута между двумя заданными городами, как показано на рис. 13.1. Не будем пока учитывать длину путей. Разумеется, эту задачу можно сформулировать как поиск пути в пространстве состояний. Соответствующее пространство состояний выглядело бы в точности, как карта рис. 13.1: вершины соответствуют городам, дуги — непосредственным связям между городами. Тем не менее давайте построим другое представление, основанное на естественном разбиении этой задачи на подзадачи.</p>
     <image l:href="#_88.png"/>
     <p><strong>Рис. 13.1.</strong> Поиск маршрута из <emphasis>а</emphasis> в <emphasis>z</emphasis> на карте дорог. Через реку можно переправиться в городах <emphasis>f</emphasis> и <emphasis>g</emphasis>. И/ИЛИ-представление этой задачи показано на рис. 13.2.</p>
     <p>На карте рис. 13.1 мы видим также реку. Допустим, что переправиться через нее можно только по двум мостам: один расположен в городе <emphasis>f</emphasis>, другой — в городе <emphasis>g</emphasis>. Очевидно, что искомый маршрут обязательно должен проходить через один из мостов, а значит, он должен пройти либо через <emphasis>f</emphasis>, либо через <emphasis>g</emphasis>. Таким образом, мы имеем две главных альтернативы:</p>
     <p>Для того, чтобы найти путь из <emphasis>а</emphasis> в <emphasis>z</emphasis>, необходимо найти <emphasis>одно из двух</emphasis>:</p>
     <p>(1) путь из <emphasis>а</emphasis> в <emphasis>z</emphasis>, проходящий через <emphasis>f</emphasis>, или</p>
     <p>(2) путь из <emphasis>а</emphasis> в <emphasis>z</emphasis>, проходящий через  <emphasis>g</emphasis>.</p>
     <image l:href="#_89.png"/>
     <p><strong>Рис. 13.2.</strong> И/ИЛИ-представление задачи поиска маршрута рис. 13.1. Вершины соответствуют задачам или подзадачам, полукруглые дуги означают, что все (точнее, обе) подзадачи должны быть решены.</p>
     <p>Теперь каждую из этих двух альтернативных задач можно, в свою очередь, разбить следующим образом:</p>
     <p>(1) Для того, чтобы найти путь из <emphasis>a</emphasis> в <emphasis>z</emphasis> через <emphasis>f</emphasis>, необходимо:</p>
     <p>   1.1 найти путь из <emphasis>а</emphasis> и <emphasis>f  и</emphasis></p>
     <p>   1.2 найти путь из <emphasis>f</emphasis> в <emphasis>z</emphasis>.</p>
     <p>(2) Для того, чтобы найти путь из <emphasis>a</emphasis> в <emphasis>z</emphasis> через <emphasis>g</emphasis>, необходимо:</p>
     <p>   2.1 найти путь из <emphasis>а</emphasis> в <emphasis>g  и</emphasis></p>
     <p>   2.2 найти путь из <emphasis>g</emphasis> в <emphasis>z</emphasis>.</p>
     <image l:href="#_90.png"/>
     <p><strong>Рис. 13.3.</strong> (а) Решить P — это значит решить  P<sub>1</sub> или Р<sub>2</sub> или … (б) Решить Q — это значит решить все: Q<sub>1</sub> и Q<sub>2</sub> и ….</p>
     <p>Итак, мы имеем две главных альтернативы для решения исходной задачи: (1) путь через <emphasis>f</emphasis> или (2) путь через <emphasis>g</emphasis>. Далее, каждую из этих альтернатив можно <emphasis>разбить на подзадачи</emphasis> (1.1 и 1.2 или 2.1 и 2.2 соответственно). Здесь важно то обстоятельство, что каждую из подзадач в обоих альтернативах можно решать независимо от другой. Полученное разбиение исходной задачи можно изобразить в форме <emphasis>И/ИЛИ-графа</emphasis> (рис. 13.2). Обратите внимание на полукруглые дуги, которые указывают на отношение И между соответствующими подзадачами. Граф, показанный на рис. 13.2 — это всего лишь верхняя часть всего И/ИЛИ-дерева. Дальнейшее разбиение подзадач можно было бы строить на основе введения дополнительных промежуточных городов.</p>
     <p>Какие вершины  И/ИЛИ-графа  являются целевыми? Целевые вершины — это тривиальные, или "примитивные" задачи. В нашем примере такой подзадачей можно было бы считать подзадачу "найти путь из <emphasis>а</emphasis> в <emphasis>с</emphasis>", поскольку между городами <emphasis>а</emphasis> и <emphasis>с</emphasis> на карте имеется непосредственная связь.</p>
     <p>Рассматривая наш пример, мы ввели ряд важных понятий. И/ИЛИ-граф — это направленный граф, вершины которого соответствуют задачам, а дуги — отношениям между задачами. Между дугами также существуют свои отношения. Это отношения И и ИЛИ, в зависимости от того, должны ли мы решить только одну из задач-преемников или же несколько из них (см. рис. 13.3). В принципе из вершины могут выходить дуги, находящиеся в отношении И вместе с дугами, находящимися в отношении ИЛИ. Тем не менее, мы будем предполагать, что каждая вершина имеет либо только И-преемников, либо только ИЛИ-преемников; дело в том, что в такую форму можно преобразовать любой И/ИЛИ граф, вводя в него при необходимости вспомогательные ИЛИ-вершины. Вершину, из которой выходят только И-дуги, называют И-вершиной; вершину, из которой выходят только ИЛИ-дуги, — ИЛИ-вершиной.</p>
     <p>Когда задача представлялась в форме пространства состояний, ее решением был путь в этом пространстве. Что является решением в случае И/ИЛИ-представления? Решение должно, конечно, включать в себя все подзадачи И-вершины. Следовательно, это уже не путь, а дерево. Такое решающее дерево T определяется следующим образом:</p>
     <p>• исходная задача P — это корень дерева T;</p>
     <p>• если P является ИЛИ-вершиной, то в T содержится только один из ее преемников (из И/ИЛИ-графа) вместе со своим собственным решающим деревом;</p>
     <p>• если P — это И-вершина, то все ее преемники (из И/ИЛИ-графа) вместе со своими решающими деревьями содержатся в T.</p>
     <image l:href="#_91.png"/>
     <p><strong>Рис. 13.4.</strong> (а) Пример И/ИЛИ-графа: <emphasis>d</emphasis>, <emphasis>g</emphasis> и <emphasis>h</emphasis> — целевые вершины; <emphasis>a</emphasis> — исходная задача. (b) и (с) Два решающих дерева, стоимости которых равны 9 и 8 соответственно. Здесь стоимость решающего дерева определена как сумма стоимостей всех входящих в него дуг.</p>
     <p>Иллюстрацией к этому определению может служить рис. 13.4. Используя стоимости, мы можем формулировать критерии оптимальности решения. Например, можно определить стоимость решающего графа как сумму стоимостей всех входящих в него дуг. Тогда, поскольку обычно мы заинтересованы в минимизации стоимости, мы отдадим предпочтение решающему графу, изображенному на рис. 13.4(с).</p>
     <p>Однако мы не обязательно должны измерять степень оптимальности решения, базируясь на стоимостях дуг. Иногда более естественным окажется приписывать стоимость не дугам, а вершинам, или же и тем, и другим одновременно.</p>
     <p>Подведем итоги:</p>
     <p>• И/ИЛИ-представление основано на философии сведения задач к подзадачам.</p>
     <p>• Вершины И/ИЛИ-графа соответствуют задачам; связи между вершинами — отношениям между задачами.</p>
     <p>• Вершина, из которой выходят ИЛИ-связи, называется ИЛИ-вершиной. Для того, чтобы решить соответствующую задачу, нужно решить одну из ее задач-преемников.</p>
     <p>• Вершина, из которой выходят И-связи, называется И-вершиной. Для того, чтобы решить соответствующую задачу, нужно решить все ее задачи-преемники.</p>
     <p>• При заданном И/ИЛИ-графе конкретная задача специфицируется заданием</p>
     <p>  стартовой вершины и</p>
     <p>  целевого условия для распознавания</p>
     <p>  целевых вершин.</p>
     <p>• <emphasis>Целевые вершины</emphasis> (или "терминальные вершины") соответствуют тривиальным (или "примитивным") задачам.</p>
     <p>• Решение представляется в виде <emphasis>решающего графа</emphasis> — подграфа всего И/ИЛИ-графа.</p>
     <p>• Представление задач в форме пространства состояний можно рассматривать как специальный частный случай И/ИЛИ-представления, когда все вершины И/ИЛИ-графа являются ИЛИ-вершинами.</p>
     <p>• И/ИЛИ-представление имеет преимущество в том случае, когда вершинами, находящимися в отношении И, представлены подзадачи, которые можно решать независимо друг от друга. Критерий независимости можно несколько ослабить, а именно потребовать, чтобы существовал такой порядок решения И-задач, при котором решение более "ранних" подзадач не разрушалось бы при решении более "поздних" под задач.</p>
     <p>• Дугам или вершинам, или и тем, и другим можно приписать стоимости с целью получить возможность сформулировать критерий оптимальности решения.</p>
    </section>
    <section>
     <title>
      <p>13.2. Примеры И/ИЛИ-представления задач </p>
     </title>
     <section>
      <title>
       <p>13.2.1. И/ИЛИ-представление задачи поиска маршрута</p>
      </title>
      <p>Для задачи отыскания кратчайшего маршрута (рис. 13.1) И/ИЛИ-граф вместе с функцией стоимости можно определить следующим образом:</p>
      <p>• ИЛИ-вершины представляются в форме X-Z, что означает: найти кратчайший путь из X в Z.</p>
      <p>• И-вершины имеют вид </p>
      <p>  X-Z через Y</p>
      <p>что означает: найти кратчайший путь из X в Z, проходящий через Y.</p>
      <p>• Вершина X-Z является целевой вершиной (примитивной задачей), если на карте существует непосредственная связь между X и Z.</p>
      <p>• Стоимость каждой целевой вершины X-Z равна расстоянию, которое необходимо  преодолеть по дороге, соединяющей X с Z.</p>
      <p>• Стоимость всех остальных (нетерминальных) вершин равна 0.</p>
      <p>Стоимость решающего графа равна сумме стоимостей всех его вершин (в нашем случае это просто сумма стоимостей всех терминальных вершин). В задаче рис. 13.1 стартовая вершина — это <emphasis>а-z</emphasis>. На рис. 13.5 показан решающий граф, имеющий стоимость 9. Это дерево соответствует пути <code>[a, b, d, f, i, z]</code>, который можно построить, если пройти по всем листьям решающего дерева слева направо.</p>
      <image l:href="#_92.png"/>
      <p><strong>Рис. 13.5.</strong> Решающее дерево минимальной стоимости для задачи поиска маршрута рис. 13.1, сформулированной в терминах И/ИЛИ-графа. </p>
     </section>
     <section>
      <title>
       <p>13.2.2. Задача о ханойской башне</p>
      </title>
      <p>Задача о ханойской башне (рис. 13.6) — это еще один классический пример эффективного применения метода разбиения задачи на подзадачи и построения И / ИЛИ-графа. Для простоты мы рассмотрим упрощенную версию этой задачи, когда в ней участвует только три диска:</p>
      <p>Имеется три колышка 1, 2 и 3 и три диска <emphasis>а</emphasis>, <emphasis>b</emphasis> и <emphasis>с</emphasis> (<emphasis>а</emphasis> — наименьший из них, а <emphasis>с</emphasis> — наибольший). Первоначально все диски находятся на колышке 1. Задача состоит в том, чтобы переложить все диски на колышек 3. На каждом шагу можно перекладывать только один диск, причем никогда нельзя помещать больший диск на меньший.</p>
      <p>Эту задачу можно рассматривать как задачу достижения следующих трех целей:</p>
      <p>(1) Диск <emphasis>а</emphasis> — на колышек 3.</p>
      <p>(2) Диск <emphasis>b</emphasis> — на колышек 3.</p>
      <p>(3) Диск <emphasis>с</emphasis> — на колышек 3.</p>
      <p>Беда в том, что эти цели не независимы. Например, можно сразу переложить диск <emphasis>а</emphasis> на колышек 3, и первая цель будет достигнута. Но тогда две другие цели станут недостижимыми (если только мы не отменим первое наше действие). К счастью, существует такой удобный порядок достижения этих целей, из которого можно легко вывести искомое решение.</p>
      <image l:href="#_93.png"/>
      <p><strong>Рис. 13.6.</strong> Задача о ханойской башне</p>
      <p>Порядок этот можно установить при помощи следующего рассуждения: самая трудная цель — это цель 3 (диск <emphasis>с</emphasis> — на колышек 3), потому что на диск <emphasis>c</emphasis> наложено больше всего ограничений. В подобных ситуациях часто срабатывает хорошая идея: пытаться достичь первой самую трудную цель. Этот принцип основан на следующей логике: поскольку другие цели достигнуть легче (на них меньше ограничений), можно надеяться на то, что их достижение возможно без отмены действий на достижение самой трудной цели.</p>
      <p>Применительно к нашей задаче это означает, что необходимо придерживаться следующей стратегии:</p>
      <p>Первой достигнуть цель "диск <emphasis>с</emphasis> — на колышек 3", а затем — все остальные.</p>
      <p>Но первая цель не может быть достигнута сразу, так как в начальной ситуации диск <emphasis>с</emphasis> двигать нельзя. Следовательно, сначала мы должны подготовить этот ход, и наша стратегия принимает такой вид</p>
      <p>(1) Обеспечить возможность перемещения диска <emphasis>с</emphasis> с 1 на 3.</p>
      <p>(2) Переложить <emphasis>с</emphasis> с 1 на 3.</p>
      <p>(3) Достигнуть остальные цели (<emphasis>а</emphasis> на 3 и <emphasis>b</emphasis> на 3).</p>
      <p>Переложить <emphasis>c</emphasis> с 1 на 3 возможно только в том случае, если диск <emphasis>а</emphasis> и <emphasis>b</emphasis> оба надеты на колышек 2. Таким образом наша исходная задача перемещения <emphasis>а</emphasis>, <emphasis>b</emphasis> и <emphasis>с</emphasis> с 1 на 3 сводится к следующим трем подзадачам:</p>
      <p>Для того, чтобы переложить <emphasis>a</emphasis>, <emphasis>b</emphasis> и <emphasis>с</emphasis> с 1 на 3, необходимо</p>
      <p>(1) переложить <emphasis>а</emphasis> и <emphasis>b</emphasis> с 1 на 2, <emphasis>и</emphasis></p>
      <p>(2) переложить <emphasis>с</emphasis> с 1 на 3, <emphasis>и</emphasis></p>
      <p>(3) переложить <emphasis>а</emphasis> и <emphasis>b</emphasis> с 2 на 3.</p>
      <p>Задача 2 тривиальна (она решается за один шаг). Остальные две подзадачи можно решать независимо от задачи 2, так как диски <emphasis>а</emphasis> и <emphasis>b</emphasis> можно двигать, не обращая внимание на положение диска <emphasis>с</emphasis>. Для решения задач 1 и 3 можно применить тот же самый принцип разбиения (на этот раз диск <emphasis>b</emphasis> будет самым "трудным"). В соответствии с этим принципом задача 1 сводится к трем тривиальным подзадачам:</p>
      <p>Для того, чтобы переложить <emphasis>а</emphasis> и <emphasis>b</emphasis> с 1 на 2, необходимо:</p>
      <p>(1) переложить <emphasis>а</emphasis> с 1 на 3, <emphasis>и</emphasis></p>
      <p>(2) переложить <emphasis>b</emphasis> с 1 на 2, <emphasis>и</emphasis></p>
      <p>(3) переложить <emphasis>а</emphasis> с 3 на 2.</p>
     </section>
     <section>
      <title>
       <p>13.2.3. Формулировка игровых задач в терминах И/ИЛИ-графов</p>
      </title>
      <p>Такие игры, как шахматы или шашки, естественно рассматривать как задачи, представленные И/ИЛИ-графами. Игры такого рода называются играми двух лиц с полной информацией. Будем считать, что существует только два возможных исхода игры: ВЫИГРЫШ и ПРОИГРЫШ. (Об играх с тремя возможными исходами — ВЫИГРЫШ, ПРОИГРЫШ и НИЧЬЯ, можно также говорить, что они имеют только два исхода: ВЫИГРЫШ и НЕВЫИГРЫШ). Так как участники игры ходят по очереди, мы имеем два вида позиций, в зависимости от того, чей ход. Давайте условимся называть участников игры "игрок" и "противник", тогда мы будем иметь следующие два вида позиций: позиция с ходом игрока ("позиция игрока") и позиция с ходом противника ("позиция противника"). Допустим также, что начальная позиция <emphasis>P</emphasis> — это позиция игрока. Каждый вариант хода игрока в этой позиции приводит к одной из позиций противника  <emphasis>Q</emphasis><sub>1</sub>, <emphasis>Q</emphasis><sub>2</sub>, <emphasis>Q</emphasis><sub>3</sub>, … (см. рис. 13.7). Далее каждый вариант хода противника в позиции <emphasis>Q</emphasis><sub>1</sub> приводит к одной из позиций игрока <emphasis>R</emphasis><sub>11</sub>, <emphasis>R</emphasis><sub>12</sub>, …. В  И/ИЛИ-дереве, показанном на рис. 13.7, вершины соответствуют позициям, а дуги — возможным ходам. Уровни позиций игрока чередуются в дереве с уровнями позиций противника. Для того, чтобы выиграть в позиции <emphasis>P</emphasis>, нужно найти ход, переводящий <emphasis>P</emphasis> в выигранную позицию <emphasis>Q<sub>i</sub></emphasis>. (при некотором <emphasis>i</emphasis>). Таким образом, игрок выигрывает в позиции <emphasis>P</emphasis>, если он выигрывает в <emphasis>Q<sub>1</sub></emphasis>, <emphasis>или  Q<sub>2</sub></emphasis>, <emphasis>или  Q<sub>3</sub></emphasis>, <emphasis>или</emphasis> …. Следовательно, <emphasis>P</emphasis> — это ИЛИ-вершина. Для любого <emphasis>i</emphasis> позиция  <emphasis>Q<sub>i</sub></emphasis> — это позиция противника, поэтому если в этой позиции выигрывает игрок, то он выигрывает и после каждого варианта хода противника. Другими словами, игрок выигрывает в <emphasis>Q<sub>i</sub></emphasis>, если он выигрывает во всех позициях <emphasis>R<sub>i1</sub> и R<sub>i2</sub> и</emphasis> ….  Таким образом, все позиции противника — это И-вершины. Целевые вершины — это позиции, выигранные согласно правилам игры, например позиции, в которых король противника получает мат. Позициям проигранным соответствуют задачи, не имеющие решения. Для того, чтобы решить игровую задачу, мы должны построить решающее дерево, гарантирующее победу игрока независимо от ответов противника. Такое дерево задает полную стратегию достижения выигрыша: для каждого возможного продолжения, выбранного противником, в дереве стратегии есть ответный ход, приводящий к победе.</p>
      <image l:href="#_94.png"/>
      <p><strong>Рис. 13.7.</strong> Формулировка игровой задачи для игры двух лиц в форме И/ИЛИ-дерева; участники игры: "игрок" и "противник".</p>
     </section>
    </section>
    <section>
     <title>
      <p>13.3. Базовые процедуры поиска в И/ИЛИ-графах</p>
     </title>
     <p>В этом разделе нас будет интересовать <emphasis>какое-нибудь</emphasis> решение задачи независимо от его стоимости, поэтому проигнорируем пока стоимости связей или вершин И/ИЛИ-графа. Простейший способ организовать поиск в И/ИЛИ-графах средствами Пролога — это использовать переборный механизм, заложенный в самой пролог-системе. Оказывается, что это очень просто сделать, потому что процедурный смысл Пролога это и есть не что иное, как поиск в И/ИЛИ-графе. Например, И/ИЛИ-граф рис. 13.4 (без учета стоимостей дуг) можно описать при помощи следующих предложений:</p>
     <p><code>а :- b.    % а - ИЛИ-вершина с двумя преемниками</code></p>
     <p><code>а :- с.    % b и  с</code></p>
     <p><code>b :- d, e. % b - И-вершина с двумя преемниками d и e</code></p>
     <p><code>с :- h.</code></p>
     <p><code>с :- f, g.</code></p>
     <p><code>f :- h, i.</code></p>
     <p><code>d. g. h.   % d, g и h - целевые вершины</code></p>
     <p>Для того, чтобы узнать, имеет ли эта задача решение, нужно просто спросить:</p>
     <p><code>?- а.</code></p>
     <p>Получив этот вопрос, пролог-система произведет поиск в глубину в дереве рис. 13.4 и после того, как пройдет через все вершины подграфа, соответствующего решающему дереву рис. 13.4(b), ответит "да".</p>
     <p>Преимущество такого метода программирования И/ИЛИ-поиска состоит в его простоте. Но есть и недостатки:</p>
     <p>• Мы получаем ответ "да" или "нет", но не получаем решающее дерево. Можно было бы восстановить решающее дерево при помощи трассировки программы, но такой способ неудобен, да его и недостаточно, если мы хотим иметь возможность явно обратиться к решающему дереву как к объекту программы.</p>
     <p>• В эту программу трудно вносить добавления, связанные с обработкой стоимостей.</p>
     <p>• Если наш И/ИЛИ-граф — это граф общего вида, содержащий циклы, то пролог-система, следуя стратегии в глубину, может войти в бесконечный рекурсивный цикл.</p>
     <p>Попробуем постепенно исправить эти недостатки. Сначала определим нашу собственную процедуру поиска в глубину для И/ИЛИ-графов.</p>
     <p>Прежде всего мы должны изменить представление И/ИЛИ-графов. С этой целью введём бинарное отношение, изображаемое инфиксным оператором '<code>---&gt;</code>'. Например, вершина <emphasis>а</emphasis> с двумя ИЛИ-преемниками будет представлена предложением</p>
     <p><code>а ---&gt; или : [b, с].</code></p>
     <p>Оба символа '<code>---&gt;</code>' и '<code>:</code>' — инфиксные операторы, которые можно определить как</p>
     <p><code>:- op( 600, xfx, ---&gt;).</code></p>
     <p><code>:- op( 500, xfx, :).</code></p>
     <p>Весь И/ИЛИ-граф рис. 13.4 теперь можно задать при помощи множества предложений</p>
     <p><code>а ---&gt; или : [b, с].</code></p>
     <p><code>b ---&gt; и : [d, e].</code></p>
     <p><code>с ---&gt; и : [f, g].</code></p>
     <p><code>e ---&gt; или : [h].</code></p>
     <p><code>f ---&gt; или : [h, i].</code></p>
     <p><code>цель( d). цель( g). цель( h).</code></p>
     <p>Процедуру поиска в глубину в И/ИЛИ-графах можно построить, базируясь на следующих принципах:</p>
     <p>Для того, чтобы решить задачу вершины В, необходимо придерживаться приведенных ниже правил:</p>
     <p>(1) Если  В — целевая вершина, то задача решается тривиальным образом.</p>
     <p>(2) Если вершина В имеет ИЛИ-преемников, то нужно решить одну из соответствующих задач-преемников (пробовать решать их одну за другой, пока не будет найдена задача, имеющая решение).</p>
     <p>(3) Если вершина В имеет И-преемников, то нужно решить все соответствующие задачи (пробовать решать их одну за другой, пока они не будут решены все).</p>
     <p>Если применение этих правил не приводит к решению, считать, что задача не может быть решена.</p>
     <p>Соответствующая программа выглядит так:</p>
     <p><code>решить( Верш) :-</code></p>
     <p><code> цель( Верш).</code></p>
     <p><code>решить( Верш) :-</code></p>
     <p><code> Верш ---&gt; или : Вершины, % Верш - ИЛИ-вершина</code></p>
     <p><code> принадлежит( Верш1, Вершины),</code></p>
     <p><code>  % Выбор преемника  Верш1  вершины  Верш</code></p>
     <p><code> решить( Bepш1).</code></p>
     <p><code>решить( Верш) :-</code></p>
     <p><code> Верш ---&gt; и : Вершины,   % Верш - И-вершина</code></p>
     <p><code> решитьвсе( Вершины).</code></p>
     <p><code>  % Решить все задачи-преемники</code></p>
     <empty-line/>
     <p><code>решитьвсе( []).</code></p>
     <p><code>решитьвсе( [Верш | Вершины]) :-</code></p>
     <p><code> решить( Верш),</code></p>
     <p><code> решитьвсе( Вершины).</code></p>
     <p>Здесь <code>принадлежит</code> — обычное отношение принадлежности к списку.</p>
     <p>Эта программа все еще имеет недостатки:</p>
     <p>• она не порождает решающее дерево, и</p>
     <p>• она может зацикливаться, если И/ИЛИ-граф имеет соответствующую структуру (циклы).</p>
     <p>Программу нетрудно изменить с тем, чтобы она порождала решающее дерево. Необходимо так подправить отношение <code>решить</code>, чтобы оно имело два аргумента:</p>
     <p><code>решить( Верш, РешДер).</code></p>
     <p>Решающее дерево представим следующим образом. Мы имеем три случая:</p>
     <p>(1) Если <code>Верш</code> — целевая вершина, то соответствующее решающее дерево и есть сама эта вершина.</p>
     <p>(2) Если <code>Верш</code> — ИЛИ-вершина, то решающее дерево имеет вид</p>
     <p><code>Верш ---&gt; Поддерево</code></p>
     <p>где <code>Поддерево</code> — это решающее дерево для одного из преемников вершины <code>Верш</code>.</p>
     <p>(3) Если <code>Верш</code> — И-вершина, то решающее дерево имеет вид</p>
     <p><code>Верш ---&gt; и : Поддеревья</code></p>
     <p>где <code>Поддеревья</code> — список решающих деревьев для всех преемников вершины <code>Верш</code>.</p>
     <empty-line/>
     <p><code>% Поиск в глубину для И/ИЛИ-графов</code></p>
     <p><code>% Процедура решить( Верш, РешДер) находит решающее дерево для</code></p>
     <p><code>% некоторой вершины в И / ИЛИ-графе</code></p>
     <p><code>решить( Верш, Верш) :-    % Решающее дерево для целевой</code></p>
     <p><code> цель( Верш).             % вершины - это сама вершина</code></p>
     <p><code>решить( Верш, Верш ---&gt; Дер) :-</code></p>
     <p><code> Верш ---&gt; или : Вершины, % Верш - ИЛИ-вершина</code></p>
     <p><code> принадлежит( Верш1, Вершины),</code></p>
     <p><code>  % Выбор преемника  Верш1  вершины  Верш</code></p>
     <p><code> решить( Bepш1, Дер).</code></p>
     <p><code>решить( Верш, Верш ---&gt; и : Деревья) :-</code></p>
     <p><code> Верш ---&gt; и : Вершины,   % Верш - И-вершина</code></p>
     <p><code> решитьвсе( Вершины, Деревья).</code></p>
     <p><code>  % Решить все задачи-преемники</code></p>
     <empty-line/>
     <p><code>решитьвсе( [], []).</code></p>
     <p><code>решитьвсе( [Верш | Вершины], [Дер | Деревья]) :-</code></p>
     <p><code> решить( Верш, Дер),</code></p>
     <p><code> решитьвсе( Вершины, Деревья).</code></p>
     <empty-line/>
     <p><code>отобр( Дер) :-            % Отобразить решающее дерево</code></p>
     <p><code> отобр( Дер, 0), !.       % с отступом 0</code></p>
     <p><code>отобр( Верш ---&gt; Дер, H) :-</code></p>
     <p><code>  % Отобразить решающее дерево с отступом H</code></p>
     <p><code> write( Верш), write( '---&gt;'),</code></p>
     <p><code> H1 is H + 7,</code></p>
     <p><code> отобр( Дер, H1), !.</code></p>
     <p><code>отобр( и : [Д], H) :-</code></p>
     <p><code>  % Отобразить И-список решающих деревьев</code></p>
     <p><code> отобр( Д, H).</code></p>
     <p><code>отобр( и : [Д | ДД], H) :-</code></p>
     <p><code>  % Отобразить И-список решающих деревьев</code></p>
     <p><code> отобр( Д, H),</code></p>
     <p><code> tab( H),</code></p>
     <p><code> отобр( и : ДД, H), !.</code></p>
     <p><code>отобр( Верш, H) :-</code></p>
     <p><code> write( Верш), nl.</code></p>
     <p><strong>Рис. 13.8.</strong> Поиск в глубину для И/ИЛИ-графов. Эта программа может зацикливаться. Процедура <code>решить</code> находит решающее дерево, а процедура <code>отобр</code> показывает его пользователю. В процедуре <code>отобр </code>предполагается, что на вывод вершины тратится только один символ.</p>
     <empty-line/>
     <p>Например, при поиске в И/ИЛИ-графе рис. 13.4 первое найденное решение задачи, соответствующей самой верхней вершине <emphasis>а</emphasis>, будет иметь следующее представление:</p>
     <p><code>а ---&gt; b ---&gt; и : [d, c ---&gt; h]</code></p>
     <p>Три формы представления решающего дерева соответствуют трем предложениям отношения <code>решить</code>. Поэтому все, что нам нужно сделать для изменения нашей исходной программы <code>решить</code>, — это подправить каждое из этих трех предложений, просто добавив в каждое из них решающее дерево в качестве второго аргумента. Измененная программа показана на рис. 13.8. В нее также введена дополнительная процедура <code>отобр</code> для отображения решающих деревьев в текстовой форме. Например, решающее дерево рис. 13.4 будет отпечатано процедурой <code>отобр</code> в следующем виде:</p>
     <p><code>а ---&gt; b ---&gt; d</code></p>
     <p><code>              e ---&gt; h</code></p>
     <p>Программа рис. 13.8 все еще сохраняет склонность к вхождению в бесконечные циклы. Один из простых способов избежать бесконечных циклов — это следить за текущей глубиной поиска и не давать программе заходить за пределы некоторого ограничения по глубине. Это можно сделать, введя в отношение <code>решить</code> еще один аргумент:</p>
     <p><code>решить( Верш, РешДер, МаксГлуб)</code></p>
     <p>Как и раньше, вершиной <code>Верш</code> представлена решаемая задача, а <code>РешДер</code> — это решение этой задачи, имеющее глубину, не превосходящую <code>МаксГлуб</code>. <code>МаксГлуб</code> — это допустимая глубина поиска в графе. Если <code>МаксГлуб</code> = 0, то двигаться дальше запрещено, если же <code>МаксГлуб</code> &gt; 0, то поиск распространяется на преемников вершины <code>Верш</code>, причем для них устанавливается меньший предел по глубине, равный <code>МаксГлуб</code>-1. Это дополнение легко ввести в программу рис. 13.8. Например, второе предложение процедуры решить примет вид:</p>
     <p><code>решить( Верш, Верш ---&gt; Дер, МаксГлуб) :-</code></p>
     <p><code> МаксГлуб &gt; 0,</code></p>
     <p><code> Верш ---&gt; или : Вершины, % Верш - ИЛИ-вершина</code></p>
     <p><code> принадлежит ( Верш1, Вершины),</code></p>
     <p><code>  % Выбор преемника  Верш1  вершины  Верш</code></p>
     <p><code> Глуб1 is МаксГлуб - 1,   % Новый предел по глубине</code></p>
     <p><code> решить( Bepш1, Дер, Глуб1).</code></p>
     <p><code>  % Решить задачу-преемник с меньшим ограничением</code></p>
     <p>Нашу процедуру поиска в глубину с ограничением можно также использовать для имитации поиска в ширину. Идея состоит в следующем: многократно повторять поиск в глубину каждый раз все с большим значением ограничения до тех пор, пока решение не будет найдено, То есть попробовать решить задачу с ограничением по глубине, равным 0, затем — с ограничением 1, затем — 2 и т.д. Получаем следующую программу:</p>
     <p><code>имитация_в_ширину( Верш, РешДер) :-</code></p>
     <p><code> проба_в_глубину( Верш, РешДер, 0).</code></p>
     <p><code>  % Проба поиска с возрастающим ограничением, начиная с 0</code></p>
     <empty-line/>
     <p><code>проба_в_глубину( Верш, РешДер, Глуб) :-</code></p>
     <p><code> решить( Верш, РешДер, Глуб);</code></p>
     <p><code> Глуб1 is Глуб + 1, % Новый предел по глубине</code></p>
     <p><code> проба_в_глубину( Верш, РешДер, Глуб1).</code></p>
     <p><code>  % Попытка с новым ограничением</code></p>
     <p>Недостатком имитации поиска в ширину является то, что при каждом увеличении предела по глубине программа повторно просматривает верхнюю область пространства поиска.</p>
     <subtitle>Упражнения</subtitle>
     <p><strong>13.1.</strong> Закончите составление программы поиска в глубину (с ограничением) для И/ИЛИ-графов, намеченную в настоящем разделе.</p>
     <p><strong>13.2.</strong> Определите на Прологе И/ИЛИ-пространство для задачи "ханойская башня" и примените к нему процедуры поиска настоящего раздела.</p>
     <p><strong>13.3.</strong> Рассмотрите какую-нибудь простую детерминированную игру двух лиц с полной информацией и дайте определение ее И/ИЛИ-представления. Используйте программу поиска в И/ИЛИ-графах для построения выигрывающих стратегий в форме И/ИЛИ-деревьев.</p>
    </section>
    <section>
     <title>
      <p>13.4. Поиск с предпочтением в И/ИЛИ-графах </p>
     </title>
     <section>
      <title>
       <p>13.4.1. Эвристические оценки и алгоритм поиска</p>
      </title>
      <p>Базовые процедуры поиска предыдущего раздела производят систематический и полный просмотр И/ИЛИ-дерева, не руководствуясь при этом какими-либо эвристиками. Для сложных задач подобные процедуры весьма не эффективны из-за большой комбинаторной сложности пространства поиска. В связи с этим возникает необходимость в эвристическом управлении поиском, направленном на уменьшение комбинаторной сложности за счет исключения бесполезных альтернатив. Управление эвристиками, излагаемое в настоящем разделе, будет основано на численных эвристических оценках "трудности" задач, входящих в состав И/ИЛИ-графа. Программу, которую мы составим, можно рассматривать как обобщение программы поиска с предпочтением в пространстве состояний гл. 12.</p>
      <p>Начнем с того, что сформулируем критерий оптимальности, основанный на стоимостях дуг И/ИЛИ-графа. Во-первых, мы расширим наше представление И/ИЛИ-графов, дополнив его стоимостями дуг. Например, И/ИЛИ-граф рис. 13.4 можно представить следующими предложениями:</p>
      <p><code>а ---&gt; или : [b/1, с/3].</code></p>
      <p><code>b ---&gt; и : [d/1, e/1].</code></p>
      <p><code>с ---&gt; и : [f/2, g/1].</code></p>
      <p><code>e ---&gt; или : [h/6].</code></p>
      <p><code>f ---&gt; или : [h/2, i/3].</code></p>
      <empty-line/>
      <p><code>цель( d). цель( g). цель( h).</code></p>
      <p>Стоимость решающего дерева мы определим как сумму стоимостей его дуг. Цель оптимизации - найти решающее дерево минимальной стоимости. Как и раньше, иллюстрацией служит рис. 13.4.</p>
      <p>Будет полезным определить <emphasis>стоимость вершины</emphasis> И/ИЛИ-графа как стоимость оптимального решающего дерева для этой вершины. Стоимость вершины, определенная таким образом, соответствует "трудности" соответствующей задачи.</p>
      <p>Мы будем предполагать, что стоимости вершин И/ИЛИ-графа можно оценить (не зная соответствующих решающих деревьев) при помощи эвристической функции <emphasis>h</emphasis>. Эти оценки будут использоваться для управления поиском. Наша программа поиска начнет свою работу со стартовой вершины и, распространяя поиск из уже просмотренных вершин на их преемников, будет постепенно наращивать дерево поиска. Этот процесс будет строить дерево даже в том случае, когда сам И/ИЛИ-граф не является деревом; при этом граф будет разворачиваться в дерево за счет дублирования своих отдельных частей.</p>
      <p>Для продолжения поиска будет всегда выбираться "наиболее перспективное" решающее дерево-кандидат. Каким же образом используется функция <emphasis>h</emphasis> для оценки степени перспективности решающего дерева-кандидата или, точнее, вершины-кандидата — корня этого дерева?</p>
      <image l:href="#_95.png"/>
      <p><strong>Рис. 13.9.</strong> Получение оценки <emphasis>H</emphasis> трудности задач И/ИЛИ-графа.</p>
      <p>Обозначим через <emphasis>H(В)</emphasis> оценку трудности вершины <emphasis>В</emphasis>. Для самой верхней вершины текущего дерева поиска <emphasis>H(В)</emphasis> просто совпадает с <emphasis>h(В)</emphasis>. С другой стороны, для оценки внутренней вершины дерева поиска нам не обязательно использовать непосредственно значение <emphasis>h</emphasis>, поскольку у нас есть некоторая дополнительная информация об этой вершине: мы знаем ее преемников. Следовательно, как показано на рис. 13.9, мы можем приближенно оценить трудность внутренней ИЛИ-вершины как</p>
      <p><emphasis> <image l:href="#img_01.png_0"/></emphasis></p>
      <p>где <emphasis>с(В, В<sub>i</sub>)</emphasis> — стоимость дуги, ведущей из <emphasis>В</emphasis> в <emphasis>В<sub>i</sub></emphasis>. Взятие минимума в этой формуле оправдано тем обстоятельством, что для того, чтобы решить задачу <emphasis>В</emphasis>, нам нужно решить только одну из ее задач-преемников. Трудность И-вершины <emphasis>В</emphasis> можно приближенно оценить так:</p>
      <p> <image l:href="#img_11.png"/></p>
      <p>Будем называть <emphasis>H</emphasis>-оценку внутренней вершины "возвращенной" (backed-up) оценкой.</p>
      <p>Более практичной с точки зрения использования в нашей программе поиска является другая величина <emphasis>F</emphasis>, которую можно определить в терминах <emphasis>H</emphasis> следующим образом. Пусть <emphasis>В1</emphasis> — вершина-предшественник вершины <emphasis>В</emphasis> в дереве поиска, причем стоимость дуги, ведущей из <emphasis>В1</emphasis> в <emphasis>В</emphasis>, равна <emphasis>с(В1, В)</emphasis>, тогда положим</p>
      <p><emphasis>F( B) = с( В1, В) + H( В)</emphasis></p>
      <p>Пусть <emphasis>В1</emphasis> — родительская вершина вершины <emphasis>В</emphasis>, а <emphasis>В</emphasis><sub>1</sub>, <emphasis>В</emphasis><sub>2</sub>, … — ее дочерние вершины, тогда, в соответствии с определениями <emphasis>F</emphasis> и <emphasis>H</emphasis>, имеем</p>
      <p> <image l:href="#img_21.png"/>,  если <emphasis>В</emphasis> — ИЛИ-вершина</p>
      <p> <image l:href="#img_3.png"/>,  если <emphasis>В</emphasis> — И-вершина</p>
      <p>Хотя стартовая вершина <emphasis>А</emphasis> и не имеет предшественника, будем считать, что стоимость ведущей в нее (виртуальной) дуги равна 0. Если положить <emphasis>h</emphasis> равным 0 для всех вершин И/ИЛИ-дерева, то для любого найденного оптимального решающего дерева окажется, что его стоимость, т.е. сумма стоимостей его дуг, в точности равна  <emphasis>F(A)</emphasis>.</p>
      <p>На любой стадии поиска каждый преемник ИЛИ-вершины соответствует некоторому альтернативному решающему дереву-кандидату. Процесс поиска всегда принимает решение продолжать просмотр того дерева-кандидата, для которого <emphasis>F</emphasis>-оценка минимальна. Вернемся еще раз к рис. 13.4 и посмотрим, как будет вести себя процесс, поиска на примере И/ИЛИ-графа, изображенного на этом рисунке. В начале дерево поиска состоит всего из одной вершины — стартовой вершины  <emphasis>а</emphasis>, далее дерево постепенно "растет" до тех пор, пока не будет найдено решающее дерево. На рис. 13.10, показан ряд "мгновенных снимков", сделанных в процессе роста дерева поиска. Для простоты мы предположим, что <emphasis>h =</emphasis> 0 для всех вершин. Числа, приписанные вершинам на рис. 13.10 — это их <emphasis>F</emphasis>-оценки (разумеется, по мере накопления информации в процессе поиска они изменяются). Ниже даются некоторые пояснительные замечания к рис. 13.10.</p>
      <p>После распространения поиска из первоначального дерева (снимок А) получается дерево В. Вершина <emphasis>а</emphasis> — это ИЛИ-вершина, поэтому мы имеем два решающих дерева-кандидата: <emphasis>b</emphasis> и <emphasis>с</emphasis>. Поскольку <emphasis>F( b) = 1 &lt; 3 = F( c)</emphasis>, для продолжения поиска выбирается альтернатива <emphasis>b</emphasis>. Насколько далеко может зайти процесс роста поддерева <emphasis>b</emphasis>? Этот процесс может продолжаться до тех пор, пока не произойдет одно из двух событий:</p>
      <p>(1) <emphasis>F</emphasis>-оценка вершины <emphasis>b</emphasis> станет больше, чем  <emphasis>F</emphasis>-оценка ее конкурента <emphasis>с</emphasis>, или</p>
      <p>(2) обнаружится, что найдено решающее дерево.</p>
      <p>В связи с этим, начиная просмотр поддерева-кандидата <emphasis>b</emphasis>, мы устанавливаем верхнюю границу для <emphasis>F( b)</emphasis>: <emphasis>F( b) </emphasis>&#8804;<emphasis> 3 = F( c)</emphasis>. Сначала порождаются преемники <emphasis>d</emphasis> и <emphasis>e</emphasis> вершины <emphasis>b</emphasis> (снимок С),после чего <emphasis>F</emphasis>-оценка <emphasis>b</emphasis> возрастает до 3. Так как это значение не превосходит верхнюю границу, рост дерева-кандидата с корнем в <emphasis>b</emphasis> продолжается. Вершина <emphasis>d</emphasis> оказывается целевой вершиной, а после распространения поиска из вершины <emphasis>e</emphasis> на один шаг получаем дерево, показанное на снимке D. В этот момент выясняется, что <emphasis>F( b) = 9 &gt; 3</emphasis>,  и рост дерева <emphasis>b </emphasis>прекращается. В результате процесс поиска не успевает "осознать", что <emphasis>h</emphasis> — это тоже целевая вершина и что порождено решающее дерево. Вместо этого происходит переключение активности на конкурирующую альтернативу  <emphasis>с</emphasis>.  Поскольку в этот момент <emphasis>F( b) =</emphasis> 9, устанавливается верхняя граница для  <emphasis>F( c)</emphasis>,  равная 9. Дерево-кандидат с корнем  <emphasis>с</emphasis>   наращивается (с учетом установленного ограничения) до тех пор, пока не возникает ситуация, показанная на снимке  E.  Теперь процесс поиска обнаруживает, что найдено решающее дерево (включающее в себя целевые вершины <emphasis>h</emphasis> и <emphasis>g</emphasis>), на чем поиск заканчивается. Заметьте, что в качестве результата процесс поиска выдает наиболее дешевое из двух возможных решающих деревьев, а именно решающее дерево рис. 13.4(с).</p>
      <image l:href="#_98.png"/>
      <p><strong>Рис. 13.10.</strong> Трассировка процесса поиска с предпочтением в И/ИЛИ-графе (<emphasis>h =</emphasis> 0) при решении задачи рис. 13.4. </p>
     </section>
     <section>
      <title>
       <p>13.4.2. Программа поиска</p>
      </title>
      <p>Программа, в которой реализованы идеи предыдущего раздела, показана на рис. 13.12. Прежде, чем мы перейдем к объяснению отдельных деталей этой программы, давайте рассмотрим тот способ представления дерева поиска, который в ней используется.</p>
      <p>Существует несколько случаев, как показано на рис. 13.11. Различные формы представления поискового дерева возникают как комбинации следующих возможных вариантов, относящихся к размеру дерева и к его "решающему статусу".</p>
      <p>• Размер:</p>
      <p> (1) дерево состоит из одной вершины (листа) или</p>
      <p> (2) оно имеет корень и (непустые) поддеревья.</p>
      <p>• Решающий статус:</p>
      <p> (1) обнаружено, что дерево соответствует решению задачи (т.е. является решающим деревом) или</p>
      <p> (2) оно все еще решающее дерево-<emphasis>кандидат</emphasis>.</p>
      <image l:href="#_991.png"/>
      <empty-line/>
      <image l:href="#_992.jpg"/>
      <p><strong>Рис. 13.11.</strong> Представление дерева поиска.</p>
      <p>Основной функтор, используемый для представления дерева, указывает, какая из комбинаций этих воз-можностей имеется в виду. Это может быть одна из следующих комбинаций:</p>
      <p><code>лист  решлист  дер  решдер</code></p>
      <p>Далее, в представление дерева входят все или некоторые из следующих объектов:</p>
      <p>• корневая вершина дерева,</p>
      <p>• <emphasis>F</emphasis>-оценка дерева,</p>
      <p>• стоимость С дуги И/ИЛИ-графа, ведущей в корень дерева,</p>
      <p>• список поддеревьев,</p>
      <p>• отношение (И или ИЛИ) между поддеревьями.</p>
      <p>Список поддеревьев всегда упорядочен по возрастанию <emphasis>F</emphasis>-оценок. Поддеревья, являющиеся решающими деревьями, помещаются в конец списка.</p>
      <p>Обратимся теперь к программе рис. 13.12. Отношение самого высокого уровня — это</p>
      <p><code>и_или( Верш, РешДер)</code></p>
      <p>где <code>Верш</code> — стартовая вершина. Программа строит решающее дерево (если таковое существует), рассчитывая на то, что оно окажется оптимальным решением. Будет ли это решение в действительности самым дешевым, зависит от той функции <emphasis>h</emphasis>, которую использует алгоритм. Существует теорема, в которой говорится о том, как оптимальность решения зависит от <emphasis>h</emphasis>. Эта теорема аналогична теореме о допустимости алгоритма поиска с предпочтением в пространстве состояний (гл. 12). Обозначим через <emphasis>С( В)</emphasis>  стоимость оптимального решающего дерева для вершины <emphasis>В</emphasis>. Если для каждой вершины <emphasis>В</emphasis> И/ИЛИ-графа эвристическая оценка  <emphasis>h(B)</emphasis>&#8804;<emphasis>C(B)</emphasis>, то гарантируется, что процедура <code>и_или</code> найдет оптимальное решение. Если же <emphasis>h</emphasis> не удовлетворяет этому условию, то найденное решение может оказаться субоптимальным. Существует тривиальная эвристическая функция, удовлетворяющая условию оптимальности, а именно <emphasis>h =</emphasis> 0 для всех вершин. Ее недостатком является отсутствие эвристической силы.</p>
      <p>Основную роль в программе рис. 13.12 играет отношение</p>
      <p><code>расширить( Дер, Предел, Дер1, ЕстьРеш)</code></p>
      <p><code>Дер</code> и <code>Предел</code> — его "входные" аргументы, а <code>Дер1</code> и <code>ЕстьРеш</code> — "выходные". Аргументы имеют следующий смысл:</p>
      <p><code>Дер</code> — дерево поиска, подлежащее расширению.</p>
      <p><code>Предел</code> — предельное значение <emphasis>F</emphasis>-оценки, при котором еще разрешено наращивать дерево <code>Дер</code>.</p>
      <p><code>ЕстьРеш</code> — индикатор, значения которого указывают на то, какой из следующих трех случаев имеет место:</p>
      <p>(1) <code>ЕстьРеш = да</code>: <code>Дер</code> можно "нарастить" (с учетом ограничения <code>Предел</code>) таким образом, чтобы образовалось решающее дерево <code>Дер1</code>.</p>
      <p>(2) <code>ЕстьРеш = нет</code>: дерево <code>Дер</code> можно расширить до состояния <code>Дер1</code>, для которого <emphasis>F</emphasis>-оценка превосходит <code>Предел</code>, но прежде чем <emphasis>F</emphasis>-оценка превзошла <code>Предел</code>, решающее дерево не было обнаружено.</p>
      <p>(3) <code>ЕстьРеш = никогда</code>: <code>Дер</code> не содержит решения.</p>
      <p>В зависимости от случая <code>Дер1</code> — это либо решающее дерево, либо <code>Дер</code>, расширенное до момента перехода через <code>Предел</code>; если <code>ЕстьРеш = никогда</code>, то переменная <code>Дер1</code> неинициализирована.</p>
      <p>Процедура</p>
      <p><code>расширспис( Деревья, Предел, Деревья1, ЕстьРеш)</code></p>
      <p>аналогична процедуре <code>расширить</code>. Так же, как и в процедуре <code>расширить</code>, <code>Предел</code> задает ограничение на рост дерева, а <code>ЕстьРеш</code> — это индикатор, указывающий, каков результат расширения ("да", "нет" или "никогда"). Первый аргумент — это, на этот раз, список деревьев (И-список или ИЛИ-список):</p>
      <p><code>Деревья = или:[Д1, Д2, ...]</code> или</p>
      <p><code>Деревья = и : [Д1, Д2, ...]</code></p>
      <p>Процедура <code>расширспис</code> выбирает из списка <code>Деревья</code> наиболее перспективное дерево (исходя из <emphasis>F</emphasis>-оценок). Так как деревья в списке упорядочены, таким деревом является первый элемент списка. Наиболее перспективное дерево подвергается расширению с новым ограничением <code>Предел1</code>. Значение <code>Предел1</code> зависит от <code>Предел</code>, а также от других деревьев списка. Если <code>Деревья</code> — это ИЛИ-список, то <code>Предел1</code> устанавливается как наименьшая из двух величин: <code>Предел</code> и <emphasis>F</emphasis>-оценка следующего по "качеству" дерева из списка <code>Деревья</code>. Если <code>Деревья</code> — это И-дерево, то <code>Предел1</code> устанавливается равным <code>Предел</code> минус сумма <emphasis>F</emphasis>-оценок всех остальных деревьев из списка. Значение переменной <code>Деревья1</code> зависит от случая, задаваемого индикатором <code>ЕстьРеш</code>. Если <code>ЕстьРеш = нет</code>, то <code>Деревья1</code> — это то же самое, что и список <code>Деревья</code>, причем наиболее перспективное дерево расширено с учетом ограничения <code>Предел1</code>. Если <code>ЕстьРеш = да</code>, то <code>Деревья1</code> — это решение для всего списка <code>Деревья</code> (найденное без выхода за границы значения <code>Предел</code>). Если <code>ЕстьРеш = никогда</code>, то переменная <code>Деревья1</code> неинициализирована.</p>
      <p>Процедура <code>продолжить</code>, вызываемая после расширения списка деревьев, решает, что делать дальше, в зависимости от результата срабатывания процедуры <code>расширить</code>. Эта процедура либо строит решающее дерево, либо уточняет дерево поиска и продолжает процесс его наращивания, либо выдает сообщение "никогда" в случае, когда было обнаружено, что список деревьев не содержит решения.</p>
      <empty-line/>
      <p><code>/* ПРОГРАММА И/ИЛИ-ПОИСКА С ПРЕДПОЧТЕНИЕМ</code></p>
      <p><code>Эта программа порождает только одно решение. Гарантируется, что это решение самое дешевое при условии, что используемая эвристическая функция является нижней гранью реальной стоимости решающих деревьев.</code></p>
      <p><code>Дерево поиска имеет одну из следующих форм:</code></p>
      <p><code>дер( Верш, F, С, Поддеревья) дерево-кандидат</code></p>
      <p><code>лист( Верш, F, C)            лист дерева поиска</code></p>
      <p><code>решдер( Верш, F, Поддеревья) решающее дерево</code></p>
      <p><code>решлист( Верш, F)            лист решающего дерева</code></p>
      <p><code>С - стоимость дуги, ведущей в Верш</code></p>
      <p><code>F = С + H, где H - эвристическая оценка оптимального решающего дерева с корнем Верш</code></p>
      <p><code>Список Поддеревья упорядочен таким образом, что</code></p>
      <p><code>(1) решающие поддеревья находятся в конце списка;</code></p>
      <p><code>(2) остальные поддеревья расположены в порядке возрастания F-оценок</code></p>
      <p><code>*/</code></p>
      <empty-line/>
      <p><code>:- op( 500, xfx, :).</code></p>
      <p><code>:- op( 600, xfx, ---&gt;).</code></p>
      <empty-line/>
      <p><code>и_или( Верш, РешДер) :-</code></p>
      <p><code> расширить( лист( Верш, 0, 0), 9999, РешДер, да).</code></p>
      <p><code>  % Предполагается, что 9999  &gt;  любой F-оценки</code></p>
      <empty-line/>
      <p><code>% Процедура расширить( Дер, Предел, НовДер, ЕстьРеш)</code></p>
      <p><code>% расширяет Дер в пределах ограничения Предел</code></p>
      <p><code>% и порождает НовДер с "решающим статусом" ЕстьРеш.</code></p>
      <empty-line/>
      <p><code>% Случай 1:  выход за ограничение</code></p>
      <p><code>расширить( Дер, Предел, Дер, нет) :-</code></p>
      <p><code> f( Дер, F),  F &gt; Предел, !. % Выход за ограничение</code></p>
      <empty-line/>
      <p><code>% В остальных случаях F &#8804; Предел</code></p>
      <p><code>% Случай 2:  встретилась целевая вершина</code></p>
      <p><code>расширить( лист( Верш, F, С), _, решлист( Верш, F), да) : -</code></p>
      <p><code> цель( Верш), !.</code></p>
      <empty-line/>
      <p><code>% Случай 3:  порождение преемников листа</code></p>
      <p><code>расширить( лист( Верш, F,C), Предел, НовДер, ЕстьРеш) :-</code></p>
      <p><code> расшлист( Верш, С, Дер1), !,</code></p>
      <p><code> расширить( Дер1, Предел, НовДер, ЕстьРеш);</code></p>
      <p><code> ЕстьРеш = никогда, !.       % Нет преемников, тупик</code></p>
      <empty-line/>
      <p><code>% Случай 4:  расширить дерево</code></p>
      <p><code>расширить( дер( Верш, F, С, Поддеревья),</code></p>
      <p><code> Предел, НовДер, ЕстьРеш) :-</code></p>
      <p><code> Предел1 is Предел - С,</code></p>
      <p><code> расширспис( Поддеревья, Предел1, НовПоддер, ЕстьРеш1),</code></p>
      <p><code> продолжить( ЕстьРеш1, Верш, С, НовПоддер, Предел,</code></p>
      <p><code>  НовДер, ЕстьРеш).</code></p>
      <empty-line/>
      <p><code>% расширспис( Деревья, Предел, Деревья1, ЕстьРеш)</code></p>
      <p><code>% расширяет деревья из заданного списка с учетом</code></p>
      <p><code>% ограничения Предел и выдает новый список Деревья1</code></p>
      <p><code>% с "решающим статусом" ЕстьРеш.</code></p>
      <p><code>расширспис( Деревья, Предел, Деревья1, ЕстьРеш) :-</code></p>
      <p><code> выбор( Деревья, Дер, ОстДер, Предел, Предел1),</code></p>
      <p><code> расширить( Дер, Предел1, НовДер, ЕстьРеш1),</code></p>
      <p><code> собрать( ОстДер, НовДер, ЕстьРеш1, Деревья1, ЕстьРеш).</code></p>
      <empty-line/>
      <p><code>% "продолжить" решает, что делать после расширения</code></p>
      <p><code>% списка деревьев</code></p>
      <p><code>продолжить( да, Верш, С, Поддеревья, _,</code></p>
      <p><code> решдер( Верш, F, Поддеревья), да): -</code></p>
      <p><code> оценка( Поддеревья, H), F is С + H, !.</code></p>
      <p><code>продолжить( никогда, _, _, _, _, _, никогда) :- !.</code></p>
      <p><code>продолжить( нет, Верш, С, Поддеревья, Предел,</code></p>
      <p><code> НовДер, ЕстьРеш) :-</code></p>
      <p><code> оценка( Поддеревья, H), F is С + H, !,</code></p>
      <p><code> расширить( дер( Верш, F, С, Поддеревья), Предел,</code></p>
      <p><code>  НовДер, ЕстьРеш).</code></p>
      <empty-line/>
      <p><code>% "собрать" соединяет результат расширения дерева со списком деревьев</code></p>
      <p><code>собрать( или : _, Дер, да, Дер, да):- !. % Есть решение ИЛИ-списка</code></p>
      <p><code>собрать( или : ДД, Дер, нет, или : НовДД, нет) :-</code></p>
      <p><code> встав( Дер, ДД, НовДД), !.  % Нет решения ИЛИ-списка</code></p>
      <p><code>собрать( или : [], _, никогда, _, никогда) :- !.</code></p>
      <p><code>  % Больше нет кандидатов</code></p>
      <p><code>собрать( или:ДД, _, никогда, или:ДД, нет) :- !.</code></p>
      <p><code>  % Есть еще кандидаты</code></p>
      <p><code>собрать( и : ДД, Дер, да, и : [Дер Э ДД], да ) :-</code></p>
      <p><code> всереш( ДД), !.             % Есть решение И-списка</code></p>
      <p><code>собрать( и : _, _, никогда, _, никогда) :- !.</code></p>
      <p><code>  % Нет решения И-списка</code></p>
      <p><code>собрать( и : ДД, Дер, ДаНет, и : НовДД, нет) :-</code></p>
      <p><code> встав( Дер, ДД, НовДД), !.  % Пока нет решения И-списка</code></p>
      <empty-line/>
      <p><code>% "расшлист" формирует дерево из вершины и ее преемников</code></p>
      <p><code>расшлист( Верш, С, дер( Верш, F, С, Оп : Поддеревья)) :-</code></p>
      <p><code> Верш---&gt; Оп : Преемники,</code></p>
      <p><code> оценить( Преемники, Поддеревья),</code></p>
      <p><code> оценка( Оп : Поддеревья, H), F is С + H.</code></p>
      <p><code> оценить( [], []).</code></p>
      <empty-line/>
      <p><code>оценить( [Верш/С | ВершиныСтоим], Деревья) :-</code></p>
      <p><code> h( Верш, H), F is С + H,</code></p>
      <p><code> оценить( ВершиныСтоим, Деревья1),</code></p>
      <p><code> встав( лист( Верш, F, С), Деревья1, Деревья).</code></p>
      <empty-line/>
      <p><code>% "всереш" проверяет, все ли деревья в списке "решены"</code></p>
      <p><code>всереш([]).</code></p>
      <p><code>всереш( [Дер | Деревья] ) :-</code></p>
      <p><code> реш( Дер),</code></p>
      <p><code> всереш( Деревья).</code></p>
      <empty-line/>
      <p><code>реш( решдер( _, _, _ ) ).</code></p>
      <p><code>реш( решлист( _ , _) ).</code></p>
      <empty-line/>
      <p><code>f( Дер, F) :-              % Извлечь F-оценку дерева</code></p>
      <p><code> arg( 2, Дер, F), !.       % F - это 2-й аргумент Дер</code></p>
      <empty-line/>
      <p><code>% встав( Дер, ДД, НовДД) вставляет Дер в список</code></p>
      <p><code>% деревьев ДД; результат - НовДД</code></p>
      <p><code>встав( Д, [], [Д] ) :- !.</code></p>
      <p><code>встав( Д, [Д1 | ДД], [Д, Д1 | ДД] ) :-</code></p>
      <p><code> реш( Д1), !.</code></p>
      <p><code>встав( Д, [Д1 | ДД], [Д1 | ДД1] ) :-</code></p>
      <p><code> реш( Д),</code></p>
      <p><code> встав( Д, ДД, ДД1), !.</code></p>
      <p><code>встав( Д, [Д1 | ДД], [Д, Д1 | ДД] ) :-</code></p>
      <p><code> f( Д, F), f( Д1, F1), F=&lt; F1, !.</code></p>
      <p><code>встав( Д, [Д1 | ДД], [ Д1 | ДД1] ) :-</code></p>
      <p><code> встав( Д, ДД, ДД1).</code></p>
      <empty-line/>
      <p><code>% "оценка" находит "возвращенную" F-оценку И/ИЛИ-списка деревьев</code></p>
      <p><code>оценка( или :[Дер | _ ], F) :-</code></p>
      <p><code> % Первое дерево ИЛИ-списка - наилучшее</code></p>
      <p><code> f( Дер, F), !.</code></p>
      <p><code>оценка( и :[], 0) :- !.</code></p>
      <p><code>оценка( и : [Дер1 | ДД], F) :-</code></p>
      <p><code> f( Дер1, F1),</code></p>
      <p><code> оценка( и : ДД, F2),</code></p>
      <p><code> F is F1 + F2, !.</code></p>
      <p><code>оценка( Дер, F) :-</code></p>
      <p><code> f( Дер, F).</code></p>
      <empty-line/>
      <p><code>% Отношение выбор( Деревья, Лучшее, Остальные, Предел, Предел1):</code></p>
      <p><code>% Остальные - И/ИЛИ-список Деревья без его "лучшего" дерева</code></p>
      <p><code>% Лучшее; Предел - ограничение для Списка Деревья, Предел1 -</code></p>
      <p><code>% ограничение для дерева Лучшее</code></p>
      <p><code>выбор( Оп : [Дер], Дер, Оп : [], Предел, Предел) :- !.</code></p>
      <p><code>  % Только один кандидат</code></p>
      <p><code>выбор( Оп : [Дер | ДД], Дер, Оп : ДД, Предел, Предел1) :-</code></p>
      <p><code> оценка( Оп : ДД, F),</code></p>
      <p><code> ( Оп = или, !, мин( Предел, F, Предел1);</code></p>
      <p><code>   Оп = и, Предел1 is Предел - F).</code></p>
      <empty-line/>
      <p><code>мин( А, В, А) :- А &lt; В, !.</code></p>
      <p><code>мин( А, В, В).</code></p>
      <p><strong>Рис. 13.12.</strong> Программа поиска с предпочтением в И/ИЛИ-графе.</p>
      <empty-line/>
      <p>Еще одна процедура</p>
      <p><code>собрать( ОстДер, НовДер, ЕстьРеш1, НовДеревья, ЕстьРеш)</code></p>
      <p>связывает между собой несколько объектов, с которыми работает <code>расширспис</code>. <code>НовДер</code> — это расширенное дерево, взятое из списка деревьев процедуры <code>расширспис</code>, <code>ОстДер</code> — остальные, не измененные деревья из этого списка, а <code>ЕстьРеш1</code> указывает на "решающий статус" дерева <code>НовДер</code>. Процедура <code>собрать</code> имеет дело с несколькими случаями в зависимости от значения <code>ЕстьРеш1</code>, а также от того, является ли список деревьев И-списком или ИЛИ-списком. Например, предложение</p>
      <p><code>собрать( или : _, Дер, да, Дер, да).</code></p>
      <p>означает: в случае, когда список деревьев — это ИЛИ-список и при только что проведенном расширении получено решающее дерево, считать, что задача, соответствующая всему списку деревьев, также решена, а ее решающее дерево и есть само дерево <code>Дер</code>. Остальные случаи легко понять из текста процедуры <code>собрать</code>.</p>
      <p>Для отображения решающего дерева можно определить процедуру, аналогичную процедуре <code>отобр</code> (рис. 13.8). Оставляем это читателю в качестве упражнения.</p>
     </section>
     <section>
      <title>
       <p>13.4.3. Пример отношений, определяющих конкретную задачу: поиск маршрута</p>
      </title>
      <p>Давайте теперь сформулируем задачу нахождения маршрута как задачу поиска в И/ИЛИ-графе, причем сделаем это таким образом, чтобы наша формулировка могла бы быть непосредственно использована процедурой <code>и_или</code> рис. 13.12. Мы условимся, что карта дорог будет представлена при помощи отношения</p>
      <p><code>связь( Гор1, Гор2, P)</code></p>
      <p>означающего, что между городами <code>Гор1</code> и <code>Гор2</code> существует непосредственная связь, а соответствующее расстояние равно <code>P</code>. Далее, мы допустим, что существует отношение</p>
      <p><code>клпункт( Гор1-Гор2, Гор3)</code></p>
      <p>имеющее следующий смысл: для того, чтобы найти маршрут из <code>Гор1</code> в <code>Гор2</code>, следует рассмотреть пути, проходящие через <code>Гор3</code> (<code>Гор3</code> — это "ключевой пункт" между <code>Гор1</code> и <code>Гор2</code>). Например, на карте рис. 13.1 <emphasis>f</emphasis> и <emphasis>g</emphasis> — это ключевые пункты между <emphasis>а</emphasis> и <emphasis>z</emphasis>:</p>
      <p><code>клпункт( a-z, f).  клпункт( a-z, g).</code></p>
      <p>Мы реализуем следующий принцип построения маршрута:</p>
      <p> Для того, чтобы найти маршрут между городами X и Z, необходимо:</p>
      <p>  (1) если между X и Z имеются ключевые пункты Y1, Y2, …, то найти один из путей:</p>
      <p>   путь из X в Z через Y1, или</p>
      <p>   путь из X в Z через Y2, или</p>
      <p>   …</p>
      <p>  (2) если между X и Z нет ключевых пунктов, то найти такой соседний с X город Y, что существует маршрут из Y в Z.</p>
      <p>Таким образом, мы имеем два вида задач, которые мы будем представлять как</p>
      <p>(1) <code>X-Z         </code>найти маршрут из X в Z</p>
      <p>(2) <code>X-Z через Y </code>найти маршрут из X в Z, проходящий через Y</p>
      <p>Здесь '<code>через</code>' — это инфиксный оператор более высокого приоритета, чем '<code>-</code>', и более низкого, чем '<code>---&gt;</code>'. Теперь можно определить соответствующий И/ИЛИ-граф явным образом при помощи следующего фрагмента программы:</p>
      <p><code>:- op( 560, xfx, через)</code></p>
      <empty-line/>
      <p><code>% Правила задачи X-Z, когда между  X  и  Z</code></p>
      <p><code>% имеются ключевые пункты,</code></p>
      <p><code>% стоимости всех дуг равны 0</code></p>
      <p><code>X-Z ---&gt; или : СписокЗадач</code></p>
      <p><code> :- bagof( ( X-Z через Y)/0, клпункт( X-Z, Y),</code></p>
      <p><code> СписокЗадач), !.</code></p>
      <empty-line/>
      <p><code>% Правила для задачи X-Z без ключевых пунктов</code></p>
      <p><code>X-Z ---&gt; или : СписокЗадач</code></p>
      <p><code> :- bagof( ( Y-Z)/P, связь( X, Y, P), СписокЗадач).</code></p>
      <empty-line/>
      <p><code>% Сведение задачи типа "через" к подзадачам,</code></p>
      <p><code>% связанным отношением И</code></p>
      <p><code>X-Z через Y---&gt; и : [( X-Y)/0, ( Y-Z)/0].</code></p>
      <p><code> цель( X-X) % Тривиальная задача: попасть из X в X</code></p>
      <p>Функцию <emphasis>h</emphasis> можно определить, например, как расстояние, которое нужно преодолеть при воздушном сообщении между городами.</p>
      <subtitle>Упражнение</subtitle>
      <p><strong>13.4.</strong> Напишите процедуру</p>
      <p><code>отобр2( РешДер)</code></p>
      <p>для отображения решающего дерева, найденного программой <code>и_или</code> рис. 13.12. Формат отображения пусть будет аналогичен тому, что применялся в процедуре <code>отобр</code> (рис. 13.8), так что процедуру <code>отобр2</code> можно получить, внеся в <code>отобр</code> изменения, связанные с другим представлением деревьев. Другая полезная модификация — заменить в <code>отобр</code> цель <code>write( Верш)</code> на процедуру, определяемую пользователем</p>
      <p><code>печверш( Верш, H)</code></p>
      <p>которая выведет <code>Верш</code> в удобной для пользователя форме, а также конкретизирует <code>H</code> в соответствии с количеством символов, необходимом для представления <code>Верш</code> в этой форме. В дальнейшем <code>H</code> будет использоваться как величина отступа для поддеревьев.</p>
     </section>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• И/ИЛИ-граф — это формальный аппарат для представления задач. Такое представление является наиболее естественным и удобным для задач, которые разбиваются на независимые подзадачи. Примером могут служить игры.</p>
     <p>• Вершины И/ИЛИ-графа бывают двух типов: И-вершины и ИЛИ-вершины.</p>
     <p>• Конкретная задача определяется стартовой вершиной и целевым условием. Решение задачи представляется решающим деревом.</p>
     <p>• Для моделирования оптимизационных задач в И/ИЛИ-граф можно ввести стоимости дуг и вершин.</p>
     <p>• Процесс решения задачи, представленной И/ИЛИ-графом, включает в себя поиск в графе. Стратегия поиска в глубину предусматривает систематический просмотр графа и легко программируется. Однако эта стратегия может привести к неэффективности из-за комбинаторного взрыва.</p>
     <p>• Для оценки трудности задач можно применить эвристики, а для управления поиском — принцип эвристического поиска с предпочтением. Эта стратегия более трудна в реализации.</p>
     <p>• В данной главе были разработаны прологовские программы для поиска в глубину и поиска с предпочтением в И/ИЛИ-графах.</p>
     <p>• Были введены следующие понятия: </p>
     <p>  И/ИЛИ-графы</p>
     <p>  И-дуги, ИЛИ-дуги</p>
     <p>  И-вершины, ИЛИ-вершины</p>
     <p>  решающий путь, решающее дерево</p>
     <p>  стоимость дуг и вершин</p>
     <p>  эвристические оценки в И/ИЛИ-графах</p>
     <p>  "возвращенные" оценки</p>
     <p>  поиск в глубину в И/ИЛИ-графах</p>
     <p>  поиск с предпочтением в И/ИЛИ-графах</p>
     <subtitle>Литература</subtitle>
     <p>И/ИЛИ-графы и связанные с ними алгоритмы поиска являются частью классических механизмов искусственного интеллекта для решения задач и реализации машинных игр. Ранним примером прикладной задачи, использующей эти методы, может служить программа символического интегрирования (Slagle 1963). И/ИЛИ-поиск используется в самой пролог-системе. Общее описание И/ИЛИ-графов и алгоритма можно найти в учебниках по искусственному интеллекту (Nilsson 1971; Nilsson 1980). Наша программа поиска с предпочтением — это один из вариантов алгоритма, известного под названием АО*. Формальные свойства АО*-алгоритма (включая его допустимость) изучались несколькими авторами. Подробный обзор полученных результатов можно найти в книге Pearl (1984).</p>
     <empty-line/>
     <p>Nilsson N.J. (1971). <emphasis>Problem-Solving Methods in Artificial Intelligence</emphasis>. McGraw-Hill.</p>
     <p>Nilsson N.J. (1980). <emphasis>Principles of Artificial Intelligence</emphasis>. Tioga; also Springer-Verlag.</p>
     <p>Pearl J. (1984). <emphasis>Heuristics: Intelligent Search Strategies for Computer Problem Solving</emphasis>. Addison-Wesley.</p>
     <p>Slagle J.R. (1963). A heuristic program that solves symbolic integration problems in freshman calculus. In: <emphasis>Computers and Thought</emphasis> (E. Feigenbaum, J. Feldman, eds.). McGraw-Hill. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 14</p>
     <p>Экспертные системы</p>
    </title>
    <section>
     <p>Экспертная система - это программа, которая ведет себя подобно эксперту в некоторой проблемной области. Она должна иметь способность к <emphasis>объяснению</emphasis> своих решений и тех рассуждений, на основе которых эти решения были приняты. Часто от экспертной системы требуют, чтобы она могла работать с неточной и неполной информацией.</p>
     <p>Для того, чтобы построить экспертную систему, мы должны создать механизмы, обеспечивающие выполнение следующих функций: решение задач, взаимодействие с пользователем и работа в условиях неопределенности. В данной главе мы разработаем и peaлизуем основные идеи построения экспертных систем.</p>
    </section>
    <section>
     <title>
      <p>14.1. Функции, выполняемые экспертной системой</p>
     </title>
     <p><emphasis>Экспертная система</emphasis> — это программа, которая ведет себя подобно эксперту в некоторой, обычно узкой, прикладной области. Типичные применения экспертных систем включают в себя такие задачи, как медицинская диагностика, локализация неисправностей в оборудовании и интерпретация результатов измерений. Экспертные системы должны решать задачи, требующие для своего решения экспертных знаний в некоторой конкретной области. В той или иной форме экспертные системы должны обладать этими знаниями. Поэтому их также называют <emphasis>системами</emphasis>,<emphasis> основанными на знаниях</emphasis>. Однако не всякую систему, основанную на знаниях, можно рассматривать как экспертную. Экспертная система должна также уметь каким-то образом <emphasis>объяснять</emphasis> свое поведение и свои решения пользователю, так же, как это делает эксперт-человек. Это особенно необходимо в областях, для которых характерна неопределенность, неточность информации (например, в медицинской диагностике). В этих случаях способность к объяснению нужна для того, чтобы повысить степень доверия пользователя к советам системы, а также для того, чтобы дать возможность пользователю обнаружить возможный дефект в рассуждениях системы. В связи с этим в экспертных системах следует предусматривать дружественное взаимодействие с пользователем, которое делает для пользователя процесс рассуждения системы "прозрачным".</p>
     <p>Часто к экспертным системам предъявляют дополнительное требование — способность иметь дело с неопределенностью и неполнотой. Информация о поставленной задаче может быть неполной или ненадежной; отношения между объектами предметной области могут быть приближенными. Например, может не быть полной уверенности в наличии у пациента некоторого симптома или в том, что данные, полученные лри измерении, верны; лекарство <emphasis>может</emphasis> стать причиной осложнения, хотя <emphasis>обычно</emphasis> этого не происходит. Во всех этих случаях необходимы рассуждения с использованием вероятностного подхода.</p>
     <p>В самом общем случае для того, чтобы построить экспертную систему, мы должны разработать механизмы выполнения следующих функций системы:</p>
     <p>• <emphasis>решение задач</emphasis> с использованием знаний о конкретной предметной области — возможно, при этом возникнет необходимость <emphasis>иметь дело с неопределенностью</emphasis></p>
     <p>• <emphasis>взаимодействие с пользователем</emphasis>, включая объяснение намерений и решений системы во время и после окончания процесса решения задачи.</p>
     <p>Каждая из этих функций может оказаться очень сложной и зависит от прикладной области, а также от различных практических требований. В процессе разработки и реализации могут возникать разнообразные трудные проблемы. В данной главе мы ограничился наметками основных идей, подлежащих в дальнейшем детализации и усовершенствованию.</p>
    </section>
    <section>
     <title>
      <p>14.2. Грубая структура экспертной системы</p>
     </title>
     <p>При разработке экспертной системы принято делить ее на три основных модуля, как показано на рис. 14.1:</p>
     <p>(1) база знаний,</p>
     <p>(2) машина логического вывода,</p>
     <p>(3) интерфейс с пользователем.</p>
     <p><emphasis>База знаний</emphasis> содержит знания, относящиеся к конкретной прикладной области, в том числе отдельные факты, правила, описывающие отношения или явления, а также, возможно, методы, эвристики и различные идеи, относящиеся к решению задач в этой прикладной области. <emphasis>Машина логического вывода</emphasis> умеет активно использовать информацию, содержащуюся в базе знаний. <emphasis>Интерфейс с пользователем</emphasis> отвечает за бесперебойный обмен информацией между пользователем и системой; он также дает пользователю возможность наблюдать за процессом решения задач, протекающим в машине логического вывода. Принято рассматривать машину вывода и интерфейс как один крупный модуль, обычно называемый <emphasis>оболочкой экспертной системы</emphasis>, или, для краткости, просто <emphasis>оболочкой</emphasis>.</p>
     <image l:href="#_100.png"/>
     <p><strong>Рис. 14.1.</strong> Структура экспертной системы.</p>
     <p>В описанной выше структуре собственно знания отделены от алгоритмов, использующих эти знания. Такое разделение удобно по следующим соображениям. База знаний, очевидно, зависит от конкретного приложения. С другой стороны, оболочка, по крайней мере в принципе, независима от приложений. Таким образом, разумный способ разработки экспертной системы для нескольких приложений сводится к созданию универсальной оболочки, после чего для каждого приложения достаточно подключить к системе новую базу знаний. Разумеется, все эти базы знаний должны удовлетворять одному и тому же формализму, который оболочка "понимает". Практический опыт показывает, что для сложных экспертных систем наш сценарий с одной оболочкой и многими базами знаний работает не так гладко, как бы этого хотелось, за исключением тех случаев, когда прикладные области очень близки. Тем не менее даже если переход от одной прикладной области к другой требует модификации оболочки, то по крайней мере основные принципы ее построения обычно удается сохранить.</p>
     <p>В этой главе мы намерены разработать относительно простую оболочку, при помощи которой, несмотря на. ее простоту, мы сможем проиллюстрировать основные идеи и методы в области экспертных систем. Мы будем придерживаться следующего плана:</p>
     <p>(1) Выбрать формальный аппарат для представления знаний.</p>
     <p>(2) Разработать механизм логического вывода, соответствующий этому формализму.</p>
     <p>(3) Добавить средства взаимодействия с пользователем.</p>
     <p>(4) Обеспечить возможность работы в условиях неопределенности.</p>
    </section>
    <section>
     <title>
      <p>14.3. Правила типа "если-то" для представления знаний</p>
     </title>
     <p>В качестве кандидата на использование в экспертной системе можно рассматривать, в принципе, любой непротиворечивый формализм, в рамках которого можно описывать знания о некоторой проблемной области. Однако самым популярным формальным языком представления знаний является язык правил типа "если-то" (или кратко: "если-то"-правил), называемых также <emphasis>продукциями</emphasis>. Каждое такое правило есть, вообще говоря, некоторое условное утверждение, но возможны и различные другие интерпретации. Вот примеры:</p>
     <p><emphasis>• если</emphasis> предварительное условие P <emphasis>то</emphasis> заключение (вывод) С</p>
     <p>• <emphasis>если</emphasis> ситуация S <emphasis>то</emphasis> действие А</p>
     <p>• <emphasis>если</emphasis> выполнены условия C1 и C2 <emphasis>то</emphasis> не выполнено условие С</p>
     <p>"Если-то"-правила обычно оказываются весьма естественным выразительным средством представления знаний. Кроме того, они обладают следующими привлекательными свойствами:</p>
     <p>• <emphasis>Модульность</emphasis>: каждое правило описывает небольшой, относительно независимый фрагмент знаний.</p>
     <p>• Возможность <emphasis>инкрементного наращивания</emphasis>: добавление новых правил в базу знаний происходит относительно независимо от других правил.</p>
     <p>• <emphasis>Удобство модификации</emphasis> (как следствие модульности): старые правила можно изменять и заменять на новые относительно независимо от других правил.</p>
     <p>• Применение правил способствует <emphasis>прозрачности</emphasis> системы.</p>
     <p>Последнее свойство — это важное, отличительное свойство экспертных систем. Под прозрачностью мы понимаем способность системы к объяснению принятых решений и полученных результатов. Применение "если-то"-правил облегчает получение ответов на следующие основные типы вопросов пользователя:</p>
     <p>(1) Вопросы типа "как": <emphasis>Как</emphasis> вы пришли к этому выводу?</p>
     <p>(2) Вопросы типа "почему": <emphasis>Почему</emphasis> вас интересует эта информация?</p>
     <p>Механизмы, основанные на "если-то"-правилах, для формирования ответов на подобные вопросы мы обсудим позже.</p>
     <empty-line/>
     <p><emphasis>если</emphasis></p>
     <p> 1 тип инфекции — это первичная бактериемия и</p>
     <p> 2 материал для посева был отобран стерильно, и</p>
     <p> 3 предполагаемые ворота инфекции — желудочно-кишечный тракт</p>
     <p><emphasis>то</emphasis></p>
     <p> имеются веские аргументы (0.7) за то,</p>
     <p> что инфекционный агент является бактерией</p>
     <p><strong>Рис. 14.2.</strong> "Если-то"-правило медицинской консультативной системы MYCIN (Shortliffe, 1976). Параметр 0.7 показывает степень доверия этому правилу.</p>
     <empty-line/>
     <p>"Если-то"-правила часто применяют для определения логических отношений между понятиями предметной области. Про чисто логические отношения можно сказать, что они принадлежат к "категорическим знаниям", "категорическим" — потому, что соответствующие утверждения всегда, абсолютно верны. Однако в некоторых предметных областях, таких, как медицинская диагностика, преобладают "мягкие" или вероятностные знания. Эти знания являются "мягкими"; в том смысле, что говорить об их применимости к любым практическим ситуациям можно только до некоторой степени ("часто, но не всегда"). В таких случаях используют модифицированные "если-то"-правила, дополняя их логическую интерпретацию вероятностной оценкой. Например:</p>
     <p><emphasis>если</emphasis> условие А <emphasis>то</emphasis> заключение В <emphasis>с уверенностью</emphasis> F</p>
     <p>Рис. 14.2, 14.3 и 14.4 дают представление о разнообразии способов, которыми знания могут быть выражены при помощи "если-то"-правил. На этих рисунках приведены примеры правил из трех различных систем, основанных на знаниях: медицинской консультативной системы MYCIN, системы AL/X для диагностики неисправностей в оборудовании и системы AL3 для решения шахматных задач.</p>
     <p>Вообще говоря, если вы хотите разработать серьезную экспертную систему для некоторой выбранной вами предметной области, вы должны провести консультации с экспертами в этой области и многое узнать о ней сами. Достигнуть определенного понимания предметной области после общения с экспертами и чтения литературы, а затем облечь это понимание в форму представления знаний в рамках выбранного формального языка — это искусство, называемое <emphasis>инженерией знаний</emphasis>. Как правило, это сложная задача, требующая больших усилий, чего мы не можем себе позволить в данной книге. Но какая-нибудь предметная область и какая-нибудь база данных нам необходимы в качестве материала для экспериментов. С практической точки зрения нам для этой цели вполне подойдет "игрушечная" база знаний. На рис. 14.5 показана часть такой базы знаний. Она состоит из простых правил, помогающих идентифицировать животных по их основным признаками в предположении, что задача идентификации ограничена только небольшим числом разных животных.</p>
     <empty-line/>
     <p><emphasis>если</emphasis></p>
     <p> давление в v-01 достигло уровня открытия выпускного клапана</p>
     <p><emphasis>то</emphasis></p>
     <p> выпускной клапан в v-01 открылся</p>
     <p> [N=0.005, S=400]</p>
     <p><emphasis>если</emphasis></p>
     <p> давление в v-01 не достигло уровня открытия выпускного клапана и выпускной клапан в v-01 открылся</p>
     <p><emphasis>то</emphasis></p>
     <p> преждевременное открытие выпускного клапана (сместилась установка порогового давления)</p>
     <p> [N=0.001, S=2000]</p>
     <p><strong>Рис. 14.3.</strong> Два правила из демонстрационной базы знаний системы AL/X для диагностики неисправностей (Reiter 1980). N и S — величины "необходимости" и "достаточности", детально описанные в разд. 14.7. Величина S указывает степень, с которой условие влечет за собой заключение (вывод). Величина N указывает, до какой степени истинность условия необходима для того, чтобы заключение было истинным.</p>
     <empty-line/>
     <p><emphasis>если</emphasis></p>
     <p> 1 существует гипотеза <emphasis>H</emphasis>, что план <emphasis>P</emphasis> ведет к успеху, и</p>
     <p> 2 существуют две гипотезы</p>
     <p>  <emphasis>H1</emphasis>, что план <emphasis>P1</emphasis> опровергает план <emphasis>P</emphasis>, и</p>
     <p>  <emphasis>Н2</emphasis>, что план <emphasis>Р2</emphasis> опровергает план <emphasis>P</emphasis>, и</p>
     <p> 3 имеют место факты:</p>
     <p>   гипотеза <emphasis>H1</emphasis> ложна и</p>
     <p>   гипотеза <emphasis>Н2</emphasis> ложна</p>
     <p><emphasis>то</emphasis></p>
     <p> 1 породить гипотезу <emphasis>Н3</emphasis>, что составной план <emphasis>"P1 или Р2"</emphasis> опровергает план <emphasis>P</emphasis>, и</p>
     <p> 2 породить факт: <emphasis>из  Н3 следует не( H)</emphasis></p>
     <p><strong>Рис. 14.4.</strong> Правило уточнения плана из системы AL3 для решения шахматных задач (Bratko 1982).</p>
     <empty-line/>
     <p>Правила, содержащиеся в базе знаний, имеют вид</p>
     <p><code>ИмяПравила : если Условие то Заключение</code></p>
     <p>где <code>Заключение</code> — это простое утверждение, а <code>Условие</code> — это набор простых утверждений, соединенных между собой операторами <code>и</code> и <code>или</code>. Мы также разрешим в части условия использовать оператор <code>не</code>, хотя и с некоторыми оговорками. При надлежащем прологовском определении этих операторов (как это сделано на рис. 14.5) правила станут синтаксически верными предложениями Пролога. Заметим, что оператор <code>и</code> связывает операнды сильнее, чем <code>или</code>, что соответствует обычным соглашениям.</p>
     <empty-line/>
     <p><code>% Небольшая база знаний для идентификации животных</code></p>
     <p><code>:- op( 100, xfx, [имеет, 'кормит детенышей',</code></p>
     <p><code> 'не может', ест, откладывает, это]).</code></p>
     <p><code>:- op( 100, xf, [плавает, летает, хорошо]).</code></p>
     <empty-line/>
     <p><code>прав1: если</code></p>
     <p><code> Животное имеет шерсть</code></p>
     <p><code> или</code></p>
     <p><code> Животное 'кормит детенышей' молоком</code></p>
     <p><code>то</code></p>
     <p><code> Животное это млекопитающее.</code></p>
     <empty-line/>
     <p><code>прав2: если</code></p>
     <p><code> Животное имеет перья</code></p>
     <p><code> или</code></p>
     <p><code> Животное летает и</code></p>
     <p><code> Животное откладывает яйца</code></p>
     <p><code>то</code></p>
     <p><code> Животное это птица.</code></p>
     <empty-line/>
     <p><code>прав3: если</code></p>
     <p><code> Животное это млекопитающее и</code></p>
     <p><code> ( Животное ест мясо</code></p>
     <p><code>   или</code></p>
     <p><code>   Животное имеет 'острые зубы' и</code></p>
     <p><code>   Животное имеет когти и</code></p>
     <p><code>   Животное имеет</code></p>
     <p><code>   'глаза, направленные вперед' )</code></p>
     <p><code>то</code></p>
     <p><code> Животное это хищник.</code></p>
     <empty-line/>
     <p><code>прав4: если</code></p>
     <p><code> Животное это хищник и</code></p>
     <p><code> Животное имеет</code></p>
     <p><code>  'рыжевато-коричневый цвет' и</code></p>
     <p><code> Животное имеет 'темные пятна'</code></p>
     <p><code>то</code></p>
     <p><code> Животное это гепард.</code></p>
     <empty-line/>
     <p><code>прав5: если</code></p>
     <p><code> Животное это хищник и</code></p>
     <p><code> Животное имеет</code></p>
     <p><code>  'рыжевато-коричневый цвет' и</code></p>
     <p><code> Животное имеет 'черные полосы'</code></p>
     <p><code>то</code></p>
     <p><code> Животное это тигр.</code></p>
     <empty-line/>
     <p><code>прав6: если</code></p>
     <p><code> Животное это птица и</code></p>
     <p><code> Животное 'не может' летать и</code></p>
     <p><code> Животное плавает</code></p>
     <p><code>то</code></p>
     <p><code> Животное это пингвин.</code></p>
     <empty-line/>
     <p><code>прав7: если</code></p>
     <p><code> Животное это птица и</code></p>
     <p><code> Животное летает хорошо</code></p>
     <p><code>то</code></p>
     <p><code> Животное это альбатрос.</code></p>
     <empty-line/>
     <p><code>факт: X это животное :-</code></p>
     <p><code> принадлежит( X, [гепард, тигр, пингвин, альбатрос]).</code></p>
     <empty-line/>
     <p><code>можно_спросить( _ 'кормит детенышей' _,</code></p>
     <p><code> 'Животное' 'кормит детенышей' 'Чем').</code></p>
     <p><code>можно_спросить( _ летает, 'Животное' летает).</code></p>
     <p><code>можно_спросить( _ откладывает яйца,</code></p>
     <p><code> 'Животное' откладывает яйца).</code></p>
     <p><code>можно_спросить( _ ест _, 'Животное' ест 'Что').</code></p>
     <p><code>можно_спросить( _ имеет _,'Животное' имеет 'Нечто').</code></p>
     <p><code>можно_спросить( _ 'не может' _,</code></p>
     <p><code> 'Животное' 'не может' 'Что делать').</code></p>
     <p><code>можно_спросить( _ плавает, 'Животное' плавает).</code></p>
     <p><code>можно_спросить( _ летает хорошо,</code></p>
     <p><code> 'Животное' летает хорошо).</code></p>
     <p><strong>Рис. 14.5.</strong> Простая база знаний для идентификации животных. Заимствовано из Winston (1984). Отношение "можно_спросить" определяет вопросы, которые можно задавать пользователю. Операторы <code>если</code>, <code>то</code>, <code>и</code>, <code>или</code> определены на рис. 14.10.</p>
     <empty-line/>
     <p>Рассмотрим еще одну небольшую базу знаний, которая может помочь локализовать неисправности в простой электрической схеме, состоящей из электрических приборов и предохранителей. Электрическая схема показана на рис. 14.6. Вот одно из возможных правил:</p>
     <p><emphasis>если</emphasis></p>
     <p> лампа1 включена <emphasis>и</emphasis></p>
     <p> лампа1 не работает  <emphasis>и</emphasis></p>
     <p> предохранитель1 заведомо цел</p>
     <p><emphasis>то</emphasis></p>
     <p> лампа1 заведомо неисправна.</p>
     <p>Вот другой пример правила:</p>
     <p><emphasis>если</emphasis></p>
     <p> радиатор работает</p>
     <p><emphasis>то</emphasis></p>
     <p> предохранитель1 заведомо цел.</p>
     <image l:href="#_101.png"/>
     <p><strong>Рис. 14.6.</strong> Соединения между предохранителями и приборами в простой электрической схеме.</p>
     <p>Эти два правила опираются на некоторые факты (относящиеся к нашей <emphasis>конкретной</emphasis> схеме), а именно что <emphasis>лампа1</emphasis> соединена с <emphasis>предохранитель1</emphasis> и что <emphasis>лампа1</emphasis> и <emphasis>радиатор</emphasis> имеют общий предохранитель. Для другой схемы нам понадобится еще один набор правил. Поэтому было бы лучше сформулировать правила в более общем виде (используя прологовские переменные) так, чтобы они были применимы к любой схеме, а затем уже дополнять их информацией о конкретной схеме. Например, вот одно из полезных правил: если прибор включен, но не работает, а соответствующий предохранитель цел, то прибор неисправен. На наш формальный язык это транслируется так:</p>
     <p><code>правило_поломки:</code></p>
     <p><code> если</code></p>
     <p><code>  Прибор включен и</code></p>
     <p><code>  не (Прибор работает) и</code></p>
     <p><code>  Прибор соединен с Предохранитель и</code></p>
     <p><code>  Предохранитель заведомо цел</code></p>
     <p><code> то</code></p>
     <p><code>  Прибор заведомо неисправен.</code></p>
     <p>База знаний такого рода показана на рис. 14. 7.</p>
     <empty-line/>
     <p><code>% Небольшая база знаний для локализации неисправностей в</code></p>
     <p><code>% электрической схеме</code></p>
     <empty-line/>
     <p><code>% Если прибор включен, но не работает, и предохранитель цел,</code></p>
     <p><code>% то прибор неисправен.</code></p>
     <p><code>правило_поломки:</code></p>
     <p><code> если</code></p>
     <p><code>  вкл( Прибор) и</code></p>
     <p><code>  прибор( Прибор) и</code></p>
     <p><code>  не работает( Прибор) и</code></p>
     <p><code>  соед( Прибор, Предохр) и</code></p>
     <p><code>  доказано( цел( Предохр) )</code></p>
     <p><code> то</code></p>
     <p><code>  доказано( неиспр( Прибор) ).</code></p>
     <empty-line/>
     <p><code>% Если устройство работает, то его предохранитель цел</code></p>
     <p><code>правило_цел_предохр:</code></p>
     <p><code> если</code></p>
     <p><code>  соед( Прибор, Предохр)</code></p>
     <p><code>  и работает( Прибор)</code></p>
     <p><code> то</code></p>
     <p><code>  доказано( цел( Предохр) ).</code></p>
     <empty-line/>
     <p><code>% Если два различных прибора подключены к одному и тому же</code></p>
     <p><code>% предохранителю, оба включены и не работают, то предохранитель</code></p>
     <p><code>% сгорел.</code></p>
     <p><code>% ЗАМЕЧАНИЕ: предполагается, что из двух приборов неисправных -</code></p>
     <p><code>% не более одного!</code></p>
     <p><code>правило_предохр:</code></p>
     <p><code> если</code></p>
     <p><code>  соед( Прибор1, Предохр) и</code></p>
     <p><code>  вкл( Прибор1) и</code></p>
     <p><code>  не работает( Прибор1) и</code></p>
     <p><code>  общ_предохр( Прибор2, Прибор1) и</code></p>
     <p><code>  вкл( Прибор2) и</code></p>
     <p><code>  не работает( Прибор2)</code></p>
     <p><code> то</code></p>
     <p><code>  доказано( сгорел( Предохр) ).</code></p>
     <empty-line/>
     <p><code>правило_общ_предохр:</code></p>
     <p><code> если</code></p>
     <p><code>  соед( Прибор1, Предохр) и</code></p>
     <p><code>  соед( Прибор2, Предохр) и</code></p>
     <p><code>  различны( Прибор1, Прибор2)</code></p>
     <p><code> то</code></p>
     <p><code>  общ_предохр( Прибор1, Прибор2).</code></p>
     <empty-line/>
     <p><code>факт: различны( X, Y) :- not (X=Y).</code></p>
     <p><code>факт: прибор( радиатор).</code></p>
     <p><code>факт: прибор( лампа1).</code></p>
     <p><code>факт: прибор( лампа2).</code></p>
     <p><code>факт: прибор( лампа3).</code></p>
     <p><code>факт: прибор( лампа4).</code></p>
     <p><code>факт: соед( лампа1, предохр1).</code></p>
     <p><code>факт: соед( лампа2, предохр1).</code></p>
     <p><code>факт: соед( радиатор, предохр1).</code></p>
     <p><code>факт: соед( лампа3, предохр2).</code></p>
     <p><code>факт: соед( лампа4, предохр2).</code></p>
     <empty-line/>
     <p><code>можно_спросить( вкл( П), вкл( 'Прибор') ).</code></p>
     <p><code>можно_спросить( работает( П), работает(' Прибор')).</code></p>
     <p><strong>Рис. 14.7.</strong> База знаний для локализации неисправностей в схеме, показанной на рис. 14.6.</p>
     <empty-line/>
     <subtitle>Упражнения</subtitle>
     <p><strong>14.1.</strong> Рассмотрите "если-то"-правила рис. 14.2-14.4 и транслируйте их в нашу систему обозначений для правил. Предложите расширение нотации, чтобы, при необходимости, можно было работать с оценками уверенности.</p>
     <p><strong>14.2.</strong> Придумайте какую-нибудь задачу принятия решений и сформулируйте соответствующие знания в форме "если-то"-правил. Можете рассмотреть, например, планирование отпуска, предсказание погоды, простой медицинский диагноз и лечение и т.п.</p>
    </section>
    <section>
     <title>
      <p>14.4. Разработка оболочки</p>
     </title>
     <section>
      <p>Если мы посмотрим на правила наших двух маленьких баз знаний рис. 14.5 и 14.7, мы сразу увидим, что они по своему смыслу эквивалентны правилам Пролога. Однако, с точки зрения синтаксиса Пролога, эти правила в том виде, как они написаны, соответствуют всего лишь фактам. Для того, чтобы заставить их работать, самое простое, что может прийти в голову, это переписать их в виде настоящих прологовских правил. Например:</p>
      <p><code>Животное это млекопитающее :-</code></p>
      <p><code> Животное имеет шерсть;</code></p>
      <p><code> Животное 'кормит детенышей' молоком.</code></p>
      <empty-line/>
      <p><code>Животное это хищник :-</code></p>
      <p><code> Животное это млекопитающее,</code></p>
      <p><code> Животное ест мясо.</code></p>
      <p><code>...</code></p>
      <p>Теперь эта программа сможет подтвердить, что тигр по имени Питер — это действительно тигр, если мы добавим в нее некоторые из свойств Питера (в виде прологовских фактов):</p>
      <p><code>питер имеет шерсть.</code></p>
      <p><code>питер ленив.</code></p>
      <p><code>питер большой.</code></p>
      <p><code>питер имеет 'рыжевато-коричневый цвет'.</code></p>
      <p><code>питер имеет 'черные полосы'.</code></p>
      <p><code>питер ест мясо.</code></p>
      <p>Тогда мы можем спросить:</p>
      <p><code>?- питер это тигр.</code></p>
      <p><code>yes</code></p>
      <empty-line/>
      <p><code>?- питер это гепард.</code></p>
      <p><code>no</code></p>
      <p>Хотя пролог-система и отвечает на вопросы, используя для этого нашу базу знаний, нельзя сказать, что ее поведение вполне соответствует поведению эксперта. Это происходит по крайней мере по двум причинам:</p>
      <p>(1) Мы не можем попросить систему объяснить свой ответ; например, <emphasis>как</emphasis> она установила, что Питер это тигр, и <emphasis>почему</emphasis> Питер это <emphasis>не</emphasis> гепард.</p>
      <p>(2) Прежде, чем задать вопрос, нужно ввести в систему всю необходимую информацию (в виде прологовских фактов). Но тогда пользователь, возможно, введет какую-нибудь лишнюю информацию (как в нашем примере) или же упустит какую-нибудь информацию, имеющую решающее значение. В первом случае будет проделана ненужная работа, а во втором - система будет давать неверные ответы.</p>
      <p>Для того, чтобы исправить эти два недостатка, мы нуждаемся в более совершенном способе взаимодействия между пользователем и системой во время и после завершения процесса рассуждений. Поставим себе целью добиться того, чтобы система взаимодействовала с пользователем так, как в следующем примере диалога (ответы пользователя даются полужирным шрифтом, реплики пролог-системы — курсивом):</p>
      <p><code><emphasis>Пожалуйста, спрашивайте:</emphasis></code></p>
      <p><code><strong>питер это тигр.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет шерсть?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер ест мясо?</emphasis></code></p>
      <p><code><strong>нет.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет острые зубы?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет когти?</emphasis></code></p>
      <p><code><strong>почему.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Чтобы проверить по прав3, что питер это хищник,</emphasis></code></p>
      <p><code><emphasis>Чтобы проверить по прав5, что питер это тигр</emphasis></code></p>
      <p><code><emphasis>Это был ваш вопрос</emphasis></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет когти?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет глаза, направленные вперед?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет рыжевато-коричневый цвет?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер имеет черные полосы?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>(питер это тигр) это правда</emphasis></code></p>
      <p><code><emphasis>Хотите узнать, как?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>питер это тигр</emphasis></code></p>
      <p><code><emphasis> было выведено по прав5 из</emphasis></code></p>
      <p><code><emphasis>  питер это хищник,</emphasis></code></p>
      <p><code><emphasis>   было выведено по прав3 из</emphasis></code></p>
      <p><code><emphasis>    питер это млекопитающее</emphasis></code></p>
      <p><code><emphasis>     было выведено по прав1 из</emphasis></code></p>
      <p><code><emphasis>      питер имеет шерсть</emphasis></code></p>
      <p><code><emphasis>       было сказано</emphasis></code></p>
      <p><code><emphasis>    и</emphasis></code></p>
      <p><code><emphasis>    питер имеет острые зубы</emphasis></code></p>
      <p><code><emphasis>     было сказано</emphasis></code></p>
      <p><code><emphasis>    и</emphasis></code></p>
      <p><code><emphasis>    питер имеет когти</emphasis></code></p>
      <p><code><emphasis>     было сказано</emphasis></code></p>
      <p><code><emphasis>    и</emphasis></code></p>
      <p><code><emphasis>    питер имеет глаза, направленные вперед</emphasis></code></p>
      <p><code><emphasis>     было сказано</emphasis></code></p>
      <p><code><emphasis>    и</emphasis></code></p>
      <p><code><emphasis>    питер имеет рыжевато-коричневый цвет</emphasis></code></p>
      <p><code><emphasis>     было сказано</emphasis></code></p>
      <p><code><emphasis>    и</emphasis></code></p>
      <p><code><emphasis>    питер имеет черные полосы</emphasis></code></p>
      <p><code><emphasis>     было сказано</emphasis></code></p>
      <p>Как видно из диалога, система задает пользователю вопросы, касающиеся "примитивной" информации, например:</p>
      <p><code><emphasis>Это правда: питер ест мясо?</emphasis></code></p>
      <p>Эту информацию нельзя отыскать в базе знаний или вывести из другой информации. На подобные вопросы пользователь может отвечать двумя способами:</p>
      <p>(1) сообщив системе в качестве ответа на вопрос необходимую информацию или</p>
      <p>(2) спросив систему, <emphasis>почему</emphasis> эта информация необходима.</p>
      <p>Последняя из двух возможностей полезна, поскольку она позволяет пользователю заглянуть внутрь системы и увидеть ее текущие намерения. Пользователь спросит "почему" в том случае, когда вопрос системы покажется ему не относящимся к делу либо когда ответ на вопрос системы потребует от него дополнительных усилий. Из объяснений системы пользователь поймет, стоит ли информация, которую запрашивает система, тех дополнительных усилий, которые необходимо приложить для ее приобретения. Предположим, например, что система спрашивает: "Это животное ест мясо?" Пользователь, не знающий ответа на этот вопрос, поскольку он никогда не видел, как это животное ело что-либо, может решить, что не стоит ждать, пока он застанет животное за едой и убедится, что оно действительно ест мясо.</p>
      <p>Для того, чтобы заглянуть внутрь системы и до какой-то степени представить себе протекающий в ней процесс рассуждений, можно воспользоваться прологовскими средствами трассировки. Но эти средства в большинстве случаев окажутся недостаточно гибкими для наших целей. Поэтому, вместо того, чтобы воспользоваться собственным механизмом интерпретации Пролога, который не сможет справиться с нужным нам способом взаимодействия с пользователем, мы создадим свое средство интерпретации в виде специальной надстройки над пролог-системой. Этот новый интерпретатор будет включать в себя средства для взаимодействия с пользователем.</p>
     </section>
     <section>
      <title>
       <p>14.4.1. Процесс рассуждений</p>
      </title>
      <p>Наш интерпретатор будет принимать вопрос и искать на него ответ. Язык правил допускает, чтобы в условной части правила была И/ИЛИ-комбинация условий. Вопрос на входе интерпретатора может быть такой же комбинацией подвопросов. Поэтому процесс поиска ответов на эти вопросы будет аналогичен процессу поиска в И/ИЛИ-графах, который мы обсуждали в гл. 13.</p>
      <p>Ответ на заданный вопрос можно найти несколькими способами в соответствии со следующими принципами:</p>
      <cite>
       <p>Для того, чтобы найти ответ <emphasis>Отв</emphasis> на вопрос <emphasis>В</emphasis>, используйте одну из следующих возможностей:</p>
       <p>• если <emphasis>В</emphasis> найден в базе знаний в виде факта, то <emphasis>Отв</emphasis> — это "<emphasis>В</emphasis> это правда"</p>
       <p>• если в базе знаний существует правило вида</p>
       <p>  "если <emphasis>Условие</emphasis> то <emphasis>В</emphasis>",</p>
       <p>то для получения ответа <emphasis>Отв</emphasis> рассмотрите <emphasis>Условие</emphasis></p>
       <p>• если вопрос <emphasis>В</emphasis> можно задавать пользователю, спросите пользователя об истинности <emphasis>В</emphasis></p>
       <p>• если в имеет вид <emphasis>В1 и В2</emphasis>, то рассмотрите <emphasis>В1</emphasis>, а затем,</p>
       <p>  если <emphasis>В1 </emphasis>ложно, то положите <emphasis>Отв </emphasis>равным "<emphasis>В </emphasis>это ложь",  в противном случае рассмотрите <emphasis>В2 </emphasis>и получите <emphasis>Отв </emphasis>как соответствующую комбинацию ответов на вопросы <emphasis>В1</emphasis> и <emphasis>В2</emphasis></p>
       <p>• если <emphasis>В</emphasis> имеет вид <emphasis>В1 или В2</emphasis>, то рассмотрите <emphasis>В1</emphasis>, а затем,</p>
       <p>  если <emphasis>В1</emphasis> истинно, то положите <emphasis>Отв</emphasis> равным "<emphasis>В1</emphasis> это правда",  в противном случае рассмотрите <emphasis>В2</emphasis> и получите <emphasis>Oтв</emphasis> как соответствующую комбинацию ответов на вопросы <emphasis>В1</emphasis> и <emphasis>В2</emphasis>.</p>
      </cite>
      <p>Вопросы вида</p>
      <p><emphasis>не В</emphasis></p>
      <p>обрабатываются не так просто, и мы обсудим их позже. </p>
     </section>
     <section>
      <title>
       <p>14.4.2. Формирование ответа на вопрос "почему"</p>
      </title>
      <p>Вопрос "<emphasis>почему</emphasis>" возникает в ситуации, когда система просит пользователя сообщить ей некоторую информацию, а пользователь желает знать, <emphasis>почему</emphasis> эта информация необходима. Допустим, что система спрашивает:</p>
      <p><code><emphasis>а — это правда?</emphasis></code></p>
      <p>В ответ пользователь может спросить:</p>
      <p><code><strong>почему?</strong></code></p>
      <p>Объяснение в этом случае выглядит примерно так:</p>
      <p>Потому, что</p>
      <p>Я могу использовать <emphasis>а</emphasis>,</p>
      <p>  чтобы проверить по правилу <emphasis>П<sub>а</sub></emphasis>, что <emphasis>b</emphasis>, и</p>
      <p>Я могу использовать <emphasis>b</emphasis>,</p>
      <p>  чтобы проверить по правилу <emphasis>П<sub>b</sub></emphasis>, что <emphasis>с</emphasis>, и</p>
      <p>Я могу использовать <emphasis>с</emphasis>,</p>
      <p>  чтобы проверить по правилу <emphasis>П<sub>c</sub></emphasis>, что <emphasis>d</emphasis>, и</p>
      <p>…</p>
      <p>Я могу использовать <emphasis>y</emphasis>,</p>
      <p>  чтобы проверить по правилу <emphasis>П<sub>y</sub></emphasis>, что <emphasis>z</emphasis>, и</p>
      <p><emphasis>z</emphasis> — это ваш исходный вопрос.</p>
      <p>Объяснение — это демонстрация того, как система намерена использовать информацию, которую она хочет получить от пользователя. Намерения системы демонстрируются в виде цепочки правил и целей, соединяющей эту информацию с исходным вопросом.</p>
      <image l:href="#_102.png"/>
      <p><strong>Рис. 14.8.</strong> Объяснение типа "почему". На вопрос "Почему вас интересует текущая цель?" дается объяснение в виде цепочки правил и целей, соединяющей текущую цель с исходным вопросом пользователя, находящимся в верхушке дерева. Эта цепочка называется трассой.</p>
      <p>Будем называть такую цепочку <emphasis>трассой</emphasis>. Трассу можно себе представлять как цепочку правил, соединяющую в И/ИЛИ-дереве вопросов текущую цель с целью самого верхнего уровня так, как это показано на рис. 14.8. Таким образом, для формирования ответа на вопрос "почему" нужно двигаться в пространстве поиска от текущей цели вверх вплоть до самой верхней цели. Для того, чтобы суметь это сделать, нам придется в процессе рассуждений сохранять трассу в явном виде. </p>
     </section>
     <section>
      <title>
       <p>14.4.3. Формирование ответа на вопрос "как"</p>
      </title>
      <p>Получив ответ на свой вопрос, пользователь возможно захочет увидеть, <emphasis>как</emphasis> система пришла к такому заключению. Один из подходящих способов ответить на вопрос "как" — это представить доказательство, т.е. те правила и подцели, которые использовались для достижения полученного заключения. Это доказательство в случае нашего языка записи правил имеет вид решающего И/ИЛИ-дерева. Поэтому наша машина логического вывода будет не просто отвечать на вопрос, соответствующий цели самого верхнего уровня — этого нам недостаточно, а будет выдавать в качестве ответа решающее И/ИЛИ-дерево, составленное из имен правил и подцелей. Затем это дерево можно будет отобразить на выходе системы в качестве объяснения типа "как". Объяснению можно придать удобную для восприятия форму, если каждое поддерево печатать с надлежащим отступом, например:</p>
      <p><code><emphasis>питер это хищник</emphasis></code></p>
      <p><code><emphasis> было выведено по прав3 из</emphasis></code></p>
      <p><code><emphasis>  питер это млекопитающее</emphasis></code></p>
      <p><code><emphasis>   было выведено по прав1 из</emphasis></code></p>
      <p><code><emphasis>    питер имеет шерсть</emphasis></code></p>
      <p><code><emphasis>     было сказано</emphasis></code></p>
      <p><code><emphasis>  и</emphasis></code></p>
      <p><code><emphasis>  питер ест мясо</emphasis></code></p>
      <p><code><emphasis>   было сказано</emphasis></code></p>
     </section>
    </section>
    <section>
     <title>
      <p>14.5. Реализация</p>
     </title>
     <section>
      <p>Теперь мы приступим к реализации нашей оболочки, следуя тем идеям, которые обсуждались в предыдущем разделе. На рис. 14.9 показаны основные объекты, которыми манипулирует оболочка. <code>Цель</code> — это вопрос, подлежащий рассмотрению; <code>Трасса</code> — это цепочка, составленная из "целей-предков" и правил, находящихся между вершиной <code>Цель</code> и вопросом самого верхнего уровня; <code>Ответ</code> — решающее дерево типа И/ИЛИ для вершины <code>Цель</code>.</p>
      <image l:href="#_103.png"/>
      <p><strong>Рис. 14.9.</strong> Отношение <code>рассмотреть( Цель,  Трасса,  Ответ).</code></p>
      <p><code>Ответ</code> — это И/ИЛИ решающее дерево для целевого утверждения <code>Цель</code>.</p>
      <p>Основными процедурами оболочки будут:</p>
      <p><code>рассмотреть( Цель, Трасса, Ответ)</code></p>
      <p>Эта процедура находит ответ <code>Ответ</code> на вопрос <code>Цель</code>. Процедура</p>
      <p><code>ответпольз( Цель, Трасса, Ответ)</code></p>
      <p>порождает решения для тех вопросов <code>Цель</code>, которые можно задавать пользователю. Она спрашивает пользователя об истинности утверждения <code>Цель</code>, а также отвечает на вопросы "почему". Процедура</p>
      <p><code>выдать( Ответ)</code></p>
      <p>выводит результат и отвечает на вопросы "как". Все эти процедуры приводятся в действие процедурой-драйвером <code>эксперт</code>.</p>
     </section>
     <section>
      <title>
       <p>14.5.1. Процедура <code>рассмотреть</code></p>
      </title>
      <p>Центральной процедурой оболочки является процедура</p>
      <p><code>рассмотреть( Цель, Трасса, Ответ)</code></p>
      <p>которая будет находить ответ <code>Ответ</code> на заданный вопрос <code>Цель</code>, используя принципы, намеченные в общих чертах в разд. 14.4.1: найти <code>Цель</code> среди фактов базы знаний, или применить правило из базы знаний, или спросить пользователя, или же обработать <code>Цель</code> как И/ИЛИ-комбинацию подцелей.</p>
      <p>Аргументы имеют следующий смысл и следующую структуру:</p>
      <p><code>Цель</code></p>
      <p> вопрос, подлежащий рассмотрению, представленный как И/ИЛИ-комбинация простых утверждений, например</p>
      <p><code> X имеет перья или X летает или</code></p>
      <p><code> X откладывает яйца</code></p>
      <p><code>Трасса</code></p>
      <p> цепочка, составленная из целей-предков и правил, расположенных между <code>Цель</code> и исходной целью самого верхнего уровня. Представляется как список, состоящий из элементов вида</p>
      <p><code> Цель  по  Прав</code></p>
      <p> что означает: <code>Цель</code> рассматривалась с использованием правила <code>Прав</code>. Например, пусть исходной целью будет "питер это тигр", а текущей целью — "питер ест мясо". В соответствии с базой знаний рис. 14.5 имеем трассу</p>
      <p><code> [( питер это хищник) по прав3,</code></p>
      <p><code>  ( питер это тигр) по прав5 ]</code></p>
      <p> Смысл ее можно выразить так:</p>
      <p> Я могу использовать "питер ест мясо" для того, чтобы проверить по прав3, что "питер это хищник".</p>
      <p> Далее, я могу использовать "питер это хищник" для того, чтобы проверить по прав5, что "питер это тигр".</p>
      <p><code>Ответ</code></p>
      <p> решающее И/ИЛИ-дерево для вопроса <code>Цель</code>. Общая форма представления для объекта <code>Ответ</code>:</p>
      <p><code> Заключение было Найдено</code></p>
      <p>где <code>Найдено</code> — это обоснование для результата <code>Заключение</code>. Следующие три примера иллюстрируют различные варианты ответов:</p>
      <p>(1)<code> ( соед( радиатор, предохр1) это правда) было</code> </p>
      <p><code>   'найдено как факт'</code></p>
      <p>(2)<code> (питер ест мясо) это ложь было сказано</code> </p>
      <p>(3)<code> (питер это хищник) это правда было</code> </p>
      <p><code>    ( 'выведено по' прав3 из</code></p>
      <p><code>   (питер это млекопитающее) это правда было</code></p>
      <p><code>    ( 'выведено по' прав1 из</code></p>
      <p><code>   (питер имеет шерсть) это правда было сказано)</code></p>
      <p><code>   и</code></p>
      <p><code>   (питер ест мясо) это правда было сказано )</code></p>
      <p>На рис. 14.10 показана прологовская программа для процедуры <code>рассмотреть</code>. В этой программе реализованы принципы разд. 14.4.1 с использованием только что описанных структур данных.</p>
      <empty-line/>
      <p><code>% Процедура</code></p>
      <p><code>%</code></p>
      <p><code>% рассмотреть( Цель, Трасса, Ответ)</code></p>
      <p><code>%</code></p>
      <p><code>% находит Ответ на вопрос Цель. Трасса - это цепочка</code></p>
      <p><code>% целей-предков и правил. "рассмотреть" стремится найти</code></p>
      <p><code>% положительный ответ на вопрос. Ответ "ложь" выдается</code></p>
      <p><code>% только в том случае, когда рассмотрены все возможности,</code></p>
      <p><code>% и все они дали результат "ложь".</code></p>
      <empty-line/>
      <p><code>:- op( 900, xfx, :).</code></p>
      <p><code>:- op( 800, xfx, было).</code></p>
      <p><code>:- op( 870, fx, если).</code></p>
      <p><code>:- op( 880, xfx, то).</code></p>
      <p><code>:- op( 550, xfy, или).</code></p>
      <p><code>:- op( 540, xfy, и).</code></p>
      <p><code>:- op( 300, fx, 'выведено по').</code></p>
      <p><code>:- op( 600, xfx, из).</code></p>
      <p><code>:- op( 600, xfx, по).</code></p>
      <empty-line/>
      <p><code>% В программе предполагается,что op( 700, хfх, это), op( 500, fx, не)</code></p>
      <p><code>рассмотреть( Цель, Трасса, Цель это правда</code></p>
      <p><code> было 'найдено как факт') :-</code></p>
      <p><code> факт : Цель.</code></p>
      <empty-line/>
      <p><code>% Предполагается, что для каждого типа цели</code></p>
      <p><code>% существует только одно правило</code></p>
      <p><code>рассмотреть( Цель, Трасса,</code></p>
      <p><code> Цель это ПравдаЛожь</code></p>
      <p><code> было 'выведено по' Прав из Ответ) :-</code></p>
      <p><code> Прав : если Условие то Цель,</code></p>
      <p><code>  % Правило, относящееся к цели</code></p>
      <p><code> рассмотреть( Условие, [Цель по Прав | Трасса], Ответ),</code></p>
      <p><code> истинность( Ответ, ПравдаЛожь).</code></p>
      <p><code>рассмотреть( Цель1 и Цель2, Трасса, Ответ) :- !,</code></p>
      <p><code> рассмотреть( Цель1, Трасса, Ответ1),</code></p>
      <p><code> продолжить( Ответ1, Цель1 и Цель2, Трасса, Ответ).</code></p>
      <p><code>рассмотреть( Цель1 или Цель2, Трасса, Ответ) :-</code></p>
      <p><code> рассм_да( Цель1, Трасса, Ответ);</code></p>
      <p><code>  % Положительный ответ на Цель1</code></p>
      <p><code> рассм_да( Цель2, Трасса, Ответ).</code></p>
      <p><code>  % Положительный ответ на Цель2</code></p>
      <p><code>рассмотреть( Цель1 или Цель2, Трасса,</code></p>
      <p><code> Ответ1 и Ответ2) :- !,</code></p>
      <p><code> not рассм_да( Цель1, Трасса, _ ),</code></p>
      <p><code> not рассм_да( Цель2, Трасса, _ ),</code></p>
      <p><code>  % Нет положительного ответа</code></p>
      <p><code> рассмотреть( Цель1, Трасса, Ответ1),</code></p>
      <p><code>  % Ответ1 отрицательный</code></p>
      <p><code> рассмотреть( Цель2, Трасса, Ответ2).</code></p>
      <p><code>  % Ответ2 отрицательный</code></p>
      <p><code>рассмотреть( Цель, Трасса,</code></p>
      <p><code> Цель это Ответ было сказано) :-</code></p>
      <p><code> ответпольз( Цель, Трасса, Ответ). % Ответ дан пользователем</code></p>
      <empty-line/>
      <p><code>рассм_да( Цель, Трасса, Ответ) :-</code></p>
      <p><code> рассмотреть( Цель, Трасса, Ответ),</code></p>
      <p><code> положительный( Ответ).</code></p>
      <empty-line/>
      <p><code>продолжить( Ответ1, Цель1 и Цель2, Трасса, Ответ) :-</code></p>
      <p><code> положительный( Ответ1),</code></p>
      <p><code> рассмотреть( Цель2, Трасса, Ответ2),</code></p>
      <p><code> ( положительный( Ответ2), Ответ = Ответ1 и Ответ2;</code></p>
      <p><code> отрицательный( Ответ2), Ответ = Ответ2).</code></p>
      <p><code>продолжить( Ответ1, Цель1 и Цель2, _, Ответ1) :-</code></p>
      <p><code> отрицательный( Ответ1).</code></p>
      <empty-line/>
      <p><code>истинность( Вопрос это ПравдаЛожь было Найдено,</code></p>
      <p><code> ПравдаЛожь) :- !.</code></p>
      <p><code>истинность( Ответ1 и Ответ2, ПравдаЛожь) :-</code></p>
      <p><code> истинность( Ответ1, правда),</code></p>
      <p><code> истинность( Ответ2, правда), !,</code></p>
      <p><code> ПравдаЛожь = правда;</code></p>
      <p><code> ПравдаЛожь = ложь.</code></p>
      <empty-line/>
      <p><code>положительный( Ответ) :-</code></p>
      <p><code> истинность( Ответ, правда).</code></p>
      <empty-line/>
      <p><code>отрицательный( Ответ) :-</code></p>
      <p><code> истинность( Ответ, ложь).</code></p>
      <p><strong>Рис. 14.10.</strong> Основная процедура оболочки экспертной системы. </p>
     </section>
     <section>
      <title>
       <p>14.5.2. Процедура <code>ответпольз</code></p>
      </title>
      <p>Прежде чем перейти к написанию процедуры <code>ответпольз</code>, давайте рассмотрим одну полезную вспомогательную процедуру</p>
      <p><code>принять( Ответ)</code></p>
      <p>В процессе диалога часто возникает ситуация, когда от пользователя ожидается ответ "да", "нет" или "почему". Процедура <code>принять</code> предназначена для того, чтобы извлечь один из этих ответов, понимая его правильно и в тех случаях, когда пользователь применяет сокращения ('д' или 'н') или делает ошибки. Если ответ пользователя непонятен, то <code>принять</code> просит дать другой вариант ответа.</p>
      <p><code>принять( Ответ) :-</code></p>
      <p><code> read( Ответ1),</code></p>
      <p><code> означает( Ответ1, Значение), !,</code></p>
      <p><code>  % Ответ1 означает что-нибудь?</code></p>
      <p><code> Ответ = Значение;                          % Да</code></p>
      <p><code> nl, write( 'Непонятно, попробуйте еще раз, % Нет</code></p>
      <p><code>             пожалуйста'), nl,</code></p>
      <p><code> принять( Ответ). % Новая попытка</code></p>
      <empty-line/>
      <p><code>означает( да, да).</code></p>
      <p><code>означает( д, да).</code></p>
      <p><code>означает( нет, нет).</code></p>
      <p><code>означает( н, нет).</code></p>
      <p><code>означает( почему, почему).</code></p>
      <p><code>означает( п, почему).</code></p>
      <p>Следует заметить, что процедурой <code>принять</code> нужно пользоваться с осторожностью, так как она содержит взаимодействие с пользователем. Следующий фрагмент программы может служить примером неудачной попытки запрограммировать интерпретацию ответов пользователя:</p>
      <p><code>принять( да), интерп_да( ...);</code></p>
      <p><code>принять( нет), интерп_нет( ...);</code></p>
      <p><code>...</code></p>
      <p>Здесь, если пользователь ответит "нет", то программа попросит его повторить свой ответ. Поэтому более правильный способ такой:</p>
      <p><code>принять( Ответ),</code></p>
      <p><code> ( Ответ = да, интерп_да( ...);</code></p>
      <p><code>   Ответ = нет, интерп_нет( ...);</code></p>
      <p><code>   ... )</code></p>
      <p>Процедура</p>
      <p><code>ответпольз( Цель, Трасса, Ответ)</code></p>
      <p>спрашивает пользователя об истинности утверждения <code>Цель</code>. <code>Ответ</code> — это результат запроса. <code>Трасса</code> используется для объяснения в случае, если пользователь спросит "почему".</p>
      <p>Сначала процедура <code>ответпольз</code> должна проверить, является ли <code>Цель</code> информацией, которую можно запрашивать у пользователя. Это свойство объекта <code>Цель</code> задается отношением</p>
      <p><code>можно_спросить( Цель)</code></p>
      <p>которое в дальнейшем будет усовершенствовано. Если спросить можно, то утверждение <code>Цель</code> выдается пользователю, который, в свою очередь, указывает истинно оно или ложно. Если пользователь спросит "почему", то ему выдается <code>Трасса</code>. Если утверждение <code>Цель</code> истинно, то пользователь укажет также значения содержащихся в нем переменных (если таковые имеются).</p>
      <p>Все вышеизложенное можно запрограммировать (в качестве первой попытки) следующим образом:</p>
      <p><code>остветпольз( Цель, Трасса, Ответ) :-</code></p>
      <p><code> можно_спросить( Цель), % Можно ли спрашивать</code></p>
      <p><code> спросить( Цель, Трасса, Ответ).</code></p>
      <p><code>  % Задать вопрос относительно утверждения Цель</code></p>
      <empty-line/>
      <p><code>спросить( Цель, Трасса, Ответ) :-</code></p>
      <p><code> показать( Цель),</code></p>
      <p><code>  % Показать пользователю вопрос</code></p>
      <p><code> принять(Ответ1),       % Прочесть ответ</code></p>
      <p><code> обработать( Ответ1, Цель, Трасса, Ответ).</code></p>
      <p><code>  % Обработать ответ</code></p>
      <empty-line/>
      <p><code>обработать( почему, Цель, Трасса, Ответ) :-</code></p>
      <p><code>  % Задан вопрос "почему"</code></p>
      <p><code> показать_трассу( Трасса),</code></p>
      <p><code>  % Выдача ответа на вопрос "почему"</code></p>
      <p><code> спросить( Цель, Трасса, Ответ).</code></p>
      <p><code>  % Еще раз спросить</code></p>
      <p><code>обработать( да, Цель, Трасса, Ответ) :-</code></p>
      <p><code>  % Пользователь ответил, что Цель истинна</code></p>
      <p><code> Ответ = правда,</code></p>
      <p><code> запрос_перем( Цель);</code></p>
      <p><code>  % Вопрос о значении переменных</code></p>
      <p><code> спросить( Цель, Трасса, Ответ).</code></p>
      <p><code>  % Потребовать от пользователя новых решений</code></p>
      <p><code>обработать( нет, Цель, Трасса, ложь).</code></p>
      <p><code>  % Пользователь ответил, что Цель ложна</code></p>
      <empty-line/>
      <p><code>показать( Цель) :-</code></p>
      <p><code> nl, write( 'Это правда:'),</code></p>
      <p><code> write( Цель), write( ?), nl.</code></p>
      <p>Обращение к процедуре <code>запрос_перем( Цель)</code> нужно для того, чтобы попросить пользователя указать значение каждой из переменных, содержащихся в утверждении <code>Цель</code>:</p>
      <p><code>запрос_перем( Терм) :-</code></p>
      <p><code> var( Терм), !, % Переменная ?</code></p>
      <p><code> nl, write( Терм), write( '='),</code></p>
      <p><code> read( Терм).   % Считать значение переменной</code></p>
      <p><code>запрос_перем( Терм) :-</code></p>
      <p><code> Терм =.. [Функтор | Аргументы],</code></p>
      <p><code>  % Получить аргументы структуры</code></p>
      <p><code> запрос_арг( Аргументы).</code></p>
      <p><code>  % Запросить значения переменных в аргументах</code></p>
      <empty-line/>
      <p><code>запрос_арг( []).</code></p>
      <p><code>запрос_арг( [Терм | Термы]) :-</code></p>
      <p><code> запрос_перем( Терм),</code></p>
      <p><code> запрос_арг( Термы).</code></p>
      <p>Проведем несколько экспериментов с процедурой <code>ответпольз</code>. Пусть, например, известно, что пользователя можно спрашивать о наличии бинарного отношения <code>ест</code>:</p>
      <p><code>можно_спросить( X ест Y).</code></p>
      <p>(В приведенных ниже диалогах между пролог-системой и пользователем тексты пользователя даются <strong>полужирным шрифтом</strong>, а реплики пролог-системы <emphasis>курсивом</emphasis>).</p>
      <p><code><strong>?- ответпольз( питер ест мясо, [], Ответ).</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: питер ест мясо?</emphasis> % Вопрос пользователю</code></p>
      <p><code><strong>да.</strong>                         % Ответ пользователя</code></p>
      <empty-line/>
      <p><code><emphasis>Ответ = правда</emphasis></code></p>
      <p>Более интересный пример диалога (с использованием переменных) мог бы выглядеть примерно так:</p>
      <p><code><strong>?- ответпольз( Кто ест Что, [], Ответ).</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: _17 ест _18?</emphasis></code></p>
      <p><code>  % Пролог дает переменным свои внутренние имена</code></p>
      <p><code><strong>да.</strong></code></p>
      <p><code><emphasis>_17 =</emphasis> <strong>питер</strong>.</code></p>
      <p><code><emphasis>_18 =</emphasis> <strong>мясо</strong>.</code></p>
      <empty-line/>
      <p><code><emphasis>Ответ = правда.</emphasis></code></p>
      <p><code><emphasis>Кто = питер</emphasis></code></p>
      <p><code><emphasis>Что = мясо;</emphasis> % Возврат для получения других решений</code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: _17 ест _18?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <p><code><emphasis>_17 =</emphasis> <strong>сьюзен.</strong></code></p>
      <p><code><emphasis>_18</emphasis> = <strong>бананы.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Ответ = правда</emphasis></code></p>
      <p><code><emphasis>Кто = сьюзен</emphasis></code></p>
      <p><code><emphasis>Что = бананы;</emphasis></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда : _17 ест _18?</emphasis></code></p>
      <p><code><strong>нет.</strong></code></p>
      <p><code><emphasis>Ответ = ложь</emphasis></code></p>
     </section>
     <section>
      <title>
       <p>14.5.3. Усовершенствование процедуры <code>ответпольз</code></p>
      </title>
      <p>Один из недостатков нашей процедуры <code>ответпольз</code>, который хорошо виден из приведенного выше диалога, — это появление на выходе системы имен, генерируемых пролог-системой, что выглядит довольно неуклюже. Символы, подобные _17, следовало бы заменить на более осмысленные слова.</p>
      <p>Другой, более серьезный дефект этой версии процедуры <code>ответпольз</code> состоит в следующем. Если мы еще раз обратимся к <code>ответпольз</code>, задав ту же самую цель, то пользователю придется повторно вводить все варианты решений. Поэтому, если наша экспертная система придет в процессе рассуждений к рассмотрению той же самой цели второй раз, то, вместо того, чтобы использовать информацию, уже полученную от пользователя, она проведет с пользователем в точности тот же самый скучный диалог.</p>
      <p>Давайте исправим эти два дефекта. Во-первых, улучшение внешнего вида запросов системы будет основано на введении стандартного формата для каждой "запрашиваемой" цели. Для этого в отношение <code>можно_спросить</code> мы добавим второй аргумент, который и будет задавать этот формат, как видно из следующего примера:</p>
      <p><code>можно_спросить(X ест Y, 'Животное' ест 'Что-то').</code></p>
      <p>При передаче запроса пользователю каждая переменная вопроса должна быть заменена на ключевое слово, взятое из формата, например:</p>
      <p><code><strong>?- ответпольз( X ест Y, [], Ответ).</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Это правда: Животное ест Что-то?</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Животное =</emphasis> <strong>питер.</strong></code></p>
      <p><code><emphasis>Что-то =</emphasis> <strong>мясо.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Ответ = правда</emphasis></code></p>
      <p><code><emphasis>X = питер</emphasis></code></p>
      <p><code><emphasis>Y = мясо</emphasis></code></p>
      <p>В улучшенной версии процедуры <code>ответпольз</code>, показанной на рис. 14.11, такое форматирование запросов выполняется процедурой</p>
      <p><code>формат( Цель, ВнешФормат, Вопрос, Перем0, Перем )</code></p>
      <p>Здесь <code>Цель</code> — утверждение, которое нужно форматировать. <code>ВнешФормат</code> определяет внешний формат этого утверждения, задаваемый отношением</p>
      <p><code>можно_спросить( Цель, ВнешФормат)</code></p>
      <p><code>Вопрос</code> — это <code>Цель</code>, отформатированная в соответствии с <code>ВнешФормат</code>. <code>Перем</code> — список переменных, входящих в <code>Цель</code>, вместе с соответствующими ключевыми словами (как указано в <code>ВнешФормат</code>), причем список <code>Перем</code> получается из списка <code>Перем0</code> добавлением новых переменных. Например:</p>
      <p><code>?- формат( X передает документы Y,</code></p>
      <p><code> 'Кто' передает 'Что' 'Кому',</code></p>
      <p><code> Вопрос, [], Перем).</code></p>
      <empty-line/>
      <p><code>Вопрос = 'Кто' передает документы 'Кому',</code></p>
      <p><code> Перем = [ X/'Кто', Y/'Кому'].</code></p>
      <p>Второе усовершенствование, состоящее в устранении повторных вопросов к пользователю, будет более трудным. Во-первых, все ответы пользователя следует запоминать, с тем чтобы их можно было отыскать в памяти в более поздний момент времени. Для этого достаточно сделать ответы пользователя элементами некоторого отношения и применить <code>assert</code>, например</p>
      <p><code>assert( сказано( мери передает документы друзьям, правда) ).</code></p>
      <p>В ситуации, когда имеется несколько решений, предложенных пользователем для одной и той же цели, в память относительно нее будет записано несколько фактов. Здесь возникает одно осложнение. Допустим, что в нескольких местах программы встречаются различные варианты некоторой цели (отличающиеся именованием переменных). Например:</p>
      <p><code>( X имеет Y) и   % Первый вариант - Цель1</code></p>
      <p><code>...</code></p>
      <empty-line/>
      <p><code>( X1 имеет Y1) и % Второй вариант - Цель2</code></p>
      <p><code>...</code></p>
      <p>Допустим также, что пользователя просят (через механизм возвратов) предложить несколько решений для <code>Цель1</code>. Затем процесс рассуждений продвигается вплоть до <code>Цель2</code>. Так как у нас уже есть несколько решений для <code>Цель1</code>, мы захотим, чтобы система автоматически применила их и к <code>Цель2</code> (поскольку очевидно, что они удовлетворяют <code>Цель2</code>). Теперь предположим, что система пытается применить эти решения к <code>Цель2</code>, но ни одно из них не удовлетворяет некоторой другой цели, расположенной ниже. Система делает возврат к <code>Цель2</code> и просит пользователя предложить новые решения. Если пользователь введет еще несколько решений, то их также придется запомнить. И если система в дальнейшем сделает возврат к <code>Цель1</code>, то эти новые решения надо будет применить к <code>Цель1</code>.</p>
      <p>Для того, чтобы правильным образом использовать информацию, вводимую пользователем по запросам из разных точек программы, мы будем снабжать каждую такую информацию специальным индексом. Таким образом, факты, запоминаемые системой, будут иметь вид</p>
      <p><code>сказано( Цель, Истинность, Индекс)</code></p>
      <p>где <code>Индекс</code> — это значение счетчика, ответов пользователя. Процедура</p>
      <p><code>ответпольз( Цель, Трасса, Ответ)</code></p>
      <p>теперь должна будет отслеживать число решений, уже порожденных механизмом возвратов к моменту обращения к этой процедуре. Это можно сделать при помощи другого варианта процедуры <code>ответпольз</code> с четырьмя аргументами:</p>
      <p><code>ответпольз( Цель, Трасса, Ответ, N)</code></p>
      <p>где N — некоторое целое число. Такое обращение к <code>ответпольз</code> должно порождать решения для <code>Цель</code> с индексами, начиная с N и далее. Обращение</p>
      <p><code>ответпольз( Цель, Трасса, Ответ)</code></p>
      <p>соответствует получению <emphasis>всех</emphasis> решений, индексируемых, начиная с 1, поэтому мы имеем следующее соотношение:</p>
      <p><code>ответпольз( Цель, Трасса, Ответ) :-</code></p>
      <p><code> ответпольз( Цель, Трасса, Ответ, 1).</code></p>
      <p>Принцип работы процедуры</p>
      <p><code>ответпольз( Цель, Трасса, Ответ, N)</code></p>
      <p>таков: сначала получить решения для <code>Цель</code>, отыскивая в памяти все уже известные решения с индексами, начиная с N и далее. Когда все старые решения исчерпаются, начать задавать вопросы пользователю относительно утверждения <code>Цель</code>, записывая полученные таким образом новые решения в память при помощи <code>assert</code> и индексируя их должным образом при помощи целых чисел. Когда пользователь сообщит, что больше нет решений, записать в память факт</p>
      <p><code>конец_ответов( Цель)</code></p>
      <p>Если пользователь с самого начала скажет, что решений нет вообще, то записать факт</p>
      <p><code>сказано( Цель, ложь, Индекс)</code></p>
      <p>Находя в памяти те или иные решения, процедура <code>ответпольз</code> должна правильно интерпретировать подобную информацию.</p>
      <p>Однако существует еще одна трудность. Пользователь может, оставляя некоторые переменные неконкретизированными, указывать общие решения. Если найдено положительное решение, более общее, чем <code>Цель</code>, или столь же общее, как <code>Цель</code>, то нет смысла продолжать задавать вопросы об утверждении <code>Цель</code>, поскольку мы уже имеем более общее решение. Аналогичным образом следует поступить, если обнаружен факт</p>
      <p><code>сказано( Цель, ложь, _ )</code></p>
      <p>Программа <code>ответпольз</code>, показанная на рис. 14.11, учитывает все вышеприведенные соображения. В нее введен новый аргумент <code>Копия</code> (копия утверждения <code>Цель</code>), который используется в нескольких случаях сопоставлений вместо <code>Цель</code>, с тем чтобы оставить в неприкосновенности переменные утверждения <code>Цель</code>. Эта программа использует также два вспомогательных отношения. Одно из них</p>
      <p><code>конкретный( Терм)</code></p>
      <p>истинно, если <code>Терм</code> не содержит переменных. Другое</p>
      <p><code>конкретизация( Терм, Терм1)</code></p>
      <p>означает, что <code>Терм1</code> есть некоторая конкретизация (частный случай) терма <code>Терм</code>, т.е. <code>Терм</code> — это утверждение не менее общее, чем <code>Терм1</code>. Например:</p>
      <p><code>конкретизация( X передает информацию Y,</code></p>
      <p><code> мэри передает информацию Z)</code></p>
      <p>Обе процедуры основаны на еще одной процедуре:</p>
      <p><code>нумпер( Терм, N, М)</code></p>
      <p>Эта процедура "нумерует" переменные, содержащиеся в <code>Терм</code>, заменяя каждую из них на некоторый специальный новый терм таким образом, чтобы эти "нумерующие" термы соответствовали числам от N до M–1, Например, пусть эти термы имеют вид</p>
      <p><code>пер/0, пер/1, пер/2, ...</code></p>
      <p>тогда в результате обращения к системе</p>
      <p><code>?- Терм = f( X, t( a,Y, X) ), нумпер( Терм, 5, М).</code></p>
      <p>мы получим</p>
      <p><code>Терм = f( пер/5, t( а, пер/6, пер/5) )</code></p>
      <p><code>М = 7</code></p>
      <empty-line/>
      <p><code>% Процедура</code></p>
      <p><code>%</code></p>
      <p><code>% ответпольз( Цель, Трасса, Ответ)</code></p>
      <p><code>%</code></p>
      <p><code>% порождает, используя механизм возвратов, все решения</code></p>
      <p><code>% для целевого утверждения Цель, которые указал пользователь.</code></p>
      <p><code>% Трасса - это цепочка целей-предков и правил,</code></p>
      <p><code>% используемая для объяснения типа "почему".</code></p>
      <p><code>ответпольз( Цель, Трасса, Ответ) :-</code></p>
      <p><code> можно_спросить( Цель, _ ), % Можно спросить?</code></p>
      <p><code> копия( Цель, Копия),       % Переименование переменных</code></p>
      <p><code> ответпольз( Цель, Копия, Трасса, Ответ, 1).</code></p>
      <empty-line/>
      <p><code>% Не спрашивать второй раз относительно конкретизированной цели</code></p>
      <p><code>ответпольз( Цель, _, _, _, N) :-</code></p>
      <p><code> N &gt; 1,                     % Повторный вопрос?</code></p>
      <p><code> конкретный( Цель),  !,     % Больше не спрашивать</code></p>
      <p><code> fail.</code></p>
      <empty-line/>
      <p><code>% Известен ли ответ для всех конкретизации утверждения Цель?</code></p>
      <p><code>ответпольз( Цель, Копия, _, Ответ, _ ) :-</code></p>
      <p><code> сказано( Копия, Ответ, _ ),</code></p>
      <p><code> конкретизация( Копия, Цель), !. % Ответ известен</code></p>
      <empty-line/>
      <p><code>% Найти все известные решения для Цель с индексами, начиная с N</code></p>
      <p><code>ответпольз( Цель, _, _, правда, N) :-</code></p>
      <p><code> сказано( Цель, правда, М),</code></p>
      <p><code> М &gt;= N.</code></p>
      <empty-line/>
      <p><code>% Все уже сказано об утверждении Цель?</code></p>
      <p><code>ответпольз( Цель, Копия, _, Ответ, _) :-</code></p>
      <p><code> конец_ответов( Копия),</code></p>
      <p><code> конкретизация( Копия, Цель), !, % Уже все сказано</code></p>
      <p><code> fail.</code></p>
      <empty-line/>
      <p><code>% Попросить пользователя дать (еще) решения</code></p>
      <p><code>ответпольз( Цель, _, Трасса, Ответ, N) :-</code></p>
      <p><code> спросить_польз( Цель, Трасса, Ответ, N).</code></p>
      <empty-line/>
      <p><code>спросить_польз( Цель, Трасса, Ответ, N) :-</code></p>
      <p><code> можно спросить( Цель, ВнешФормат),</code></p>
      <p><code> формат( Цель, ВнешФормат, Вопрос, [], Перем),</code></p>
      <p><code>  % Получить формат вопроса</code></p>
      <p><code> спросить( Цель, Вопрос, Перем, Трасса, Ответ, N).</code></p>
      <empty-line/>
      <p><code>спросить( Цель, Вопрос, Перем, Трасса, Ответ, N) :-</code></p>
      <p><code> nl,</code></p>
      <p><code> ( Перем = [], !,                % Сформулировать вопрос</code></p>
      <p><code> write( 'Это правда: ');</code></p>
      <p><code> write( 'Есть (еще) решения для :' )),</code></p>
      <p><code> write( Вопрос), write( '?'),</code></p>
      <p><code> принять( Ответ1), !,            % Ответ1 - да/нет/почему</code></p>
      <p><code> обработать( Ответ1, Цель, Вопрос, Перем,</code></p>
      <p><code>             Трасса, Ответ, N).</code></p>
      <empty-line/>
      <p><code>обработать( почему, Цель, Вопрос, Перем,</code></p>
      <p><code> Трасса, Ответ, N):-</code></p>
      <p><code> выд_трассу( Трасса),</code></p>
      <p><code> спросить( Цель, Вопрос, Перем, Трасса, Ответ, N).</code></p>
      <p><code>обработать( да, Цель,_, Перем, Трасса, правда, N) :-</code></p>
      <p><code> след_индекс( Инд),</code></p>
      <p><code>  % Получить новый индекс для "сказано"</code></p>
      <p><code> Инд1 is Инд + 1,</code></p>
      <p><code> ( запрос_перем( Перем),</code></p>
      <p><code>   assertz( сказано( Цель, правда, Инд) );</code></p>
      <p><code>    % Запись решения</code></p>
      <p><code> копия( Цель, Копия),            % Копирование цели</code></p>
      <p><code> ответпольз( Цель, Копия, Трасса, Ответ, Инд1) ).</code></p>
      <p><code>  % Есть еще решения?</code></p>
      <p><code>обработать( нет, Цель, _, _, _, ложь, N) :-</code></p>
      <p><code> копия( Цель, Копия),</code></p>
      <p><code> сказано( Копия, правда, _), !,</code></p>
      <p><code>  % 'нет' означает, больше нет решений</code></p>
      <p><code> assertz( конец_ответов( Цель) ),</code></p>
      <p><code>  % Отметить конец ответов</code></p>
      <p><code> fail;</code></p>
      <p><code> след_индекс( Инд),</code></p>
      <p><code>  % Следующий свободный индекс для "сказано"</code></p>
      <p><code> assertz( сказано( Цель, ложь, Инд) ).</code></p>
      <p><code>  % 'нет' означает нет ни одного решения</code></p>
      <empty-line/>
      <p><code>формат( Пер, Имя, Имя, Перем, [Пер/Имя | Перем]) :-</code></p>
      <p><code> var( Пер), !.</code></p>
      <p><code>формат( Атом, Имя, Атом, Перем, Перем) :-</code></p>
      <p><code> atomic( Атом), !,</code></p>
      <p><code> atomic( Имя).</code></p>
      <p><code>формат( Цель, Форм, Вопрос, Перем0, Перем) :-</code></p>
      <p><code> Цель =.. [Функтор | Apг1],</code></p>
      <p><code> Форм =.. [Функтор | Форм1],</code></p>
      <p><code> формвсе( Apг1, Форм1, Арг2, Перем0, Перем),</code></p>
      <p><code> Вопрос =.. [Функтор | Арг2].</code></p>
      <empty-line/>
      <p><code>формвсе( [], [], [], Перем, Перем).</code></p>
      <p><code>формвсе( [X | СпХ], [Ф | СпФ], [В | СпВ], Перем0, Перем) :-</code></p>
      <p><code> формвсе( СпХ, СпФ, СпВ, Перем0, Перем1),</code></p>
      <p><code> формат( X, Ф, В, Перем1, Перем).</code></p>
      <empty-line/>
      <p><code>запрос_перем( []).</code></p>
      <p><code>запрос_перем( [Переменная/Имя | Переменные]) :-</code></p>
      <p><code> nl, write( Имя), write( '='),</code></p>
      <p><code> read( Переменная),</code></p>
      <p><code> запрос_перем( Переменные).</code></p>
      <empty-line/>
      <p><code>выд_трассу( []) :-</code></p>
      <p><code> nl, write( 'Это был ваш вопрос'), nl.</code></p>
      <p><code>выд_трассу( [Цель по Прав | Трасса] ) :-</code></p>
      <p><code> nl, write( 'Чтобы проверить по' ),</code></p>
      <p><code> write( Прав), write( ', что'),</code></p>
      <p><code> write( Цель),</code></p>
      <p><code> выд_трассу( Трасса).</code></p>
      <empty-line/>
      <p><code>конкретный( Терм) :-</code></p>
      <p><code> нумпер( Терм, 0, 0).            % Нет переменных в Терм'е</code></p>
      <empty-line/>
      <p><code>% конкретизация( Т1, Т2) означает, что Т2 - конкретизация Т1,</code></p>
      <p><code>% т.е. терм Т1 - более общий, чем Т2, или той же степени</code></p>
      <p><code>% общности, что и Т2</code></p>
      <p><code>конкретизация( Терм, Терм1) :-</code></p>
      <p><code>  % Терм1 - частный случай Терм'а</code></p>
      <p><code> копия( Терм1, Терм2),</code></p>
      <p><code>  % Копия Терм1 с новыми переменными</code></p>
      <p><code> нумпер( Терм2, 0, _), !,</code></p>
      <p><code> Терм = Терм2.       % Успех, если Терм1 - частный случай Терм2</code></p>
      <empty-line/>
      <p><code>копия( Терм, НовТерм) :-</code></p>
      <p><code>  % Копия Терм' а с новыми переменными</code></p>
      <p><code> asserta( copy( Терм) ),</code></p>
      <p><code> retract( сору( НовТерм) ), !.</code></p>
      <empty-line/>
      <p><code>посл_индекс( 0).     % Начальный индекс для "сказано"</code></p>
      <empty-line/>
      <p><code>след_индекс( Инд) :- % Следующий индекс для "сказано"</code></p>
      <p><code> retract( посл_индекс( ПослИнд) ), !,</code></p>
      <p><code> Инд is ПослИнд + 1,</code></p>
      <p><code> assert( посл_индекс( Инд) ).</code></p>
      <p><strong>Рис. 14.11.</strong> Оболочка экспертной системы: Вопросы к пользователю и ответы на вопросы "почему".</p>
      <empty-line/>
      <p>Отношение, подобное <code>нумпер</code>, часто входит в состав пролог-системы в качестве встроенной процедуры. Если это не так, то его можно реализовать программно следующим способом:</p>
      <p><code>нумпер( Терм, N, Nплюс1) :- </code></p>
      <p><code> var( Терм), !, % Переменная? </code></p>
      <p><code> Терм = пер/N, </code></p>
      <p><code> Nплюс1 is N + 1. </code></p>
      <p><code>нумпер( Терм, N, М) :-</code></p>
      <p><code> Терм =.. [Функтор | Аргументы], % Структура или атом</code></p>
      <p><code> нумарг( Аргументы, N, M).</code></p>
      <p><code>  % Пронумеровать переменные в аргументах</code></p>
      <empty-line/>
      <p><code>нумарг( [], N, N) :- !.</code></p>
      <p><code>нумарг( [X | Спис], N, M) :-</code></p>
      <p><code> нумпер( X, N, N1),</code></p>
      <p><code> нумарг( Спис, N1, М).</code></p>
     </section>
     <section>
      <title>
       <p>14.5.4. Процедура  выдать</p>
      </title>
      <p>Процедура</p>
      <p><code>выдать( Ответ)</code></p>
      <p>приведенная на рис. 14.12, показывает пользователю окончательный результат консультационного сеанса и дает объяснения типа "как". <code>Ответ</code> включает в себя как ответ на вопрос пользователя, так и дерево вывода, демонстрирующее <emphasis>как</emphasis> система пришла к такому заключению. Сначала процедура <code>выдать</code> представляет пользователю свое заключение. Затем, если пользователь пожелает узнать, <emphasis>как</emphasis> это заключение достигнуто, то печатается дерево вывода в некоторой удобной для восприятия форме - это и есть объяснение типа "как". Форма объяснения показана в примере разд. 14.4.3.</p>
     </section>
     <section>
      <title>
       <p>14.5.5. Драйвер верхнего уровня</p>
      </title>
      <p>И наконец, для того, чтобы иметь удобный доступ к оболочке из интерпретатора Пролога, нам необходима процедура, выполняющая функцию "драйвера". На рис. 14.13 показано, как могла бы выглядеть предназначенная для этой цели процедура <code>эксперт</code>. Драйвер <code>эксперт</code> производит запуск трех основных модулей оболочки (рис. 14.10–14.12) и координирует их работу. Например:</p>
      <p><code><strong>?- эксперт.</strong></code></p>
      <p><code><emphasis>Пожалуйста, спрашивайте:</emphasis>       % Приглашение пользователю</code></p>
      <p><code><strong>X это животное и голиаф это X.</strong> % Вопрос пользователя</code></p>
      <p><code><emphasis>Это правда:  голиаф имеет шерсть?</emphasis></code></p>
      <p><code><strong>...</strong></code></p>
      <empty-line/>
      <p><code>% Выдача заключения консультационного сеанса и</code></p>
      <p><code>% объяснения типа "как"</code></p>
      <p><code>выдать( Ответ) :-</code></p>
      <p><code> nl, заключение( Ответ),</code></p>
      <p><code> nl, write( 'Хотите узнать, как?'),</code></p>
      <p><code> принять( Ответ1),</code></p>
      <p><code> ( Ответ1 = да, !, отобр( Ответ);</code></p>
      <p><code>   true).                        % Показ решающего дерева</code></p>
      <empty-line/>
      <p><code>заключение( Ответ1 и Ответ2) :- !,</code></p>
      <p><code> заключение( Ответ1), write( 'и'),</code></p>
      <p><code> заключение( Ответ2).</code></p>
      <p><code>заключение( Заключение было Найдено) :-</code></p>
      <p><code> write( Заключение).</code></p>
      <empty-line/>
      <p><code>% "отобр" отображает полное решающее дерево</code></p>
      <p><code>отобр( Решение) :-</code></p>
      <p><code> nl, отобр( Решение, 0), !.      % Отступ 0</code></p>
      <p><code>отобр( Ответ1 и Ответ2, H) :- !, % Отступ H</code></p>
      <p><code> отобр( Ответ1, H),</code></p>
      <p><code> tab( H), write( 'и'), nl,</code></p>
      <p><code> отобр( Ответ2, H).</code></p>
      <p><code>отобр( Ответ был Найден, H) :-   % Отступ H</code></p>
      <p><code> tab( H), печответ( Ответ),      % Показ заключения</code></p>
      <p><code> nl, tab( H),</code></p>
      <p><code> write( 'было'),</code></p>
      <p><code> отобр1( Найден, H).             % Показ доказательства</code></p>
      <empty-line/>
      <p><code>отобр1( Выведено из Ответ, H) :- !,</code></p>
      <p><code> write( Выведено), write( 'из'), % Показ имени правила</code></p>
      <p><code> nl, H1 is H + 4,</code></p>
      <p><code> отобр( Ответ, H1).              % Показ "предшественника"</code></p>
      <p><code>отобр1( Найдено, _ ) :-</code></p>
      <p><code>  % Найдено = 'сказано' или 'найдено как факт'</code></p>
      <p><code> write( Найдено), nl.</code></p>
      <empty-line/>
      <p><code>печответ( Цель это правда) :- !,</code></p>
      <p><code> write( Цель).      % На выходе 'это правда' опускается</code></p>
      <p><code>печответ( Ответ) :- % Отрицательный ответ</code></p>
      <p><code> write( Ответ).</code></p>
      <p><strong>Рис. 14.12.</strong> Оболочка экспертной системы: Отображение окончательного результата и объяснение типа "как".</p>
     </section>
     <section>
      <title>
       <p>14.5.6. Одно замечание по поводу программы-оболочки</p>
      </title>
      <p>В некоторых местах нашей программы-оболочки обнаруживается недостаток той "декларативной ясности", которая так характерна для программ, написанных на Прологе. Причина состоит в том, что нам пришлось предусмотреть в этой программе довольно жесткое управление процессом функционирования оболочки. Ведь, согласно нашему замыслу, экспертная система должна была не только находить ответы на вопросы, но и делать это некоторым разумным с точки зрения пользователя способом. В связи с этим нам пришлось реализовать вполне определенное <emphasis>поведение</emphasis> системы в процессе решения задач, а не просто некоторое отношение ввода-вывода. В результате получилась программа более процедурного характера, чем обычно. Все это может послужить примером ситуации, когда, не имея возможности рассчитывать на собственные процедурные механизмы Пролога, мы вынуждены взять на себя детальное описание процедурного поведения системы.</p>
     </section>
     <section>
      <title>
       <p>14.5.7. Цели с отрицанием</p>
      </title>
      <p>Использование знака отрицания в левых частях правил, а следовательно, и в вопросах, обрабатываемых процедурой <code>рассмотреть</code>, представляется естественным и его следует разрешить. В качестве первой попытки можно предложить следующий способ работы с отрицанием целей:</p>
      <p><code>рассмотреть( не Цель, Трасса, Ответ) :- !,</code></p>
      <p><code> рассмотреть( Цель, Трасса, Ответ1),</code></p>
      <p><code> обратить( Ответ1, Ответ).</code></p>
      <p><code>  % Получить обратное истинностное значение</code></p>
      <empty-line/>
      <p><code>обратить( Цель это правда было Найдено,</code></p>
      <p><code> ( не Цель) это ложь было Найдено).</code></p>
      <p><code>обратить( Цель это ложь было Найдено,</code></p>
      <p><code> ( не Цель) это правда было Найдено).</code></p>
      <empty-line/>
      <p><code>% Процедура-драйвер верхнего уровня</code></p>
      <p><code>эксперт :-</code></p>
      <p><code> принять_вопрос( Вопрос),</code></p>
      <p><code>  % Ввести вопрос пользователя</code></p>
      <p><code> ( ответ_да( Вопрос);</code></p>
      <p><code>  % Попытка найти положительный ответ</code></p>
      <p><code> ответ_нет( Вопрос) ).</code></p>
      <p><code>  % Если нет положительного ответа, то найти отрицательный</code></p>
      <empty-line/>
      <p><code>ответ_да( Вопрос) :-</code></p>
      <p><code>  % Искать положительный ответ на Вопрос</code></p>
      <p><code> статус( отрицательный),</code></p>
      <p><code>  % Пока еще нет положительного ответа</code></p>
      <p><code> рассмотреть( Вопрос, [], Ответ), % Трасса пуста</code></p>
      <p><code> положительный( Ответ), % Искать положительный ответ</code></p>
      <p><code> статус( положительный),</code></p>
      <p><code>  % Найден положительный ответ</code></p>
      <p><code> выдать( Ответ), nl,</code></p>
      <p><code> write( 'Нужны еще решения?' ),</code></p>
      <p><code> принять( Ответ1), % Прочесть ответ пользователя</code></p>
      <p><code> Ответ1 = нет.</code></p>
      <p><code>  % В противном случае возврат к "рассмотреть"</code></p>
      <empty-line/>
      <p><code>ответ_нет( Вопрос):-</code></p>
      <p><code>  % Искать отрицательный ответ на Вопрос</code></p>
      <p><code> retract( пока_нет_положительного_решения), !,</code></p>
      <p><code>  % Не было положительного решения?</code></p>
      <p><code> рассмотреть( Вопрос, [], Ответ),</code></p>
      <p><code> отрицательный( Ответ),</code></p>
      <p><code> выдать( Ответ), nl,</code></p>
      <p><code> write( 'Нужны еще решения?' ),</code></p>
      <p><code> принять( Ответ1),</code></p>
      <p><code> Ответ1 = нет.</code></p>
      <p><code>  % В противном случае - возврат к "рассмотреть"</code></p>
      <empty-line/>
      <p><code>статус( отрицательный) :-</code></p>
      <p><code> assert( пока_нет_положительного_решения).</code></p>
      <p><code>статус( положительный) :-</code></p>
      <p><code> retract( пока_нет_положительного_решения), !; true.</code></p>
      <empty-line/>
      <p><code>принять_вопрос( Вопрос) :-</code></p>
      <p><code> nl, write( 'Пожалуйста, спрашивайте:'), nl,</code></p>
      <p><code> read( Вопрос).</code></p>
      <p><strong>Рис. 14.13.</strong> Оболочка экспертной системы: драйвер. Обращение к оболочке из Пролога при помощи процедуры <code>эксперт</code>.</p>
      <empty-line/>
      <p>Если Цель конкретизирована, то все в порядке, если же нет, то возникают трудности. Рассмотрим, например, такой диалог:</p>
      <p><code><strong>?- эксперт.</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Пожалуйста, спрашивайте:</emphasis></code></p>
      <p><code><strong>не ( X ест мясо).</strong></code></p>
      <empty-line/>
      <p><code><emphasis>Есть (еще) решения для : Животное</emphasis></code></p>
      <p><code><strong>да.</strong></code></p>
      <p><code><emphasis>Животное =</emphasis> <strong>тигр</strong>.</code></p>
      <p>В этот момент система даст ответ:</p>
      <p><code><emphasis>не ( тигр ест мясо) это ложь</emphasis></code></p>
      <p>Такой ответ нас не может удовлетворить. Источник затруднения следует искать в том, какой смысл мы вкладываем в вопросы типа</p>
      <p><code>не ( X ест мясо)</code></p>
      <p>В действительности мы хотим спросить: "Существует ли такой X, что X не ест мяса?" Однако процедура <code>рассмотреть</code> (так как мы ее определили) проинтерпретирует этот вопрос следующим образом:</p>
      <p>(1) Существует ли такой X, что X ест мясо?</p>
      <p>(2) Да, тигр ест мясо.</p>
      <p>Итак,</p>
      <p>(3) не (тигр ест мясо) это ложь.</p>
      <p>Короче говоря, интерпретация такова — "Правда ли, что никакой X не ест мясо?" Положительный ответ мы получим, только если <emphasis>никто</emphasis> не ест мяса. Можно также сказать, что процедура <code>рассмотреть</code> отвечает на вопрос так, как будто X находится под знаком квантора <emphasis>всеобщности</emphasis>:</p>
      <p> для <emphasis>всех</emphasis> X: не (X ест мясо)?</p>
      <p>а не квантора существования, в чем и состояло наше намерение:</p>
      <p> для <emphasis>некоторого</emphasis> X: не (X ест мясо)?</p>
      <p>Если рассматриваемый вопрос конкретизирован, то проблемы исчезают. В противном случае правильный способ работы с отрицаниями становится более сложным. Например, вот некоторые из возможных правил:</p>
      <p>Для того, чтобы рассмотреть <emphasis>(не Цель)</emphasis>, рассмотрите <emphasis>Цель</emphasis>, а затем:</p>
      <p>• если <emphasis>Цель</emphasis> это ложь, то <emphasis>(не Цель)</emphasis> это правда;</p>
      <p>• если <emphasis>Цель'</emphasis> — это некоторое решение для <emphasis>Цель</emphasis>, и <emphasis>Цель'</emphasis> — утверждение той же степени общности, что и <emphasis>Цель</emphasis>, то <emphasis>(не Цель)</emphasis> это ложь;</p>
      <p>• если <emphasis>Цель'</emphasis> — это некоторое решение для <emphasis>Цель</emphasis>, и <emphasis>Цель'</emphasis> — более конкретное утверждение, чем <emphasis>Цель</emphasis>, то об утверждении <emphasis>(не Цель)</emphasis> нельзя сказать ничего определенного.</p>
      <p>Можно избежать всех этих осложнений, если потребовать, чтобы отрицания стояли только перед конкретизированными целями. Если правила базы знаний формулировать должным образом, то часто удается удовлетворить этому условию. Нам это удалось в "правиле поломки" (рис. 14.7):</p>
      <p><code>правило_поломки:</code></p>
      <p><code> если</code></p>
      <p><code>  вкл( Прибор) и</code></p>
      <p><code>  прибор( Прибор) и % Конкретизация</code></p>
      <p><code>  не работает( Прибор) и</code></p>
      <p><code>  соед( Прибор, Предохр) и</code></p>
      <p><code>  доказано( цел( Предохр) )</code></p>
      <p><code> то</code></p>
      <p><code>  доказано( неиспр( Прибор) ).</code></p>
      <p>Здесь условие</p>
      <p><code>прибор( Прибор)</code></p>
      <p>"защищает" следующее за ним условие</p>
      <p><code>не работает( Прибор)</code></p>
      <p>от неконкретизированной переменной.</p>
      <subtitle>Упражнение</subtitle>
      <p><strong>14.3.</strong> База знаний может, в принципе, содержать циклы. Например:</p>
      <p><code>прав1: если бутылка_пуста то джон_пьян.</code></p>
      <p><code>прав2: если джон_пьян то бутылка_пуста.</code></p>
      <p>Работая с подобной базой знаний, наша процедура <code>рассмотреть</code> может зациклиться на обработке одних и тех же целей. Внесите в процедуру <code>рассмотреть</code> изменения, предотвращающие зацикливание. Используйте для этого объект <code>Трасса</code>. Однако соблюдайте осторожность: если текущая цель <emphasis>сопоставима</emphasis> с одной из предыдущих целей, то такую ситуацию следует рассматривать как цикл только в том случае, когда текущая цель имеет большую, степень общности, чем предыдущая.</p>
     </section>
    </section>
    <section>
     <title>
      <p>14.6. Работа с неопределенностью </p>
     </title>
     <section>
      <title>
       <p>14.6.1. Степень достоверности</p>
      </title>
      <p>Наша оболочка экспертной системы, описанная в предыдущем разделе, может работать только с такими вопросами (утверждениями), которые либо истинны, либо ложны. Предметные области, в которых на любой вопрос можно ответить "правда" или "ложь", называются <emphasis>категорическими</emphasis>. Наши правила базы знания (также, как и данные) были категорическими, это были "категорические импликации". Однако многие области экспертных знаний не являются категорическими. Как правило, в заключениях эксперта много догадок (впрочем, высказанных с большой уверенностью), которые обычно верны, но могут быть и исключения. Как данные, относящиеся к конкретной задаче, так и импликации, содержащиеся в правилах, могут быть не вполне определенными. Неопределенность можно промоделировать, приписывая утверждениям некоторые характеристики, отличные от "<emphasis>истина</emphasis>" и "<emphasis>ложь</emphasis>". Характеристики могут иметь свое внешнее выражение в форме дескрипторов, таких, как, например, <emphasis>верно</emphasis>, <emphasis>весьма вероятно</emphasis>, <emphasis>вероятно</emphasis>, <emphasis>маловероятно</emphasis>, <emphasis>невозможно</emphasis>. Другой способ: степень уверенности может выражаться в форме действительного числа, заключенного в некотором интервале, например между 0 и 1 или между -5 и +5. Такую числовую характеристику называют по-разному — "коэффициент определенности", "степень доверия" или "субъективная уверенность". Более естественным было бы использовать вероятности (в математическом смысле слова), но попытки применить их на практике приводят к трудностям. Происходит это по следующим причинам:</p>
      <p>• Экспертам, по-видимому, неудобно мыслить в терминах вероятностей. Их оценки правдоподобия не вполне соответствуют математическому определению вероятностей.</p>
      <p>• Работа с вероятностями, корректная с точки зрения математики, потребовала бы или какой-нибудь недоступной информации, или каких-либо упрощающих допущений, не вполне оправданных с точки зрения практического приложения.</p>
      <p>Поэтому, даже если выбранная мера правдоподобия лежит в интервале 0 и 1, более правильным будет называть ее из осторожности "субъективной уверенностью", подчеркивая этим, что имеется в виду оценка, данная экспертом. Оценки эксперта не удовлетворяют всем требованиям теории вероятностей. Кроме того, вычисления над такими оценками могут отличаться от исчисления вероятностей. Но, несмотря на это, они могут служить вполне адекватной моделью того, как человек оценивает достоверность своих выводов.</p>
      <p>Для работы в условиях неопределенности было придумано множество различных механизмов. Мы будем рассматривать здесь механизм, используемый в системах Prospector и AL/X для минералогической разведки и локализации неисправностей соответственно. Следует заметить, что модель, применяемая в системе Prospector, несовершенна как с теоретической, так и с практической точек зрения. Однако она использовалась на практике, она проста и может служить хорошей иллюстрацией при изложении основных принципов, а потому вполне подойдет нам, по крайней мере для первого знакомства с этой областью. С другой стороны, известно, что даже в значительно более сложных моделях не обходится без трудностей. </p>
     </section>
     <section>
      <title>
       <p>14.6.2. Модель Prospector'а</p>
      </title>
      <p>Достоверность событий моделируется с помощью действительных чисел, заключенных в интервале между 0 и 1. Для простоты изложения мы будем называть их "вероятностями", хотя более точный термин "субъективная уверенность". Отношения между событиями можно представить графически в форме "сети вывода". На рис. 14.14 показан пример сети вывода. События изображаются прямоугольниками, а отношения между ними — стрелками. Овалами изображены комбинации событий (И, ИЛИ, НЕ).</p>
      <p>Мы будем считать, что отношения между событиями (стрелки) являются своего рода "мягкими импликациями". Пусть имеются два события <emphasis>E</emphasis> и <emphasis>H</emphasis>, и пусть информация о том, что имело место событие <emphasis>E</emphasis>, оказывает влияние на нашу уверенность в том, что произошло событие <emphasis>H</emphasis>. Если это влияние является "категорической импликацией", то можно просто написать</p>
      <p>если <emphasis>E</emphasis> то <emphasis>H</emphasis></p>
      <p>В случае же "мягкой импликации" это отношение может быть менее определенным, так что ему можно приписать некоторую "силу", с которой оно действует:</p>
      <p>если <emphasis>E</emphasis> то <emphasis>H</emphasis> с силой S</p>
      <p>Та сила, с которой достоверность <emphasis>E</emphasis> влияет на уверенность в <emphasis>H</emphasis>, моделируется в системе Prospector при помощи двух параметров:</p>
      <p><emphasis>N</emphasis> = "коэффициент необходимости"</p>
      <p><emphasis>S</emphasis>  = "коэффициент достаточности"</p>
      <image l:href="#_104.png"/>
      <p><strong>Рис. 14.14.</strong> Сеть вывода системы AL/X (заимствовано из Reiter (1980)). Числа, приписанные прямоугольникам, — априорные вероятности событий; числами на стрелках задается "сила" отношений между событиями.</p>
      <p>В сети вывода это изображается так:</p>
      <p><emphasis>E ------------&gt; H</emphasis></p>
      <p><emphasis>       (N, S)</emphasis></p>
      <p>Два события, участвующие в отношении, часто называют "фактом" и "гипотезой" соответственно. Допустим, что мы проверяем гипотезу <emphasis>H</emphasis>. Тогда мы будем искать такой факт <emphasis>E</emphasis>, который мог бы подтвердить либо опровергнуть эту гипотезу. <emphasis>S</emphasis> говорит нам, в какой степени <emphasis>достаточно</emphasis> факта <emphasis>E</emphasis> для подтверждения гипотезы <emphasis>H</emphasis>; <emphasis>N</emphasis> — насколько <emphasis>необходим</emphasis> факт <emphasis>E</emphasis> для подтверждения гипотезы <emphasis>H</emphasis>. Если факт <emphasis>E</emphasis> имел место, то чем больше <emphasis>S</emphasis>, тем больше уверенности в <emphasis>H</emphasis>. С другой стороны, если не верно, что имел место факт <emphasis>E</emphasis>, то чем больше <emphasis>N</emphasis>, тем менее вероятно, что гипотеза <emphasis>H</emphasis> верна. В случае, когда степень достоверности <emphasis>E</emphasis> находится где-то между полной достоверностью и невозможностью, степень достоверности <emphasis>H</emphasis> определяется при помощи интерполяции между двумя крайними случаями. Крайние случаи таковы:</p>
      <p>(1) известно, что факта <emphasis>E</emphasis> не было</p>
      <p>(2) известно, что факт <emphasis>E</emphasis> имел место</p>
      <p>(3) ничего не известно относительно <emphasis>E</emphasis></p>
      <p>Для каждого события <emphasis>H</emphasis> сети вывода существует априорная вероятность <emphasis>р<sub>o</sub></emphasis>(<emphasis>H</emphasis>) (безусловная) вероятность события <emphasis>H</emphasis> в состоянии, когда неизвестно ни одного положительного или отрицательного факта. Если становится известным какой-нибудь факт <emphasis>E</emphasis>, то вероятность <emphasis>H</emphasis> меняет свое значение с  <emphasis>р<sub>o</sub></emphasis>(<emphasis>H</emphasis>) на  <emphasis>p</emphasis>(<emphasis>H|E</emphasis>). Величина изменения зависит от "силы" стрелки, ведущей из <emphasis>E</emphasis> в <emphasis>H</emphasis>. Итак, мы начинаем проверку гипотез, принимая их априорные вероятности. В дальнейшем происходит накопление информации о фактах, что находит свое отражение в изменении вероятностей событий сети. Эти изменения распространяются по сети от события к событию в соответствии со связями между событиями. Например, рассмотрим рис. 14.14 и предположим, что получена информация о срабатывании индикатора открытия выпускного клапана. Эта информация повлияет на нашу уверенность в том, что выпускной клапан открылся, что, в свою очередь, повлияет на уверенность в том, что сместилась установка порогового давления.</p>
      <image l:href="#_105.png"/>
      <p><strong>Рис. 14.15.</strong> Правила распространения вероятностей по сети, принятые в системах Prospector и AL/X: (а) "мягкая импликация" с силой (<emphasis>N</emphasis>, <emphasis>S</emphasis>); (b) логические комбинации отношений.</p>
      <p>На рис. 14.15 показан один из способов реализации этого эффекта распространения информации по сети. Часть вычислений производится не над вероятностями, а над <emphasis>шансами</emphasis>. Это удобно, хотя в принципе и не обязательно. Между шансами и вероятностями имеет место простое соотношение:</p>
      <p><emphasis>шанс = вер / </emphasis>(1<emphasis> – вер</emphasis>)</p>
      <p><emphasis>вер = шанс / </emphasis>(1<emphasis> + шанс</emphasis>)</p>
      <p>Пусть между <emphasis>E</emphasis> и <emphasis>H</emphasis> существует отношение "мягкой импликации", тогда, в соответствии с рис. 14.15,</p>
      <p><emphasis>шанс</emphasis>(<emphasis>H|E</emphasis>) <emphasis>= M * шанс</emphasis>(<emphasis>H</emphasis>)</p>
      <p>где множитель <emphasis>M</emphasis> определяется априорной и апостериорной вероятностями с учетом силы (<emphasis>N, S</emphasis>) связи между <emphasis>E</emphasis> и <emphasis>H</emphasis>. Предполагается, что правила Prospector'a (рис. 14.15) для вычисления вероятностей логических комбинаций событий (использующие <emphasis>min</emphasis> и <emphasis>max</emphasis>) правильно моделируют поведение человека при оценке субъективной уверенности в таких составных событиях. </p>
     </section>
     <section>
      <title>
       <p>14.6.3. Принципы реализации</p>
      </title>
      <p>Давайте сначала расширим правила языка, с тем чтобы получить возможность работать с неопределенностью. К каждому, правилу мы можем добавить "силовой модификатор", определяемый двумя неотрицательными действительными числами <emphasis>S </emphasis>и <emphasis>N</emphasis>. Вот соответствующий формат:</p>
      <p><code>Имя Правила: если</code></p>
      <p><code>              Условие</code></p>
      <p><code>             то</code></p>
      <p><code>              Заключение</code></p>
      <p><code>             с</code></p>
      <p><code>              Сила( N, S).</code></p>
      <p>Примеры правил рис. 14.14 можно изобразить в этой форме так:</p>
      <p><code>прав1 : если</code></p>
      <p><code>         не давлоткр и</code></p>
      <p><code>         открклап</code></p>
      <p><code>        то</code></p>
      <p><code>         открклрано</code></p>
      <p><code>        с</code></p>
      <p><code>         сила( 0.001, 2000).</code></p>
      <empty-line/>
      <p><code>прав2 : если</code></p>
      <p><code>         сепзапвд</code></p>
      <p><code>        то</code></p>
      <p><code>         давлоткр</code></p>
      <p><code>        с</code></p>
      <p><code>         сила( 0.05, 400).</code></p>
      <p>Для того, чтобы произвести соответствующее расширение оболочки экспертной системы (разд. 14.5), нам понадобится внести изменения в большинство процедур. Давайте сосредоточимся только на одной из них, а именно на процедуре</p>
      <p><code>рассмотреть( Цель, Трасса, Ответ)</code></p>
      <p>Мы предположим, что утверждение <code>Цель</code> не содержит переменных (как это сделано в Prospector'e и в AL/X). Это сильно упростит дело (особенно в процедуре <code>ответпольз</code>). Таким образом, <code>Цель</code> будет логической комбинацией элементарных утверждений. Например:</p>
      <p><code>не давлоткр и открклап</code></p>
      <p>Цепочку целей-предков и правил <code>Трасса</code> можно представить таким же способом, как это сделано в разд. 14.5. Однако форму представления объекта <code>Ответ</code> придется модифицировать для того, чтобы включить в нее вероятности. Цель и ее вероятность можно соединить в один терм следующим образом:</p>
      <p><code>Цель : Вероятность</code></p>
      <p>Получим такой пример объекта <code>Ответ</code>:</p>
      <p><code>индоткр : 1 было сказано</code></p>
      <p>Смысл ответа: пользователь сообщил системе, что событие <code>индоткр</code> произошло, и что это абсолютно достоверно.</p>
      <p>Представление объекта <code>Ответ</code> требует еще одной модификации, в связи с тем, что в одно и то же событие могут вести несколько независимых связей, которые все окажут влияние на вероятность этого события — его шанс будет помножен (рис. 14.15) на все множители. В этом случае <code>Ответ</code> будет содержать список всех ветвей вывода заключения. Приведем пример ответа такого рода для сети рис. 14.14 (для наглядности расположенный на нескольких строках):</p>
      <p><code>давлоткр : 1 было 'выведено по'</code></p>
      <p><code> [ прав2 из сепзапвд : 1 было сказано,</code></p>
      <p><code>   прав5 из диагсеп : 1 было сказано ]</code></p>
      <p>Процедура <code>рассмотреть</code>, выдающая ответы в такой форме, показана на рис. 14.16. Она обращается к предикату</p>
      <p><code>импликация( Р0, P, Сила, Вер0, Вер)</code></p>
      <p>соответствующему отношению "мягкой импликации" (см. рис. 14.15). Р0 — априорная вероятность события <emphasis>E</emphasis>, а P — его апостериорная вероятность. <code>Сила</code> — сила импликации, представленная как</p>
      <p><code>сила( N, S)</code></p>
      <p><code>Вер0</code> и <code>Вер</code> — соответственно априорная и апостериорная вероятности гипотезы <emphasis>H</emphasis>.</p>
      <p>Следует заметить, что наша реализация очень проста, она обеспечивает только изменение вероятностей при распространении информации по сети вывода и иногда ведет себя недостаточно разумно. Никакого внимания не уделяется отбору для анализа наиболее важной в данный момент информации. В более сложной версии следовало бы направлять процесс поиска ответа в сторону наиболее существенных фактов. Кроме того, необходимо стремиться к тому, чтобы пользователю задавалось как можно меньше вопросов.</p>
      <p>Наконец, несколько замечаний относительно новой версии процедуры <code>ответпольз</code>. Она будет проще, чем процедура рис. 14.11, так как в запросах, передаваемых пользователю, уже не будет переменных. На этот раз пользователь в качестве ответа введет некоторую вероятность (вместо "да" или "нет"). Если пользователю ничего неизвестно о событии, содержащемся в вопросе, то вероятность этого события не изменится. Пользователь может также задать вопрос "почему" и получить изображение объекта <code>Трасса</code> в качестве объяснения. Кроме того, следует разрешить пользователю задавать вопрос: "Какова текущая вероятность моей гипотезы?" Тогда, если он устал вводить новую информацию (или у него мало времени), он может прекратить консультационный сеанс, довольствуясь ответом системы, полученным на основании неполной информации.</p>
      <empty-line/>
      <p><code>% Процедура</code></p>
      <p><code>% рассмотреть( Цель, Трасса, Ответ)</code></p>
      <p><code>%</code></p>
      <p><code>% находит степень правдоподобия утверждения "цель это правда".</code></p>
      <p><code>% Оценка правдоподобия содержится в объекте Ответ. Трасса - это</code></p>
      <p><code>% цепочка целей-предшественников и правил, которую можно</code></p>
      <p><code>% использовать в объяснении типа "почему"</code></p>
      <p><code>рассмотреть( Цель, Трасса, ( Цель: Вер) было</code></p>
      <p><code> 'выведено по' ПравОтв) :-</code></p>
      <p><code> bagof( Прав: если Условие то Цель с Сила, Правила),</code></p>
      <p><code>  % Все правила, относящиеся к цели</code></p>
      <p><code> априори( Цель, Вер0),</code></p>
      <p><code>  % Априорная вероятность цели</code></p>
      <p><code> модиф( Вер0, Правила, Трасса, Вер, ПравОтв).</code></p>
      <p><code>  % Модифицировать априорные вероятности</code></p>
      <p><code>рассмотреть( Цель1 и Цель2, Трасса,</code></p>
      <p><code> ( Цель1 и Цель2 : Вер было 'выведено из'</code></p>
      <p><code>   ( Ответ1 и Ответ2) ) :-</code></p>
      <p><code> !,</code></p>
      <p><code> рассмотреть( Цель1, Трасса, Ответ1),</code></p>
      <p><code> рассмотреть( Цель2, Трасса, Ответ2),</code></p>
      <p><code> вероятность( Ответ1, В1),</code></p>
      <p><code> вероятность( Ответ2, В2),</code></p>
      <p><code> мин( В1, В2, Вер).</code></p>
      <p><code>рассмотреть( Цель1 или Цель2, Трасса,</code></p>
      <p><code> ( Цель или Цель2:Вер) было 'выведено из'</code></p>
      <p><code>   ( Ответ1 и Ответ2) ) :-</code></p>
      <p><code> !,</code></p>
      <p><code> рассмотреть( Цель1, Трасса, Ответ1),</code></p>
      <p><code> рассмотреть( Цель2, Трасса, Ответ2),</code></p>
      <p><code> вероятность( Ответ1, В1),</code></p>
      <p><code> вероятность( Ответ2, В2),</code></p>
      <p><code> макс( В1, В2, Вер).</code></p>
      <p><code>рассмотреть( не Цель, Трасса,</code></p>
      <p><code> ( не Цель:Вер) было 'выведено из' Ответ) :-</code></p>
      <p><code> !,</code></p>
      <p><code> рассмотреть( Цель, Трасса, Ответ),</code></p>
      <p><code> вероятность( Ответ, В),</code></p>
      <p><code> обратить( В, Вер).</code></p>
      <p><code>рассмотреть( Цель, Трасса, ( Цель: Вер) было сказано) :-</code></p>
      <p><code> ответпольз( Цель, Трасса, Вер).</code></p>
      <empty-line/>
      <p><code>% Ответ, выведенный пользователем</code></p>
      <p><code>% Отношение</code></p>
      <p><code>%</code></p>
      <p><code>% модиф( Вер0, Правила, Трасса, Вер, ПравОтв)</code></p>
      <p><code>%</code></p>
      <p><code>% Существует Цель с априорной вероятностью Вер0. Правила имеют</code></p>
      <p><code>% отношение к утверждению Цель; суммарное влияние этих правил</code></p>
      <p><code>% (точнее, их условных частей) на Вер0 приводит к тому,</code></p>
      <p><code>% что Вер0 заменяется на апостериорную вероятность Вер;</code></p>
      <p><code>% Трасса - список целей-предков и правил, использовавшихся</code></p>
      <p><code>% при выводе утверждения Цель;</code></p>
      <p><code>% ПравОтв - результаты анализа условных частей</code></p>
      <p><code>% правил из списка Правила.</code></p>
      <p><code>модиф( Вер0, [], Трасса, Вер0, []).</code></p>
      <p><code>  % Нет правил - нет модификации</code></p>
      <p><code>модиф( Вер0,</code></p>
      <p><code> [ Прав : если Усл то Цель с Сила | Правила],</code></p>
      <p><code> Трасса, Вер, [Прав из Ответ | ПравОтв] ):-</code></p>
      <p><code> рассмотреть( Усл, [Цель по Прав | Трасса], Ответ),</code></p>
      <p><code>  % Условие из первого правила</code></p>
      <p><code> априори( Усл, В0),</code></p>
      <p><code> вероятность( Ответ, В),</code></p>
      <p><code> импликация( В0, В, Сила, Вер0, Вер1),</code></p>
      <p><code>  % "Мягкая" импликация</code></p>
      <p><code> модиф( Вер1, Правила, Трасса, Вер, ПравОтв).</code></p>
      <p><strong>Рис. 14.16.</strong> Определение степени правдоподобия гипотезы при помощи распространения информации об оценке уверенности по сети вывода.</p>
     </section>
    </section>
    <section>
     <title>
      <p>14.7. Заключительные замечания</p>
     </title>
     <p>Нашу оболочку экспертной системы можно развивать в целом ряде направлений. В данный момент уместно сделать несколько критических замечаний и высказать предложения по усовершенствованию нашей программы.</p>
     <p>В нашей программе, являющейся упрощенной реализацией, не уделено достаточного внимания вопросам эффективности. В более эффективной реализации потребовалось бы использовать более сложные структуры данных, ввести индексирование или иерархическую структуризацию множества правил и т.п.</p>
     <p>Наша процедура <code>рассмотреть</code> подвержена зацикливанию в тех случаях, когда в правилах базы знаний "циклически" упоминается одна и та же цель. Этот недостаток легко исправить, предусмотрев в <code>рассмотреть</code> соответствующий контроль, т.е. проверку, не является ли текущая цель частным случаем некоторой цели, уже введенной в состав объекта <code>Трасса</code>.</p>
     <p>Наше объяснение типа "как" выводит дерево доказательства целиком. В случае больших деревьев, удобнее было бы вывести только верхнюю часть дерева, а затем дать пользователю возможность "гулять" по остальной части дерева по своему желанию. Тогда пользователь смог бы просматривать дерево выборочным образом, используя команды, такие как "Вниз по ветви 1", "Вниз по ветви 2", …, "Вверх", "Достаточно".</p>
     <p>В объяснениях типа "как" и "почему" наша оболочка ссылается на правила, указывая их имена, и не показывает их в явном виде. Необходимо, чтобы во время консультационного сеанса пользователь мог, по желанию, запрашивать те или иные правила и получать их явные изображения.</p>
     <p>Известно, что придать диалогу с пользователем естественный характер при помощи умелой постановки вопросов - сложная задача. Наш способ ее решения работает только в определенных пределах и во многих случаях приводит к самым разным проблемам, например:</p>
     <p><code><emphasis>Это правда: сьюзен летает?</emphasis></code></p>
     <p><code><strong>нет.</strong></code></p>
     <p><code><emphasis>Это правда: сьюзен летает хорошо?</emphasis></code></p>
     <p>Конечно же нет, раз она совсем не летает! Другой пример:</p>
     <p><code><emphasis>Есть (еще) решения для: Кто-нибудь летает?</emphasis></code></p>
     <p><code><strong>да.</strong></code></p>
     <p><code><emphasis>Кто-нибудь =</emphasis> <strong>птица</strong>.</code></p>
     <p><code><emphasis>Это правда: альбатрос летает?</emphasis></code></p>
     <p>Для того, чтобы справиться с подобными нежелательными эффектами, следует ввести в экспертную систему дополнительные отношения между понятиями вместе с механизмами их обработки. Обычно эти новые отношения задают иерархию объектов и их свойств.</p>
     <p>Возможно еще одно усовершенствование процедуры взаимодействия с пользователем, предусматривающее планирование оптимальной стратегии постановки вопросов. Целью оптимизации является минимизация количества вопросов, которые необходимо задать пользователю для достижения некоторого окончательного логического заключения. Разумеется, возникнут различные варианты таких стратегий, и то, какая из них окажется оптимальной, будет зависеть от ответов пользователя. Принятие решения о выборе той или иной альтернативной стратегии можно основывать на <emphasis>априорных</emphasis> вероятностях, являющихся вероятностными оценками "стоимостей" альтернатив. Величины оценок, возможно, придется пересчитывать после каждого ответа пользователя.</p>
     <p>Существует еще одна величина, поддающаяся оптимизации: длина цепочки вывода. Такая оптимизация позволила бы давать более простые объяснения типа "как". Сложность объяснений можно также уменьшить за счет селективного подхода к правилам. Некоторые из правил можно было бы не включать в состав объектов <code>Трасса</code> и <code>Ответ</code>, порождаемых процедурой <code>рассмотреть</code>. С этой целью необходимо указывать в базе знаний, какие из правил "трассируемы", а следовательно, должны появляться в объяснениях, а какие можно опускать.</p>
     <p>В "разумной" экспертной системе следует предусмотреть вероятностные механизмы, заставляющие ее концентрировать свое внимание на наиболее правдоподобных гипотезах среди всех конкурирующих между собой гипотез. Такая экспертная система должна запрашивать у пользователя ту информацию, которая позволила бы распознать наилучшую среди наиболее правдоподобных гипотез.</p>
     <p>Наша экспертная система была классификационного или "анализирующего" типа, в противоположность системам "синтезирующего" типа, в которых ставится задача <emphasis>построить</emphasis> что-либо. В последнем случае результат работы - это план действий, предпринимаемых для выполнения этой задачи, например план действий робота, компьютерная конфигурация, удовлетворяющая заданным требованиям, или форсированная комбинация в шахматах. Наш пример, относящийся к локализации неисправностей, можно естественным образом расширить, чтобы включить в рассмотрение действия. Например, если система не может прийти к определенному выводу, поскольку приборы выключены, она даст рекомендацию: "Включить лампу 3". Здесь сразу возникнет задача построения оптимального плана: минимизировать число действий, необходимых для достижения окончательного вывода.</p>
     <subtitle>Проекты</subtitle>
     <p>Завершите программирование нашей оболочки в части, касающейся неопределенной информации (процедура <code>ответпольз</code> и другие).</p>
     <p>Рассмотрите перечисленные выше критические замечания, а также возможные расширения нашей экспертной системы. Разработайте и реализуйте соответствующие усовершенствования.</p>
    </section>
    <section>
     <title>
      <p>Резюме </p>
     </title>
     <p>• Обычно от экспертных систем требуют выполнения следующих функций:</p>
     <p>  решение задач в заданной предметной области,</p>
     <p>  объяснение процесса решения задач,</p>
     <p>  работа с неопределенной и неполной информацией.</p>
     <p>• Удобно считать, что экспертная система со стоит из двух модулей: оболочки и базы знаний. Оболочка в свою очередь состоит из механизма логического вывода и интерфейса с пользователем.</p>
     <p>• При создании экспертной системы необходимо принять решения о выборе формального языка представления знаний, механизма логического вывода, средств взаимодействия с пользователем и способа работы в условиях неопределенности.</p>
     <p>• "Если-то"-правила, или продукции являются наиболее часто применяемой формой представления знаний в экспертных системах.</p>
     <p>• Оболочка, разработанная в данной главе, интерпретирует "если-то"-правила, обеспечивает выдачу объяснений типа "как" и "почему" и запрашивает у пользователя необходимую информацию.</p>
     <p>• Машина логического вывода была расширена для работы с неопределенной информацией.</p>
     <p>• В данной главе были обсуждены следующие понятия:</p>
     <p>  экспертные системы</p>
     <p>  база знаний, оболочка,</p>
     <p>  машина логического вывода</p>
     <p>  "если-то"-правила, продукции</p>
     <p>  объяснения типа "как" и "почему"</p>
     <p>  категорические знания, неопределенные знания</p>
     <p>  сеть вывода,</p>
     <p>  распространение оценок достоверности по сети</p>
     <subtitle>Литература</subtitle>
     <p>Книга Michie (1979) - это сборник статей, относящихся к различным аспектам экспертных систем и инженерии знаний. Две ранние экспертные системы, оказавшие большое влияние на развитие этой области, MYCIN и Prospector, описаны в Shortliffe (1976) и Duda et al (1979). Книга Buchanan and Shortliffe (1984) является хорошим сборником статей, посвященных результатам экспериментов с системой MYCIN. Weiss and Kulikowski (1984) описывают свой практический опыт разработки экспертных систем. Вопрос о работе в условиях неопределенности еще нельзя считать вполне решенным: в статье Quinlan (1983) сравниваются различные подходы к этой проблеме. Способ разработки нашей экспертной системы до некоторой степени аналогичен описанному в Hammond (1984). Некоторые примеры, использовавшиеся в тексте, заимствованы из Winston (1984), Shortliffe (1976), Duda et al (1979), Bratko (1982) и Reiter (1980).</p>
     <empty-line/>
     <p>Bratko I. (1982). Knowledge-based problem-solving in AL3. In: <emphasis>Machine Intelligence 10</emphasis> (J.E. Hayes, D. Michie, Y.H. Pao, eds.). Ellis Horwood.</p>
     <p>Buchanan B.G. and Shortliffe E.H. (1984, eds.). <emphasis>Rule-based Expert Systems: The МYСIN Experiments of the Stanford Heuristic Programming Project.</emphasis> Addison-Wesley.</p>
     <p>Duda R., Gasschnig J. and Hart P. (1979). Model design in the Prospector consultant system for mineral exploration. In: <emphasis>Expert Systems in the Microelectronic Age</emphasis> (D. Michie, ed.). Edinburgh University Press.</p>
     <p>Hammond P. (1984). vMicro-PROLOG for Expert Systems. In: <emphasis>Micro-PROLOG: Programming in Logic</emphasis> (K.L. Clark, F.G. McCabe, eds.). Prentice-Hall.</p>
     <p>Michie D. (1979, ed.). <emphasis>Expert Systems in the Microelectronic Age.</emphasis> Edinburgh University Press.</p>
     <p>Quinlan J.R. (1983). Inferno: a cautious approach to uncertain reasoning. <emphasis>The Computer Journal</emphasis> <strong>26</strong>: 255-270.</p>
     <p>Reiter J. (1980). AL/X: An Expert System Using Plausible Inference. Oxford: Intelligent Terminals Ltd.</p>
     <p>Shortliffe E. (1976). <emphasis>Computer-based Medical Consultations: MYCIN.</emphasis> Elsevier.</p>
     <p>Weiss S.M. and Kulikowski CA. (1984). <emphasis>A Practical Guide to Designing Expert Systems.</emphasis> Chapman and Hall.</p>
     <p>Winston P. H. (1984). <emphasis>Artificial Intelligence</emphasis> (second edition). Addison-Wesley. [Имеется перевод первого издания: Уинстон П. Искусственный интеллект. — М.: Мир, 1980.]</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 15</p>
     <p>Игры</p>
    </title>
    <section>
     <p>В этой главе мы рассмотрим методы программирования игр двух лиц с полной информацией (таких, как шахматы). Для игр, представляющих интерес, деревья возможных продолжений слишком велики, чтобы можно было говорить о полном переборе, поэтому необходимы какие-то другие подходы. Один из таких методов, основанный на минимаксном принципе, имеет эффективную реализацию, известную под названием "альфа-бета алгоритм". В дополнение к этому стандартному методу, мы разработаем в этой главе программу на основе Языка Советов (Advice Language), который дает возможность вносить в шахматную программу знания о типовых ситуациях. Этот довольно подробный пример может послужить еще одной иллюстрацией того, насколько хорошо Пролог приспособлен для реализации систем, основанных на знаниях.</p>
    </section>
    <section>
     <title>
      <p>15.1. Игры двух лиц с полной информацией</p>
     </title>
     <p>Игры, которые мы собираемся обсуждать в данной главе, относятся к классу так называемых игр двух лиц с полной информацией. Примерами таких игр могут служить шахматы, шашки и т.п. В игре участвуют два игрока, которые ходят по очереди, причем оба они обладают полной информацией о текущей игровой ситуации (это определение исключает большинство карточных игр). Игра считается оконченной, если достигнута позиция, являющаяся согласно правилам игры "терминальной" (конечной), например матовая позиция в шахматах. Правилами игры также устанавливается, каков исход игры в этой терминальной позиции.</p>
     <p>Для игр такого рода возможно представление в виде <emphasis>дерева игры</emphasis> (или <emphasis>игрового дерева</emphasis>). Вершины этого дерева соответствуют ситуациям, а дуги — ходам. Начальная ситуация игры — это корневая вершина; листьями дерева представлены терминальные позиции.</p>
     <p>В большинстве игр этого типа возможны следующие исходы: <emphasis>выигрыш</emphasis>, <emphasis>проигрыш</emphasis> и <emphasis>ничья</emphasis>. Мы будем рассматривать здесь игры, имеющие только два возможных исхода — <emphasis>выигрыш</emphasis> и <emphasis>проигрыш</emphasis>. Игры, в которых возможна ничья, можно упрощенно считать играми с двумя исходами — <emphasis>выигрыш</emphasis> и <emphasis>не-выигрыш</emphasis>. Двух участников игры мы будем называть "игроком" и "противником". "Игрок" может выиграть в некоторой нетерминальной позиции с ходом игрока ("позиции игрока"), если в ней существует <emphasis>какой-нибудь</emphasis> разрешенный ход, приводящий к выигрышу. С другой стороны, некоторая нетерминальная позиция с ходом противника ("позиция противника") является выигранной для игрока, если <emphasis>все</emphasis> разрешенные ходы из этой позиции ведут к позициям, в которых возможен выигрыш. Эти правила находятся в полном соответствии с представлением задач в форме И/ИЛИ-дерева, которое мы обсуждали в гл. 13. Между понятиями, относящимися к И/ИЛИ-деревьям, и понятиями, используемыми в играх, можно установить взаимное соответствие следующим образом:</p>
     <table>
      <tr>
       <td>позиции игры</td>
       <td>вершины, задачи</td>
      </tr>
      <tr>
       <td>терминальные позиции выигрыша</td>
       <td>целевые вершины, тривиально решаемые задачи</td>
      </tr>
      <tr>
       <td>терминальные позиции проигрыша</td>
       <td>задачи, не имеющие решения</td>
      </tr>
      <tr>
       <td>выигранные позиции</td>
       <td>задачи, имеющие решение</td>
      </tr>
      <tr>
       <td>позиции игрока</td>
       <td>ИЛИ-вершины</td>
      </tr>
      <tr>
       <td>позиции противника</td>
       <td>И-вершины</td>
      </tr>
     </table>
     <p>Очевидно, что аналогичным образом понятия, относящиеся к поиску в И/ИЛИ-деревьях, можно переосмыслить в терминах поиска в игровых деревьях.</p>
     <p>Ниже приводится простая программа, которая определяет, является ли некоторая позиция игрока выигранной.</p>
     <p><code>выигр( Поз) :-</code></p>
     <p><code> терм_выигр( Поз).</code></p>
     <p><code>  % Терминальная выигранная позиция</code></p>
     <p><code>выигр( Поз) :-</code></p>
     <p><code> not терм_проигр( Поз),</code></p>
     <p><code> ход( Поз, Поз1), % Разрешенный ход в Поз1</code></p>
     <p><code> not ( ход( Поз1, Поз2),</code></p>
     <p><code> not выигр( Поз2) ).</code></p>
     <p><code>  % Ни один из ходов противника не ведет к не-выигрышу</code></p>
     <p>Здесь правила игры встроены в предикат <code>ход( Поз, Поз1)</code>, который порождает все разрешенные ходы, а также в предикаты <code>терм_выигр( Поз)</code> и <code>терм_проигр( Поз)</code>, которые распознают терминальные позиции, являющиеся, согласно правилам игры, выигранными или проигранными. В последнем из правил программы, содержащем двойное отрицание (<code>not</code>), говорится: не существует хода противника, ведущего к не выигранной позиции. Другими словами: <emphasis>все</emphasis> ходы противника приводят к позициям, выигранным с точки зрения игрока.</p>
     <image l:href="#_106.png"/>
     <p><strong>Рис. 15.1.</strong> Сложность игровых деревьев в шахматах. Оценки основаны на том, что в каждой шахматной позиции существуют приблизительно 30 разрешенных ходов я что терминальные позиции расположены на глубине 40 ходов. Один ход равен двум полуходам (по одному полуходу с каждой стороны).</p>
     <p>Так же, как и аналогичная программа поиска в И/ИЛИ-графах, приведенная выше программа использует стратегию в глубину. Кроме того, в ней не исключается возможность зацикливания на одних и тех же позициях. Попытка устранить этот недостаток может привести к осложнениям, поскольку правила некоторых из игр допускают такое повторение позиций. Правда, разрешение повторять позиции часто носит условный характер, например по шахматным правилам после троекратного повторения позиции может быть объявлена ничья.</p>
     <p>Программа, которую мы составили, демонстрирует основные принципы программирования игр. Но практически приемлемая реализация таких сложных игр, как шахматы или го, потребовала бы привлечения значительно более мощных методов. Огромная комбинаторная сложность этих игр делает наш наивный переборный алгоритм, просматривающий дерево вплоть до терминальных игровых позиций, абсолютно непригодным. Этот вывод иллюстрирует (на примере шахмат) рис. 15.1: пространство поиска имеет астрономические размеры — около 10<sup>120</sup> позиций. Можно возразить, что в дереве на рис. 15.1 встречаются одинаковые позиции. Однако было показано, что число различных позиций дерева поиска находится далеко за пределами возможностей вычислительных машин обозримого будущего.</p>
     <subtitle>Проект</subtitle>
     <p>Напишите программу для какой-нибудь простой игры (такой, как <emphasis>ним</emphasis>), использующую упрощенный алгоритм войска в И/ИЛИ-дереве.</p>
    </section>
    <section>
     <title>
      <p>15.2. Минимаксный принцип</p>
     </title>
     <p>Для игр, представляющих интерес, полный просмотр игрового дерева невозможен, поэтому были разработаны другие методы, предусматривающие просмотр только части дерева игры. Среди этих методов существует страндартный метод поиска, используемый в игровых (особенно в шахматных) программах и основанный на <emphasis>минимаксном</emphasis> принципе. Дерево игры просматривается только вплоть до некоторой глубины (обычно на несколько ходов), а затем для всех концевых вершин дерева поиска вычисляются оценки при помощи некоторой оценочной функции. Идея состоит в том, чтобы, получив оценки этих терминальных поисковых вершин, не продвигаться дальше и получить тем самым экономию времени. Далее, оценки терминальных позиций распространяются вверх по дереву поиска в соответствии с минимаксным принципом. В результате все вершины дерева поиска получают свои оценки. И наконец, игровая программа, участвующая в некоторой реальной игре, делает свой ход — ход, ведущий из исходной (корневой) позиции в наиболее перспективного (с точки зрения оценки) ее преемника.</p>
     <p>Обратите внимание на то, что мы здесь делаем определенное различие между "деревом игры" и "деревом поиска". Дерево поиска — это только часть дерева игры (его верхняя часть), т.е. та его часть, которая была явным образом порождена в процессе поиска. Таким образом, терминальные поисковые позиции совсем не обязательно должны совпадать с терминальными позициями самой игры.</p>
     <p>Очень многое зависит от оценочной функции, которая для большинства игр, представляющих интерес, является приближенной эвристической оценкой шансов на выигрыш одного из участников игры. Чем выше оценка, тем больше у него шансов выиграть и чем ниже оценка, тем больше шансов на выигрыш у его противника. Поскольку один из участников игры всегда стремится к высоким оценкам, а другой — к низким, мы дадим им имена МАКС и МИН соответственно. МАКС всегда выбирает ход с максимальной оценкой; в противоположность ему МИН всегда выбирает ход с минимальной оценкой. Пользуясь этим принципом (<emphasis>минимаксным</emphasis> принципом) и зная значения оценок для всех вершин "подножья" дерева поиска, можно определить оценки всех остальных вершин дерева. На рис. 15.2 показано, как это делается. На этом рисунке видно, что уровни позиций с ходом МАКС'а чередуются с уровнями позиций с ходом МИН'а. Оценки вершин нижнего уровня определяются при помощи оценочной функции. Оценки всех внутренних вершин можно определить, двигаясь снизу вверх от уровня к уровню, пока мы не достигнем корневой вершины. В результате, как видно из рис. 15.2, оценка корня оказывается равной 4, и, соответственно, лучшим ходом МАКС'а из позиции <emphasis>а</emphasis> — <emphasis>a-b</emphasis>. Лучший ответ МИН'а на этот ход — <emphasis>b-d</emphasis>, и т.д. Эту последовательность ходов называют также <emphasis>основным вариантом</emphasis>. Основной вариант показывает, какова "минимаксно-оптимальная" игра для обоих участников. Обратите внимание на то, что оценки всех позиций, входящих в основной вариант, совпадают.</p>
     <image l:href="#_107.png"/>
     <p><strong>Рис. 15.2.</strong> Статические (нижний уровень) и минимаксные рабочие оценки вершин дерева поиска. Выделенные ходы образуют <emphasis>основной вариант</emphasis>, т.е. минимаксно-оптимальную игру с обеих сторон.</p>
     <p>Мы различаем два вида оценок: оценки вершин нижнего уровня и оценки внутренних вершин (рабочие оценки). Первые из них называются также "статическими", так как они вычисляются при помощи "статической" оценочной функции, в противоположность рабочим оценкам, получаемым "динамически" при распространении статических оценок вверх по дереву.</p>
     <p>Правила распространения оценок можно сформулировать следующим образом. Будем обозначать статическую оценку позиции <emphasis>P </emphasis>через <emphasis>v</emphasis>(<emphasis>P</emphasis>), а ее рабочую оценку — через <emphasis>V</emphasis>(<emphasis>P</emphasis>). Пусть <emphasis>P<sub>1</sub></emphasis>, …, <emphasis>Р<sub>n</sub></emphasis> — разрешенные преемники позиции <emphasis>P</emphasis>. Тогда соотношения между статическими и рабочими оценками можно записать так:</p>
     <p><emphasis>V</emphasis>(<emphasis>P</emphasis>)<emphasis> = v</emphasis>(<emphasis>P</emphasis>)</p>
     <p>если <emphasis>P</emphasis> — терминальная позиция дерева поиска (<emphasis>n=</emphasis>0)</p>
     <p> <image l:href="#img_4.png"/></p>
     <p>если <emphasis>P</emphasis> — позиция с ходом МАКС'а</p>
     <p> <image l:href="#img_5.png"/></p>
     <p>если <emphasis>P</emphasis> — позиция с ходом МИН'а</p>
     <empty-line/>
     <p><code>% Минимаксная процедура: минимакс( Поз, ЛучшПоз, Оц)</code></p>
     <p><code>% Поз - позиция, Оц - ее минимаксная оценка;</code></p>
     <p><code>% лучший ход из Поз ведет в позицию ЛучшПоз</code></p>
     <p><code>минимакс( Поз, ЛучшПоз, Оц) :-</code></p>
     <p><code> оды( Поз, СписПоз), !,</code></p>
     <p><code>  % СписПоз - список разрешенных ходов</code></p>
     <p><code> лучш( СписПоз, ЛучшПоз, Оц);</code></p>
     <p><code> стат_оц( Поз, Оц). % Поз не имеет преемников</code></p>
     <empty-line/>
     <p><code>лучш( [Поз], Поз, Оц) :-</code></p>
     <p><code> минимакс( Поз, _, Оц), !.</code></p>
     <p><code>лучш( [Поз1 | СписПоз], ЛучшПоз, ЛучшОц) :-</code></p>
     <p><code> минимакс( Поз1, _, Оц1),</code></p>
     <p><code> лучш( СписПоз, Поз2, Оц2),</code></p>
     <p><code> выбор( Поз1, Оц1, Поз2, Оц2, ЛучшПоз, ЛучшОц).</code></p>
     <empty-line/>
     <p><code>выбор( Поз0, Оц0, Поз1, Оц1, Поз0, Оц0) :-</code></p>
     <p><code> ход_мина( Поз0), Оц &gt; Оц1, !;</code></p>
     <p><code> ход_макса( Поз0), Оц &lt; Оц1, !.</code></p>
     <p><code>выбор( Поз0, Оц0, Поз1, Оц1, Поз1, Оц1).</code></p>
     <p><strong>Рис. 15.3.</strong> Упрощенная реализация минимаксного принципа.</p>
     <empty-line/>
     <p>Программа на Прологе, вычисляющая минимаксную рабочую оценку для некоторой заданной позиции, показана на рис. 15.3. Основное отношение этой программы —</p>
     <p><code>минимакс( Поз, ЛучшПоз, Оц)</code></p>
     <p>где <code>Оц </code>— минимаксная оценка позиции <code>Поз</code>, а <code>ЛучшПоз</code> — наилучшая позиция-преемник позиции <code>Поз</code> (лучший ход, позволяющий достигнуть оценки <code>Оц</code>). Отношение</p>
     <p><code>ходы( Поз, СписПоз)</code></p>
     <p>задает разрешенные ходы игры: <code>СписПоз</code> — это список разрешенных позиций-преемников позиции <code>Поз</code>. Предполагается, что цель <code>ходы</code> имеет неуспех, если <code>Поз</code> является терминальной поисковой позицией (листом дерева поиска). Отношение</p>
     <p><code>лучш( СписПоз, ЛучшПоз, ЛучшОц)</code></p>
     <p>выбирает из списка позиций-кандидатов <code>СписПоз</code> "наилучшую" позицию <code>ЛучшПоз</code>. <code>ЛучшОц</code> — оценка позиции <code>ЛучшПоз</code>, а следовательно, и позиции <code>Поз</code>. Под "наилучшей" оценкой мы понимаем либо максимальную, либо минимальную оценку, в зависимости от того, с чьей стороны ожидается ход.</p>
    </section>
    <section>
     <title>
      <p>15.3. Альфа-бета алгоритм: эффективная реализация минимаксного принципа</p>
     </title>
     <p>Программа, показанная на рис. 15.3, производит просмотр в глубину дерева поиска, систематически обходя <emphasis>все</emphasis> содержащиеся в нем позиции вплоть до терминальных; она вычисляет статические оценки <emphasis>всех</emphasis> терминальных позиций. Как правило, для того, чтобы получить правильную минимаксную оценку корневой вершины, совсем не обязательно проделывать эту работу полностью. Поэтому алгоритм поиска можно сделать более экономным. Его можно усовершенствовать, используя следующую идею. Предположим, что у нас есть два варианта хода. Как только мы узнали, что один из них явно хуже другого, мы можем принять правильное решение, не выясняя, на сколько <emphasis>в точности</emphasis> он хуже. Давайте используем этот принцип для сокращения дерева поиска рис. 15.2. Процесс поиска протекает следующим образом:</p>
     <p>(1) Начинаем с позиции <emphasis>а</emphasis>.</p>
     <p>(2) Переходим к <emphasis>b</emphasis>.</p>
     <p>(3) Переходим к <emphasis>d</emphasis>.</p>
     <p>(4) Берем максимальную из оценок преемников позиции <emphasis>d</emphasis>, получаем <emphasis>V(d) =</emphasis> 4.</p>
     <p>(5) Возвращаемся к <emphasis>b</emphasis> и переходим к  <emphasis>e</emphasis>.</p>
     <p>(6) Рассматриваем первого преемника позиции <emphasis>e</emphasis> с оценкой 5. В этот момент МАКС (который как раз и должен ходить в позиции <emphasis>e</emphasis>) обнаруживает, что ему гарантирована в позиции <emphasis>e</emphasis> оценка не меньшая, чем 5, независимо от оценок других (возможно, более предпочтительных) вариантов хода. Этого вполне достаточно для того, чтобы МИН, даже не зная точной оценки позиции <emphasis>e</emphasis>, понял, что для него в позиции <emphasis>b</emphasis> ход в <emphasis>e</emphasis> хуже, чем ход в <emphasis>d</emphasis>.</p>
     <p>На основании приведенного выше рассуждения мы можем пренебречь вторым преемником позиции <emphasis>e</emphasis> и приписать <emphasis>e приближенную</emphasis> оценку 5. Приближенный характер этой оценки не окажет никакого влияния на оценку позиции <emphasis>b</emphasis>, а следовательно, и позиции <emphasis>а</emphasis>.</p>
     <p>На этой идее основан знаменитый <emphasis>альфа-бета алгоритм</emphasis>, предназначенный для эффективной реализации минимаксного принципа. На рис. 15.4 показан результат работы альфа-бета алгоритма, примененного к нашему дереву рис. 15.2. Из рис. 15.4 видно, что некоторые из рабочих оценок стали приближенными. Однако этих приближенных оценок оказалось достаточно для того, чтобы определить точную оценку корневой позиции. Сложность поиска уменьшилась до пяти обращений к оценочной функции по сравнению с восемью обращениями (в первоначальном дереве поиска рис. 15.2).</p>
     <p>Как уже говорилось раньше, ключевая идея альфа-бета отсечения состоит в том, чтобы найти ход не обязательно лучший, но "достаточно хороший" для того, чтобы принять правильное решение. Эту идею можно формализовать, введя два граничных значения, обычно обозначаемых через <emphasis>Альфа</emphasis> и <emphasis>Бета</emphasis>, между которыми должна заключаться рабочая оценка позиции. Смысл этих граничных значений таков: <emphasis>Альфа</emphasis> — это самое маленькое значение оценки, которое к настоящему моменту уже гарантировано для игрока МАКС; <emphasis>Бета</emphasis> — это самое большое значение оценки, на которое МАКС пока еще может надеяться. Разумеется, с точки зрения МИН'а, <emphasis>Бета</emphasis> является самым худшим значением оценки, которое для него уже гарантировано. Таким образом, действительное значение оценки (т.е. то, которое нужно найти) всегда лежит между <emphasis>Альфа</emphasis> и <emphasis>Бета</emphasis>. Если же стало известно, что оценка некоторой позиции лежит вне интервала <emphasis>Альфа-Бета</emphasis>, то этого достаточно для того, чтобы сделать вывод: данная позиция не входит в основной вариант. При этом точное значение оценки такой позиции знать не обязательно, его надо знать только тогда, когда оценка лежит между <emphasis>Альфа</emphasis> и <emphasis>Бета</emphasis>. "Достаточно хорошую" рабочую оценку  <emphasis>V( P, Альфа, Бета)</emphasis>  позиции <emphasis>P</emphasis> по отношению к <emphasis>Альфа</emphasis> и <emphasis>Бета</emphasis> можно определить формально как любое значение, удовлетворяющее следующим ограничениям:</p>
     <p><emphasis>V( P, Альфа, Бета) &#8804;  Альфа</emphasis> если <emphasis>V( P) &#8804; Альфа</emphasis></p>
     <p><emphasis>V( P, Альфа, Бета) = V( P)</emphasis> если <emphasis>Альфа &lt; V( P) &lt; Бета</emphasis></p>
     <p><emphasis>V( P, Альфа, Бета) &#8805; Бета</emphasis> если <emphasis>V( P) &#8805; Бета</emphasis></p>
     <image l:href="#_108.png"/>
     <p><strong>Рис. 15.4.</strong> Дерево рис. 15.2 после применения альфа-бета алгоритма. Пунктиром показаны ветви, отсеченные альфа-бета алгоритмом для экономии времени поиска. В результате некоторые из рабочих оценок стали приближенными (вершины <emphasis>c</emphasis>, <emphasis>e</emphasis>, <emphasis>f</emphasis>; сравните с рис. 15.2). Однако этих приближенных оценок достаточно для вычисления точной оценки корневой вершины и построения основного варианта.</p>
     <p>Очевидно, что, умея вычислять "достаточно хорошую" оценку, мы всегда можем вычислить точную оценку корневой позиции <emphasis>P</emphasis>, установив границы интервала следующим образом:</p>
     <p><emphasis>V( P, -бесконечность, +бесконечность)  =  V( P)</emphasis></p>
     <p>На рис. 15.5 показана реализация альфа-бета алгоритма в виде программы на Прологе. Здесь основное отношение —</p>
     <p><code>альфабета( Поз, Альфа, Бета, ХорПоз, Оц)</code></p>
     <p>где <code>ХорПоз</code> — преемник позиции <code>Поз</code> с "достаточно хорошей" оценкой <code>Оц</code>, удовлетворяющей всем указанным выше ограничениям:</p>
     <p><code>Оц</code> <emphasis>= V( Поз, Альфа, Бета)</emphasis></p>
     <p>Процедура</p>
     <p><code>прибл_лучш( СписПоз, Альфа, Бета, ХорПоз, Оц)</code></p>
     <p>находит достаточно хорошую позицию <code>ХорПоз</code> в списке позиций <code>СписПоз</code>; <code>Оц</code> — приближенная (по отношению к <code>Альфа</code> и <code>Бета</code>) рабочая оценка позиции <code>ХорПоз</code>.</p>
     <p>Интервал между <emphasis>Альфа</emphasis> и <emphasis>Бета</emphasis> может сужаться (но не расширяться!) по мере углубления поиска, происходящего при рекурсивных обращениях к альфа-бета процедуре. Отношение</p>
     <p><code>нов_границы( Альфа, Бета, Поз, Оц, НовАльфа, НовБета)</code></p>
     <p>определяет новый интервал <code>(НовАльфа, НовБета)</code>. Он всегда уже, чем старый интервал <code>(Альфа, Бета)</code>, или равен ему. Таким образом, чем глубже мы оказываемся в дереве поиска, тем сильнее проявляется тенденция к сжатию интервала <emphasis>Альфа-Бета</emphasis>, и в результате оценивание позиций на более глубоких уровнях происходит в условиях более тесных границ. При более узких интервалах допускается большая степень "приблизительности" при вычислении оценок, а следовательно, происходит больше отсечений ветвей дерева. Возникает интересный вопрос: насколько велика экономия, достигаемая альфа-бета алгоритмом по сравнению с программой минимаксного полного перебора рис. 15.3?</p>
     <empty-line/>
     <p><code>% Альфа-бета алгоритм</code></p>
     <p><code>альфабета( Поз, Альфа, Бета, ХорПоз, Оц) :-</code></p>
     <p><code> ходы( Поз, СписПоз), !,</code></p>
     <p><code> прибл_лучш( СписПоз, Альфа, Бета, ХорПоз, Оц);</code></p>
     <p><code> стат_оц( Поз, Оц).</code></p>
     <empty-line/>
     <p><code>прибл_лучш( [Поз | СписПоз], Альфа, Бета, ХорПоз, ХорОц) :-</code></p>
     <p><code> альфабета( Поз, Альфа, Бета, _, Оц),</code></p>
     <p><code> дост_хор( СписПоз, Альфа, Бета, Поз, Оц, ХорПоз, ХорОц).</code></p>
     <empty-line/>
     <p><code>дост_хор( [], _, _, Поз, Оц, Поз, Оц) :- !.</code></p>
     <p><code> % Больше нет кандидатов</code></p>
     <p><code>дост_хор( _, Альфа, Бета, Поз, Оц, Поз, Оц) :-</code></p>
     <p><code> ход_мина( Поз), Оц &gt; Бета, !;</code></p>
     <p><code>  % Переход через верхнюю границу</code></p>
     <p><code> ход_макса( Поз), Оц &lt; Альфа, !.</code></p>
     <p><code>  % Переход через нижнюю границу</code></p>
     <p><code>дост_хор( СписПоз, Альфа, Бета, Поз, Оц, ХорПоз, ХорОц) :-</code></p>
     <p><code> нов_границы( Альфа, Бета, Поз, Оц, НовАльфа, НовБета),</code></p>
     <p><code>  % Уточнить границы</code></p>
     <p><code> прибл_лучш( СписПоз, НовАльфа, НовБета, Поз1, Оц1),</code></p>
     <p><code> выбор( Поз, Оц, Поз1, Оц1, ХорПоз, ХорОц).</code></p>
     <empty-line/>
     <p><code>нов_границы( Альфа, Бета, Поз, Оц, Оц, Бета) :-</code></p>
     <p><code> ход_мина( Поз), Оц &gt; Альфа, !.</code></p>
     <p><code>  % Увеличение нижней границы</code></p>
     <p><code>нов_границы( Альфа, Бета, Поз, Оц, Альфа, Оц) :-</code></p>
     <p><code> ход_макса( Поз), Оц &lt; Бета, !.</code></p>
     <p><code>  % Уменьшение верхней границы</code></p>
     <p><code>нов_границы( Альфа, Бета, _, _, Альфа, Бета).</code></p>
     <empty-line/>
     <p><code>выбор( Поз, Оц, Поз1, Оц1, Поз, Оц) :-</code></p>
     <p><code> ход_мина( Поз), Оц &gt; Оц1, !;</code></p>
     <p><code> ход_макса( Поз), Оц &lt; Оц1, !.</code></p>
     <p><code>выбор( _, _, Поз1, Оц1, Поз1, Оц1).</code></p>
     <p><strong>Рис. 15.5.</strong> Реализация альфа-бета алгоритма.</p>
     <empty-line/>
     <p>Эффективность альфа-бета процедуры зависит от порядка, в котором просматриваются позиции. Всегда лучше первыми рассматривать самые сильные ходы с каждой из сторон. Легко показать на примерах, что возможен настолько неудачный порядок просмотра, что альфа-бета алгоритму придется пройти через <emphasis>все</emphasis> вершины, которые просматривались минимаксным алгоритмом полного перебора. Это означает, что в худшем случае альфа-бета алгоритм не будет иметь никаких преимуществ. Однако, если порядок просмотра окажется удачным, то экономия может быть значительной. Пусть <emphasis>N</emphasis> — число терминальных поисковых позиций, для которых вычислялись статические оценки алгоритмом минимаксного полного перебора. Было доказано, что в лучшем случае, когда самые сильные ходы всегда рассматриваются первыми, альфа-бета алгоритм вычисляет статические оценки только для <emphasis>N</emphasis> позиций.</p>
     <p>Этот результат имеет один практический аспект, связанный с проведением турниров игровых программ. Шахматной программе, участвующей в турнире, обычно дается некоторое определенное время для вычисления очередного хода, и доступная программе глубина поиска зависит от этого времени. Альфа-бета алгоритм сможет пройти при поиске <emphasis>вдвое глубже</emphasis> по сравнению с минимаксным полным перебором, а опыт показывает, что применение той же оценочной функции, но на большей глубине приводит к более сильной игре.</p>
     <p>Экономию, получаемую за счет применения альфа-бета алгоритма, можно также выразить в терминах более эффективного коэффициента ветвления дерева поиска (т.е. числа ветвей, исходящих из каждой внутренней вершины). Пусть игровое дерево имеет единый коэффициент ветвления, равный <emphasis>b</emphasis>. Благодаря эффекту отсечения альфа-бета алгоритм просматривает только некоторые из существующих ветвей и тем самым уменьшает коэффициент ветвления. В результате коэффициент <emphasis>b</emphasis> превратится в <emphasis>b</emphasis> (в лучшем случае). В шахматных программах, использующих альфа-бета алгоритм, достигается коэффициент ветвления, равный 6, при наличии 30 различных вариантов хода в каждой позиции. Впрочем, на этот результат можно посмотреть и менее оптимистично: несмотря на применение альфа-бета алгоритма, после каждого продвижения вглубь на один полуход число терминальных поисковых вершин увеличивается примерно в 6 раз.</p>
     <subtitle>Проект</subtitle>
     <p>Рассмотрите какую-нибудь игру двух лиц (например, какой-нибудь нетривиальный вариант крестиков-ноликов). Напишите отношения, задающие правила этой игры (разрешенные ходы и терминальные позиции). Предложите статическую оценочную функцию, пригодную для использования в игровой программе, основанной на альфа-бета алгоритме.</p>
    </section>
    <section>
     <title>
      <p>15.4. Минимаксные игровые программы: усовершенствования и ограничения</p>
     </title>
     <p>Минимаксный принцип и альфа-бета алгоритм лежат в основе многих удачных игровых программ, чаще всего шахматных. Общая схема подобной программы такова: произвести альфа-бета поиск из текущей позиции вплоть до некоторого предела по глубине (диктуемого временными ограничениями турнирных правил). Для оценки терминальных поисковых позиций использовать подобранную специально для данной игры оценочную функцию. Затем выполнить на игровой доске наилучший ход, найденный альфа-бета алгоритмом, принять ответный ход противника и запустить тот же цикл с начала.</p>
     <p>Таким образом, две основных составляющих игровой программы — это альфа-бета алгоритм и эвристическая оценочная функция. Для того, чтобы создать действительно хорошую программу для такой сложной игры, как шахматы, необходимо внести в эту базовую схему много различных усовершенствований. Ниже приводится краткое описание некоторых из стандартных приемов.</p>
     <p>Многое зависит от оценочной функции. Если бы мы располагали абсолютно точной оценочной функцией, мы могли бы ограничить поиск рассмотрением только непосредственных преемников текущей позиции, фактически исключив перебор. Но для таких игр, как шахматы, любая оценочная функция, имеющая практически приемлемую вычислительную сложность, по необходимости будет всего лишь эвристической оценкой. Такая оценка базируется на "статических" свойствах позиции (например, на количестве фигур) и в одних позициях работает надежнее, чем в других. Допустим, например, что мы имеем именно такую оценочную функцию, основанную на соотношении материала, и представим себе позицию, в которой у белых лишний конь. Ясно, что оценка будет в пользу белых. Здесь все в порядке, если позиция "спокойная" и черные не располагают какой-либо сильной угрозой. Но, с другой стороны, если на следующем ходу черные могут взять белого ферзя, то такая оценка может привести к фатальному просмотру из-за своей неспособности к <emphasis>динамическому</emphasis> восприятию позиции. Очевидно, что в спокойных позициях мы можем доверять такой статической оценке в большей степени, чем в активных позициях, когда с каждой из сторон имеются непосредственные угрозы взятия фигур. Поэтому статическую оценку следует использовать только для спокойных позиций. Что же касается активных позиций, то здесь существует такой стандартный прием: следует продолжить поиск из активной позиции за пределы ограничения по глубине и продолжать его до тех пор, пока не встретится спокойная позиция. В частности, таким образом производится просчет разменов фигур в шахматах.</p>
     <p>Еще одно усовершенствование — <emphasis>эвристическое отсечение</emphasis> (ветвей). Целью его является достижение большей предельной глубины поиска за счет отбрасывания менее перспективных продолжений. Этот метод позволяет отсекать ветви в дополнение к тем, которые отсекаются самим альфа-бета алгоритмом. В связи с этим возникает риск пропустить какое-нибудь хорошее продолжение и неправильно вычислить минимаксную оценку.</p>
     <p>Существует еще один прием, называемый <emphasis>последовательным углублением</emphasis>. Программа многократно выполняет альфа-бета поиск сначала до некоторой небольшой глубины, а затем, увеличивая предел по глубине при каждой итерации. Процесс завершается, когда истекает время, отведенное для вычисления очередного хода. Выполняется наилучший ход, найденный при наибольшей глубине, достигнутой программой. Этот метод имеет следующие преимущества:</p>
     <p>• он облегчает контроль времени: в момент, когда время истекает, всегда имеется некоторый ход — лучший из всех, найденных к настоящему моменту;</p>
     <p>• минимаксные оценки, вычисленные во время предыдущей итерации, можно использовать для предварительного упорядочивания позиций в следующей итерации, что помогает альфа-бета алгоритму следовать стратегии "самые сильные ходы — первыми".</p>
     <p>Метод последовательного углубления влечет за собой некоторые накладные расходы (из-за повторного поиска в верхней части игрового дерева), но они незначительны по сравнению c суммарными затратами.</p>
     <p>Для наших программ, основанных на описанной выше схеме, существует проблема, известная как "эффект горизонта". Представьте себе шахматную позицию, в которой программе грозит неминуемая потеря коня, однако эту потерю можно отложить, пожертвовав какую-либо менее ценную фигуру, скажем пешку. Эта немедленная жертва сможет отодвинуть потерю коня за пределы доступной глубины поиска (за "горизонт" программы). Не видя грозящей опасности, программа отдаст предпочтение продолжению с жертвой пешки, чтобы избежать быстрой гибели своего коня. В действительности программа потеряет <emphasis>обе</emphasis> фигуры — и пешку (без необходимости), и коня. Эффект горизонта можно несколько смягчить за счет углубления поиска вплоть до спокойных позиций.</p>
     <p>Существует, однако, более фундаментальное ограничение на возможности минимаксных игровых программ, проистекающее из той ограниченной формы представления знаний, которая в них используется. Это становится особенно заметным при сравнении лучших шахматных программ с шахматными мастерами (людьми). Хорошая программа просматривает миллионы (и даже больше) позиций, прежде чем принимает решение об очередном ходе. Психологические опыты показали, что шахматные мастера, как правило, просматривают десятки (максимум, несколько сотен) позиций. Несмотря на эту явно меньшую производительность, мастера-шахматисты обыгрывают программы без особых усилий. Преимущество их состоит в их знаниях, значительно превосходящих знания шахматных программ. Игры между машинами и сильными шахматистами показали, что огромное превосходство в вычислительной мощности не способно скомпенсировать недостаток знаний.</p>
     <p>Знания в минимаксных игровых программах имеют следующие три основные формы:</p>
     <p>• оценочная функция</p>
     <p>• эвристики для отсечения ветвей</p>
     <p>• эвристики для распознавания спокойных позиций</p>
     <p>Оценочная функция сводит все разнообразные аспекты игровой ситуации к одному числу, и это упрощение может нанести вред. В противоположность этому хороший игрок обладает пониманием позиции, охватывающим многие "измерения". Вот пример из области шахмат: оценочная функция оценивает позицию как равную и выдает значение 0. Оценка той же позиции, данная мастером-шахматистом, может быть значительно более информативной, а также может указывать на дальнейший ход игры, например: у белых лишняя пешка, но черные имеют неплохие атакующие возможности, что компенсирует материальный перевес, следовательно, шансы равны.</p>
     <p>Минимаксные шахматные программы часто хорошо проявляют себя в острой тактической борьбе, когда решающее значение имеет точный просчет форсированных вариантов. Их слабости обнаруживаются в спокойных позициях, так как они не способны к долговременному планированию, преобладающему при медленной, стратегической игре. Из-за отсутствия плана создается внешнее впечатление, что программа все время перескакивает с одной идеи" на другую. Особенно это заметно в эндшпилях.</p>
     <p>В оставшейся части главы мы рассмотрим еще один подход к программированию игр, основанный на внесении в программу знаний о типовых ситуациях при помощи так называемых "советов".</p>
    </section>
    <section>
     <title>
      <p>15.5. Знания о типовых ситуациях и механизм "советов"</p>
     </title>
     <section>
      <p>В этом разделе рассматривается метод представления знаний о конкретной игре с использованием семейства Языков Советов. Языки Советов (Advice Languages) дают возможность пользователю декларативным способом описывать, какие идеи следует использовать в тех или иных типовых ситуациях. Идеи формулируются в терминах целей и средств, необходимых для их достижения. Интерпретатор Языка Советов определяет при помощи перебора, какая идея "работает" в данной ситуации.</p>
     </section>
     <section>
      <title>
       <p>15.5.1. Цели и ограничения на ходы</p>
      </title>
      <p>Основное понятие Языка Советов — "элементарный совет". Элементарный совет содержит указание о том, что следует делать (или <emphasis>пытаться</emphasis> делать) в некоторой типовой ситуации. Совет выражается в терминах тех <emphasis>целей</emphasis>, которые необходимо достичь, и тех <emphasis>средств</emphasis>, которые следует применять для этого. Мы называем участников игры "игроком" и "противником"; совет всегда относится к "игроку". Каждый элементарный совет имеет следующие четыре составные части:</p>
      <p>• <emphasis>главная цель</emphasis>: цель, к которой нужно стремиться;</p>
      <p>• <emphasis>цель-поддержка</emphasis>: цель, которая должна постоянно удовлетворяться в процессе достижения главной цели;</p>
      <p>• <emphasis>ограничения на ходы игрока</emphasis>: предикат, определяющий некоторое подмножество ходов из всех разрешенных ходов игрока (ходы, представляющие интерес с точки зрения достижения указанных целей).</p>
      <p>• <emphasis>ограничения на ходы противника</emphasis>: предикат, выбирающий ходы, которые должен рассмотреть противник (ходы, препятствующие достижению указанных целей).</p>
      <p>Рассмотрим, например, шахматный эндшпиль "король и пешка против короля". Здесь применима следующая очевидная идея: провести пешку в ферзи, продвигая ее вперед. В форме совета это выражается так:</p>
      <p>• <emphasis>главная цель</emphasis>: провести пешку;</p>
      <p>• <emphasis>цель-поддержка</emphasis>: не потерять пешку;</p>
      <p>• <emphasis>ходы игрока</emphasis>: продвигать пешку;</p>
      <p>• <emphasis>ходы противника</emphasis>: приближаться королем к пешке. </p>
     </section>
     <section>
      <title>
       <p>15.5.2. Выполнимость совета</p>
      </title>
      <p>Мы говорим, что элементарный совет <emphasis>выполним</emphasis> в данной позиции, если игрок может форсированным образом достигнуть главной цели, указанной в совете, при условии, что:</p>
      <p>(1) ни разу не нарушается цель-поддержка;</p>
      <p>(2) все ходы игрока удовлетворяют наложенным на них ограничениям;</p>
      <p>(3) противнику разрешено делать только те ходы, которые предусмотрены соответствующими ограничениями.</p>
      <p>С выполнимостью элементарного совета связано понятие <emphasis>форсированного дерева</emphasis>. Форсированное дерево задает детальную стратегию, которая гарантирует достижение главной цели при выполнении всех ограничений, содержащихся в элементарном совете. Таким образом, форсированное дерево указывает, как именно должен ходить игрок при любых ответах противника. Более точно, форсированное дерево T для заданной позиции P и элементарного совета А есть такое поддерево дерева игры, что</p>
      <p>• корень дерева T — позиция P;</p>
      <p>• все позиции из T удовлетворяют цели-поддержке;</p>
      <p>• все терминальные позиции из T удовлетворяют главной цели (что, однако, неверно ни для одной внутренней вершины);</p>
      <p>• для каждой внутренней позиции игрока в дереве T указан только один ход, причем он удовлетворяет ограничениям на ходы игрока;</p>
      <p>• из каждой внутренней позиции противника исходят все ходы противника (удовлетворяющие соответствующим ограничениям).</p>
      <p>Каждый элементарный совет можно рассматривать как описание некоторой небольшой специальной игры, имеющей следующие правила. Участникам игры разрешено ходить в пределах ограничений, наложенных на их ходы; позиция, не удовлетворяющая цели-поддержке, считается выигрышем "противника". Нетерминальная позиция считается выигранной с точки зрения игрока, если данный элементарный совет в ней выполним. Таким образом, для того, чтобы выиграть в этой игре, игрок должен следовать стратегии, задаваемой форсированным деревом. </p>
     </section>
     <section>
      <title>
       <p>15.5.3. Правила и таблицы советов</p>
      </title>
      <p>В Языках Советов отдельные элементарные советы объединяются в полную схему представления знаний, имеющую следующую иерархическую структуру. Элементарный совет является частью "если-то"-правила. Набор "если-то"-правил образует <emphasis>таблицу советов</emphasis>. Множество таблиц советов имеет структуру иерархической сети. Каждая таблица советов выполняет роль эксперта в своей узкой области и работает с какой-нибудь специфической подзадачей. Примером такого специализированного эксперта может служить таблица советов, содержащая знания о том, как поставить мат королем и ладьей. Эта таблица вызывается в том случае, когда в процессе игры возникает соответствующее окончание.</p>
      <p>Мы рассмотрим здесь упрощенную версию Языка Советов, допускающую только одну таблицу советов. Будем называть эту версию Язык Советов 0 или, для краткости, AL0 (Advice Language 0). Ниже описывается структура языка AL0, синтаксически специально приспособленная для удобной реализации на Прологе.</p>
      <p>Программа на AL0 называется <emphasis>таблицей советов</emphasis>. Таблица советов представляет из себя <emphasis>упорядоченное</emphasis> множество "если-то"-правил. Каждое правило имеет вид:</p>
      <p><code>ИмяПравила: если Условие то СписокСоветов</code></p>
      <p><code>Условие</code> — это логическое выражение, состоящее из имен предикатов, соединенных между собой логическими связками <code>и</code>, <code>или</code>, <code>не</code>.  <code>СписокСоветов</code> — список имен элементарных советов. Приведем пример правила под названием "правило_края" из окончания "король и ладья против короля":</p>
      <p><code>правило_края:</code></p>
      <p><code> если король_противника_на_краю и короли_рядом</code></p>
      <p><code> то [мат_2, потеснить, приблизиться,</code></p>
      <p><code>     сохранить_простр, отделить].</code></p>
      <p>В этом правиле говорится: если в текущей позиции король противника находится на краю доски, а король игрока расположен близко к королю противника (точнее, расстояние между королями меньше четырех клеток), то попытаться выполнить в указанном порядке предпочтения следующие советы: "мат_2", "потеснить", "приблизиться", "сохранить_простр", "отделить". Элементарные советы расположены в порядке убывания их "притязаний" на успех: сначала попытаться поставить мат в два хода, если не получится — "потеснить" короля противника в угол и т.д. Обратите внимание на то, что при соответствующем определении операторов наше правило станет синтаксически корректным предложением Пролога.</p>
      <p>Для представления элементарных советов в виде прологовских предложений предназначен еще один формат:</p>
      <p><code>совет( ИмяСовета,</code></p>
      <p><code>       ГлавнаяЦель:</code></p>
      <p><code>       ЦельПоддержка:</code></p>
      <p><code>       ХодыИгрока:</code></p>
      <p><code>       ХодыПротивника).</code></p>
      <p>Цели представляются как выражения, состоящие из имен предикатов и логических связок <code>и</code>, <code>или</code>, <code>не</code>.  Ограничения на ходы сторон — это тоже выражения, состоящие из имен предикатов и связок <code>и</code> и <code>затем</code>: связка <code>и</code> имеет обычный логический смысл, а <code>затем</code> задает порядок. Например, ограничение, имеющее вид</p>
      <p><code>Огр1 затем Огр2</code></p>
      <p>означает: сначала рассмотреть ходы, удовлетворяющие ограничению <code>Oгp1</code>, а затем — ходы, удовлетворяющие <code>Огр2</code>.</p>
      <p>Например, элементарный совет, относящийся к мату в два хода в окончании "король и ладья против короля", записанный в такой синтаксической форме, имеет вид:</p>
      <p><code>совет( мат_2,</code></p>
      <p><code>       мат:</code></p>
      <p><code>       не потеря_ладьи:</code></p>
      <p><code>       (глубина = 0) и разреш затем</code></p>
      <p><code>       (глубина = 2) и ход_шах :</code></p>
      <p><code>       (глубина = 1) и разреш ).</code></p>
      <p>Здесь главная цель — <code>мат</code>, цель-поддержка <code>не потеря_ладьи</code>. Ограничение на ходы игрока означает: на глубине 0 (т.е. в текущей позиции) попробовать любой разрешенный ход и затем на глубине 2 (следующий ход игрока) пробовать только ходы с шахом. Глубина измеряется в полуходах. Ограничение на ходы противника: любой разрешенный ход на глубине 1.</p>
      <p>В процессе игры таблица советов используется многократно вплоть до окончания игры, при этом выполняется следующий основной цикл: построить форсированное дерево, затем играть в соответствии с этим деревом, пока не произойдет выход из него; построить другое форсированное дерево и т.д. Форсированное дерево строится каждый раз таким образом: берется текущая позиция <code>Поз</code> и просматриваются одно за другим все правила таблицы советов; для каждого правила сопоставляется <code>Поз</code> с предварительным условием этого правила и просмотр прекращается, когда будет обнаружено правило, для которого <code>Поз</code> удовлетворяет предварительному условию. В этом случае надо рассмотреть список советов найденного правила: обработать элементарные советы один за другим, пока не будет построено форсированное дерево, представляющее собой детальную стратегию игры в этой позиции.</p>
      <p>Следует обратить внимание на существенность того порядка, в котором перечисляются правила в таблице советов. Правило, которое реально используется, — это первое из тех правил, предварительные условия которых согласуются с текущей позицией. Для любой возможной позиции должно существовать по крайней мере одно такое правило. Из него берется список советов, и первый из выполнимых советов списка используется в игре.</p>
      <p>Таким образом, таблица советов это программа в высшей степени непроцедурного характера. Интерпретатор языка AL0 принимает на входе некоторую позицию, а затем, "исполняя" таблицу советов, строит форсированное дерево, определяющее стратегию игры в этой позиции.</p>
     </section>
    </section>
    <section>
     <title>
      <p>15.6. Программа на языке  AL0 для игры в шахматном эндшпиле</p>
     </title>
     <section>
      <p>При реализации какой-либо игровой программы на языке  AL0  ее можно для удобства разбить на три модуля:</p>
      <p>(1) интерпретатор языка  AL0,</p>
      <p>(2) таблица советов на языке  AL0,</p>
      <p>(3) библиотека предикатов, используемых в таблице советов (в том числе предикаты, задающие правила игры).</p>
      <p>Эта структура соответствует обычной структуре системы, основанной на знаниях:</p>
      <p>• Интерпретатор  AL0  выполняет функцию машины логического вывода.</p>
      <p>• Таблица советов вместе с библиотекой предикатов образует базу знаний.</p>
     </section>
     <section>
      <title>
       <p>15.6.1. Миниатюрный интерпретатор языка <emphasis>AL0</emphasis></p>
      </title>
      <p>Реализация на Прологе миниатюрного, не зависящего от конкретной игры интерпретатора языка AL0 показана на рис. 15.6. Эта программа осуществляет также взаимодействие с пользователем во время игры. Центральная задача этой программы — использовать знания, записанные в таблице советов, то есть интерпретировать программу на языке советов AL0 с целью построения форсированных деревьев и их "исполнения" в процессе игры. Базовый алгоритм порождения форсированных деревьев аналогичен поиску с предпочтением в И/ИЛИ-графах гл. 13, при этом форсированное дерево соответствует решающему И/ИЛИ-дереву. Этот алгоритм также напоминает алгоритм построения решающего дерева ответа на вопрос пользователя, применявшийся в оболочке экспертной системы (гл. 14).</p>
      <p>Программа на рис. 15.6 составлена в предположении, что она играет белыми, а ее противник — черными. Программа запускается процедурой</p>
      <p><code>игра( Поз)</code></p>
      <p>где <code>Поз</code> — выбранная начальная позиция. Если в позиции <code>Поз</code> ходит противник, то программа принимает его ход, в противном случае — "консультируется" с таблицей советов, приложенной к программе, порождает форсированное дерево и делает свой ход в соответствии с этим деревом. Так продолжается до окончания игры, которое обнаруживает предикат <code>конец_игры</code> (например, если поставлен мат).</p>
      <empty-line/>
      <p><code>% Миниатюрный интерпретатор языка AL0</code></p>
      <p><code>%</code></p>
      <p><code>% Эта программа играет, начиная с заданной позиции,</code></p>
      <p><code>% используя знания, записанные на языке AL0</code></p>
      <p><code>:- op( 200, xfy, :).</code></p>
      <p><code>:- op( 220, xfy, ..).</code></p>
      <p><code>:- op( 185, fx, если).</code></p>
      <p><code>:- op( 190, xfx, то).</code></p>
      <p><code>:- op( 180, xfy, или).</code></p>
      <p><code>:- op( 160, xfy, и).</code></p>
      <p><code>:- op( 140, fx, не).</code></p>
      <empty-line/>
      <p><code>игра( Поз) :-         % Играть, начиная с Поз</code></p>
      <p><code> игра( Поз, nil).</code></p>
      <p><code>  % Начать с пустого форсированного дерева</code></p>
      <p><code>игра( Поз, ФорсДер) :-</code></p>
      <p><code> отобр( Поз),</code></p>
      <p><code> ( конец_игры( Поз),  % Конец игры?</code></p>
      <p><code>   write( 'Конец игры'), nl, !;</code></p>
      <p><code> сделать_ход( Поз, ФорсДер, Поз1, ФорсДер1), !,</code></p>
      <p><code> игра( Поз1, ФорсДер1) ).</code></p>
      <empty-line/>
      <p><code>% Игрок ходит в соответствии с форсированным деревом</code></p>
      <p><code>сделать_ход( Поз, Ход .. ФДер1, Поз1, ФДер1) :-</code></p>
      <p><code> чей_ход( Поз, б),    % Программа играет белыми</code></p>
      <p><code> разрход( Поз, Ход, Поз1),</code></p>
      <p><code> показать_ход( Ход).</code></p>
      <empty-line/>
      <p><code>% Прием хода противника</code></p>
      <p><code>сделать_ход( Поз, ФДер, Поз1, ФДер1) :-</code></p>
      <p><code> чей_ход( Поз, ч),</code></p>
      <p><code> write( 'Ваш ход:'),</code></p>
      <p><code> read( Ход),</code></p>
      <p><code> ( разрход( Поз, Ход, Поз1),</code></p>
      <p><code>   поддер( ФДер, Ход, ФДер1), !;</code></p>
      <p><code>    % Вниз по форс. дереву</code></p>
      <p><code> write( 'Неразрешенный ход'), nl,</code></p>
      <p><code> сделать_ход( Поз, ФДер, Поз1, ФДер1) ).</code></p>
      <empty-line/>
      <p><code>% Если текущее форсированное дерево пусто, построить новое</code></p>
      <p><code>сделать_ход( Поз, nil, Поз1, ФДер1) :-</code></p>
      <p><code> чей_ход( Поз, б),</code></p>
      <p><code> восст_глуб( Поз, Поз0),</code></p>
      <p><code>  % Поз0 = Поз с глубиной 0</code></p>
      <p><code> стратегия( Поз0, ФДер), !,</code></p>
      <p><code>  % Новое форсированное дерево</code></p>
      <p><code> сделать_ход( Поз0, ФДер, Поз1, ФДер1).</code></p>
      <empty-line/>
      <p><code>% Выбрать форсированное поддерево, соответствующее Ход'у</code></p>
      <p><code>поддер( ФДеревья, Ход, Фдер) :-</code></p>
      <p><code> принадлежит( Ход . . Фдер, ФДеревья), !.</code></p>
      <p><code>поддер( _, _, nil).</code></p>
      <empty-line/>
      <p><code>стратегия( Поз, ФорсДер) :-</code></p>
      <p><code>  % Найти форс. дерево для Поз</code></p>
      <p><code> Прав : если Условие то СписСов,</code></p>
      <p><code>  % Обращение к таблице советов</code></p>
      <p><code> удовл( Условие, Поз, _ ), !,</code></p>
      <p><code>  % Сопоставить Поз с предварительным условием</code></p>
      <p><code> принадлежит( ИмяСовета, СписСов),</code></p>
      <p><code>  % По очереди попробовать элем. советы</code></p>
      <p><code> nl, write( 'Пробую'), write( ИмяСовета),</code></p>
      <p><code> выполн_совет( ИмяСовета, Поз, ФорсДер), !.</code></p>
      <empty-line/>
      <p><code>выполн_совет( ИмяСовета, Поз, Фдер) :-</code></p>
      <p><code> совет( ИмяСовета, Совет),</code></p>
      <p><code>  % Найти элементарный совет</code></p>
      <p><code> выполн( Совет, Поз, Поз, ФДер).</code></p>
      <empty-line/>
      <p><code>% "выполн" требует две позиции для сравнивающих предикатов</code></p>
      <p><code>выполн( Совет, Поз, КорнПоз, ФДер) :-</code></p>
      <p><code> поддержка( Совет, ЦП),</code></p>
      <p><code> удовл( ЦП, Поз, КорнПоз),</code></p>
      <p><code>  % Сопоставить Поз с целью-поддержкой</code></p>
      <p><code> выполн1( Совет, Поз, КорнПоз, ФДер).</code></p>
      <empty-line/>
      <p><code>выполн1( Совет, Поз, КорнПоз, nil) :-</code></p>
      <p><code> главцель( Совет, ГлЦ),</code></p>
      <p><code> удовл( ГлЦ, Поз, КорнПоз), !.</code></p>
      <p><code>  % Главная цель удовлетворяется</code></p>
      <p><code>выполн1( Совет, Поз, КорнПоз, Ход .. ФДеревья) :-</code></p>
      <p><code> чей_ход( Поз, б), !, % Программа играет белыми</code></p>
      <p><code> ходы_игрока( Совет, ХодыИгрока),</code></p>
      <p><code>  % Ограничения на ходы игрока</code></p>
      <p><code> ход( ХодыИгрока, Поз, Ход, Поз1),</code></p>
      <p><code>  % Ход, удовлетворяющий ограничению</code></p>
      <p><code> выполн( Совет, Поз1, КорнПоз, ФДеревья).</code></p>
      <p><code>выполн1( Совет, Поз, КорнПоз, ФДеревья) :-</code></p>
      <p><code> чей_ход( Поз, ч), !, % Противник играет черными</code></p>
      <p><code> ходы_противника( Совет, ХодыПр),</code></p>
      <p><code> bagof ( Ход .. Поз1, ход( ХодыПр, Поз, Ход, Поз1), ХПспис),</code></p>
      <p><code> выполн_все( Совет, ХПспис, КорнПоз, ФДеревья).</code></p>
      <p><code>  % Совет выполним во всех преемниках Поз</code></p>
      <empty-line/>
      <p><code>выполн_все( _, [], _, []).</code></p>
      <p><code>выполн_все( Совет, [Ход .. Поз | ХПспис], КорнПоз,</code></p>
      <p><code> [Ход .. ФД | ФДД] ) :-</code></p>
      <p><code> выполн( Совет, Поз, КорнПоз, ФД),</code></p>
      <p><code>выполн_все( Совет, ХПспис, КорнПоз, ФДД).</code></p>
      <empty-line/>
      <p><code>% Интерпретация главной цели и цели-поддержки:</code></p>
      <p><code>% цель - это И / ИЛИ / НЕ комбинация. имен предикатов</code></p>
      <p><code>удовл( Цель1 и Цель2, Поз, КорнПоз) :- !,</code></p>
      <p><code> удовл( Цель1, Поз, КорнПоз),</code></p>
      <p><code> удовл( Цель2, Поз, КорнПоз).</code></p>
      <p><code>удовл( Цель1 или Цель2, Поз, КорнПоз) :- !,</code></p>
      <p><code> ( удовл( Цель1, Поз, КорнПоз);</code></p>
      <p><code>   удовл( Цель2, Поз, КорнПоз) ).</code></p>
      <p><code>удовл( не Цель, Поз, КорнПоз) :- !,</code></p>
      <p><code> not удовл( Цель, Поз, КорнПоз ).</code></p>
      <p><code>удовл( Пред, Поз, КорнПоз) :-</code></p>
      <p><code> ( Усл =.. [Пред, Поз];</code></p>
      <p><code>  % Большинство предикатов не зависит от КорнПоз</code></p>
      <p><code>   Усл =.. [Пред, Поз, КорнПоз] ),</code></p>
      <p><code> call( Усл).</code></p>
      <empty-line/>
      <p><code>% Интерпретация ограничений на ходы</code></p>
      <p><code>ход( Ходы1 и Ходы2, Поз, Ход, Поз1) :- !,</code></p>
      <p><code> ход( Ходы1, Поз, Ход, Поз1),</code></p>
      <p><code> ход( Ходы2, Поз, Ход, Поз1).</code></p>
      <p><code>ход( Ходы1 затем Ходы2, Поз, Ход, Поз1) :- !,</code></p>
      <p><code> ( ход( Ходы1, Поз, Ход, Поз1);</code></p>
      <p><code>   ход( Ходы2, Поз, Ход, Поз1) ).</code></p>
      <empty-line/>
      <p><code>% Доступ к компонентам элементарного совета</code></p>
      <p><code>главцель( ГлЦ : _, ГлЦ).</code></p>
      <empty-line/>
      <p><code>поддержка( ГлЦ : ЦП : _, ЦП).</code></p>
      <empty-line/>
      <p><code>ходы_игрока( ГлЦ : ЦП : ХодыИгрока : _, Ходы Игрока).</code></p>
      <empty-line/>
      <p><code>ходы_противника( ГлЦ : ЦП: ХодыИгр : ХодыПр :_,</code></p>
      <p><code> ХодыПр).</code></p>
      <empty-line/>
      <p><code>принадлежит( X, [X | Спис]).</code></p>
      <p><code>принадлежит( X, [Y | Спис]) :-</code></p>
      <p><code> принадлежит( X, Спис).</code></p>
      <p><strong>Рис. 15.6.</strong> Миниатюрный интерпретатор языка AL0.</p>
      <empty-line/>
      <p>Форсированное дерево — это дерево ходов, представленное в программе следующей структурой:</p>
      <p><code>Ход .. [ Ответ1 .. Фдер1, Ответ2 .. Фдер2, ... ]</code></p>
      <p>Здесь "<code>..</code>" — инфиксный оператор; <code>Ход</code> — первый ход "игрока"; <code>Ответ1</code>, <code>Ответ2</code>, … — возможные ответы противника; <code>Фдер1</code>, <code>Фдер2</code>, … — форсированные поддеревья для каждого из этих ответов.</p>
     </section>
     <section>
      <title>
       <p>15.6.2. Программа на языке советов для эндшпиля "король и ладья против короля"</p>
      </title>
      <p>Общий принцип достижения выигрыша королем и ладьей против единственной фигуры противника, короля, состоит в том, чтобы заставить короля отступить к краю доски или, при необходимости, загнать его в угол, а затем поставить мат в несколько ходов. В детальном изложении эта стратегия выглядит так:</p>
      <p>Повторять циклически, пока не будет поставлен мат (постоянно проверяя, что не возникла патовая позиция и что нет нападения на незащищенную ладью):</p>
      <p>(1) Найти способ поставить королю противника мат в два хода.</p>
      <p>(2) Если не удалось, то найти способ уменьшить ту область доски, в которой король противника "заперт" под воздействием ладьи.</p>
      <p>(3) Если и это не удалось, то найти способ приблизить своего короля к королю противника.</p>
      <p>(4) Если ни один из элементарных советов 1, 2, или 3 не выполним, то найти способ сохранить все имеющиеся к настоящему моменту "достижения" в смысле (2) и (3) (т.е. сделать выжидающий ход).</p>
      <p>(5) Если ни одна из целей 1, 2, 3 или 4 не достижима, то найти способ получить позицию, в которой ладья занимает вертикальную или горизонтальную линию, отделяющую одного короля от другого.</p>
      <p>Описанные выше принципы реализованы во всех деталях в таблице советов на языке AL0, показанной на рис. 15.7. Эта таблица может работать под управлением интерпретатора рис. 15.6. Рис. 15.8 иллюстрирует смысл некоторых из предикатов, использованных в таблице советов, а также показывает, как эта таблица работает.</p>
      <p>В таблице используются следующие предикаты:</p>
      <p><emphasis>Предикаты целей</emphasis></p>
      <table>
       <tr>
        <td><code>мат</code></td>
        <td>мат королю противника</td>
       </tr>
       <tr>
        <td><code>пат</code></td>
        <td>пат королю противника</td>
       </tr>
       <tr>
        <td><code>потеря_ладьи</code></td>
        <td>король противника может взять ладью</td>
       </tr>
       <tr>
        <td><code>ладья_под_боем</code></td>
        <td>король противника может напасть на ладью прежде, чем наш король сможет ее защитить</td>
       </tr>
       <tr>
        <td><code>уменьш_простр</code></td>
        <td>уменьшилось "жизненное пространство" короля противника, ограничиваемое ладьей</td>
       </tr>
       <tr>
        <td><code>раздел</code></td>
        <td>ладья занимает вертикальную или горизонтальную линию, разделяющую королей</td>
       </tr>
       <tr>
        <td><code>ближе_к_клетке</code></td>
        <td>наш король приблизился к "критической клетке" (см. рис. 15.9), т.е. манхеттеновское расстояние до нее уменьшилось</td>
       </tr>
       <tr>
        <td><code>l_конфиг</code></td>
        <td>"L-конфигурация" (рис. 15.9)</td>
       </tr>
       <tr>
        <td><code>простр_больше_2</code></td>
        <td>"жизненное пространство" короля противника занимает больше двух клеток</td>
       </tr>
      </table>
      <p><emphasis>Предикаты, ограничивающие ходы</emphasis></p>
      <table>
       <tr>
        <td><code>глубина = N</code></td>
        <td>ход на глубине N дерева поиска</td>
       </tr>
       <tr>
        <td><code>разреш</code></td>
        <td>любой разрешенный ход</td>
       </tr>
       <tr>
        <td><code>ход_шах</code></td>
        <td>ход, объявляющий шах</td>
       </tr>
       <tr>
        <td><code>ход_ладьей</code></td>
        <td>ход ладьей</td>
       </tr>
       <tr>
        <td><code>нет_хода</code></td>
        <td>ни один ход не подходит</td>
       </tr>
       <tr>
        <td><code>сначала_диаг</code></td>
        <td>ход королем, преимущественно по диагонали</td>
       </tr>
      </table>
      <empty-line/>
      <p><code>% Окончание "король и ладья против короля" на языке AL0</code></p>
      <p><code>% Правила</code></p>
      <p><code>правило_края:</code></p>
      <p><code> если король_противника_на_краю и короли_рядом</code></p>
      <p><code> то [мат_2, потеснить, приблизиться,</code></p>
      <p><code>     сохранить_простр, отделить_2, отделить_3].</code></p>
      <empty-line/>
      <p><code>иначе_правило</code></p>
      <p><code> если любая_поз</code></p>
      <p><code> то [ потеснить, приблизиться, сохранить_простр,</code></p>
      <p><code>      отделить_2, отделить_3].</code></p>
      <empty-line/>
      <p><code>% Элементарные советы</code></p>
      <p><code>совет( мат_2,</code></p>
      <p><code>       мат :</code></p>
      <p><code>       не потеря_ладьи и король_противника_на_краю:</code></p>
      <p><code>       (глубина = 0) и разреш</code></p>
      <p><code>       затем (глубина = 2) и ход_шах :</code></p>
      <p><code>       (глубина = 1) и разреш ).</code></p>
      <empty-line/>
      <p><code>совет( потеснить,</code></p>
      <p><code>       уменьш_простр и не ладья_под_боем и</code></p>
      <p><code>       раздел и не пат :</code></p>
      <p><code>       не потеря_ладьи :</code></p>
      <p><code>       (глубина = 0) и ход_ладьей :</code></p>
      <p><code>       нет_хода ).</code></p>
      <empty-line/>
      <p><code>совет( приблизиться,</code></p>
      <p><code>       ближе _к_клетке и не ладья_под_боем и</code></p>
      <p><code>       (раздел или l_конфиг) и</code></p>
      <p><code>       (простр_больше_2 или не наш_король_на_краю):</code></p>
      <p><code>       не потеря_ладьи :</code></p>
      <p><code>       (глубина = 0) и сначала_диаг :</code></p>
      <p><code>       нет_хода ).</code></p>
      <empty-line/>
      <p><code>совет( сохранить_простр,</code></p>
      <p><code>       ход_противника и не ладья_под_боем и раздел</code></p>
      <p><code>       и не_дальше_от_ладьи и</code></p>
      <p><code>       (простр_больше_2 или не наш_король_на_краю):</code></p>
      <p><code>       не потеря_ладьи :</code></p>
      <p><code>       (глубина = 0) и сначала_диаг :</code></p>
      <p><code>       нет_хода ).</code></p>
      <empty-line/>
      <p><code>совет( отделить_2,</code></p>
      <p><code>       ход_противника и раздел и не ладья_под_боем:</code></p>
      <p><code>       не потеря_ладьи :</code></p>
      <p><code>       (глубина &lt; 3) и разреш :</code></p>
      <p><code>       (глубина &lt; 2) и разреш ).</code></p>
      <empty-line/>
      <p><code>совет( отделить_3,</code></p>
      <p><code>       ход_противника и раздел и не ладья_под_боем:</code></p>
      <p><code>       не потеря_ладьи :</code></p>
      <p><code>       (глубина &lt; 5) и разреш :</code></p>
      <p><code>       (глубина &lt; 4) и разреш ).</code></p>
      <p><strong>Рис. 15.7.</strong> Таблица советов на языке AL0 для окончания "король и ладья против короля". Таблица состоит из двух правил и шести элементарных советов.</p>
      <empty-line/>
      <image l:href="#_109.png"/>
      <p><strong>Рис. 15.8.</strong> Фрагмент шахматной партии, полученный с использованием таблицы советов рис. 15.7 и иллюстрирующий применение стратегии оттеснения короля в угол доски. В этой последовательности ходов выполнялись элементарные советы: <code>сохранить_ простр</code> (выжидающий ход, сохраняющий "жизненное пространство" черного короля) и <code>потеснить</code> (ход, сокращающий "жизненное пространство"). Область, в которой заключен черный король, выделена штриховкой. После выполнения последнего совета <code>потеснить</code> эта область сократилась с восьми до шести клеток.</p>
      <image l:href="#_110.png"/>
      <p><strong>Рис. 15.9.</strong> (а) "Критическая клетка" отмечена крестиком. Она используется при маневрировании с целью оттеснить черного короля. Белый король приближается к "критической клетке", двигаясь, как указано на рисунке. (б) Три фигуры образуют конфигурацию, напоминающую букву L.</p>
      <p>Аргументами этих предикатов являются либо позиции (в предикатах целей), либо ходы (в предикатах, ограничивающих ходы). Предикаты целей могут иметь один или два аргумента. Первый из аргументов — это всегда текущая вершина поиска; второй аргумент (если он имеется) — корневая вершина дерева поиска. Второй аргумент необходим в так называемых сравнивающих предикатах, которые сравнивают корневую и текущую позиции в том или ином отношении. Например, предикат <code>уменьш_простр</code> проверяет, сократилось ли "жизненное пространство" короля противника (рис. 15.8). Эти предикаты вместе с шахматными правилами (применительно к окончанию "король и ладья против короля"), а также процедура для отображения текущего состояния игровой доски (<code>отобр( Поз)</code>) запрограммированы на рис. 15.10.</p>
      <p>На рис. 15.8 показано, как играет наша программа, основанная на механизме советов. При продолжении игры из последней позиции рис. 15.8 она могла бы протекать так, как в приведенном ниже варианте (в предположении, что "противник" ходит именно так, как указано). Здесь использована алгебраическая шахматная нотация, в которой вертикальные линии пронумерованы, как 'а', 'b', 'с', … а горизонтальные — как 1, 2, 3, …. Например, ход ЧК b7 означает: передвинуть черного короля на клетку, расположенную на пересечении вертикальной линии 'b' с горизонтальной линией 7.</p>
      <p>…        ЧК b7</p>
      <p>БК d5  ЧК с7</p>
      <p>БК с5  ЧК b7</p>
      <p>БЛ с6  ЧК а7</p>
      <p>БЛ b6  ЧК а8</p>
      <p>БК b5  ЧК а7</p>
      <p>БК с6  ЧК а8</p>
      <p>БК с7  ЧК а7</p>
      <p>БЛ с6  ЧК а8</p>
      <p>БЛ а6  мат</p>
      <p>Теперь уместно задать некоторые вопросы. Во-первых, является ли наша программа-советчик <emphasis>корректной</emphasis> в том смысле, что она ставит мат при любом варианте защиты со стороны противника и при любой начальной позиции, в которой на доске король и ладья против короля? В статье Bratko (1978) приведено формальное доказательство того, что таблица советов, практически совпадающая с таблицей рис. 15.7, действительно является корректной в указанном смысле.</p>
      <p>Другой возможный вопрос: является ли программа оптимальной, то есть верно ли, что она ставит мат за минимальное число ходов? Нетрудно показать на примерах, что игру нашей программы в этом смысле нельзя назвать оптимальной. Известно, что оптимальный вариант в этом окончании (т.е. предполагающий оптимальную игру с обеих сторон) имеет длину не более 16 ходов. Хотя наша таблица советов и далека от этого оптимума, было показано, что число, ходов наверняка не превосходит 50. Это важный результат в связи с тем, что в шахматах существует "правило 50-ти ходов": в эндшпилях типа "король и ладья против короля" противник, имеющий преимущество, должен поставить, мат не более, чем за 50 ходов; иначе может быть объявлена ничья.</p>
      <empty-line/>
      <p><code>% Библиотека предикатов для окончания</code></p>
      <p><code>% "король и ладья против короля"</code></p>
      <empty-line/>
      <p><code>% Позиция представлена стуктурой:</code></p>
      <p><code>% ЧейХод..Бх : Бу..Лх : Лу..Чх : Чу..Глуб</code></p>
      <p><code>% ЧейХод - с чьей стороны ход в этой позиции ('б' или 'ч')</code></p>
      <p><code>% Бх, Бу - координаты белого короля</code></p>
      <p><code>% Лх, Лу - координаты белой ладьи</code></p>
      <p><code>% Чх, Чу - координаты черного короля</code></p>
      <p><code>% Глуб - глубина, на которой находится эта позиция в дереве</code></p>
      <p><code>% поиска</code></p>
      <empty-line/>
      <p><code>% Отношения выбора элементов позиции</code></p>
      <p><code>чей_ход( ЧейХод.._, ЧейХод).</code></p>
      <p><code>бк( _..БК.._, БК).                % Белый король</code></p>
      <p><code>бл( _.._..БЛ.._, БЛ).             % Белая ладья</code></p>
      <p><code>чк( _.._.._..ЧК.._, ЧК).          % Черный король</code></p>
      <p><code>глуб( _.._.._.._..Глуб, Глуб).</code></p>
      <p><code>восст_глуб( ЧХ..Б..Л..Ч..Г, ЧХ..Б..Л..Ч..0).</code></p>
      <p><code>  % Формируется копия позиции, глубина устанавливается в 0</code></p>
      <empty-line/>
      <p><code>% Некоторые отношения между клетками доски</code></p>
      <p><code>сосед_чсл( N, N1) :- % Соседнее число "в пределах доски"</code></p>
      <p><code> ( N1 is N + 1;</code></p>
      <p><code>   N1 is N - 1 ),</code></p>
      <p><code> внутри( N1).</code></p>
      <empty-line/>
      <p><code>внутри( N) :-</code></p>
      <p><code> N &gt; 0, N &lt; 9.</code></p>
      <empty-line/>
      <p><code>сосед_диаг( X : Y, X1 : Y1) :-</code></p>
      <p><code>  % Соседние клетки по диагонали</code></p>
      <p><code> сосед_чсл( X, X1 ), сосед_чсл( Y, Y1).</code></p>
      <empty-line/>
      <p><code>сосед_верт( X : Y, X : Y1) :-</code></p>
      <p><code>  % Соседние клетки по вертикали</code></p>
      <p><code> сосед_чсл( Y, Y1).</code></p>
      <empty-line/>
      <p><code>сосед_гор( X : Y, X1 : Y) :-</code></p>
      <p><code>  % Соседние клетки по горизонтали</code></p>
      <p><code> сосед_чсл( X, X1).</code></p>
      <empty-line/>
      <p><code>сосед( S, S1) :-</code></p>
      <p><code>  % Соседние клетки (предпочтение - диагонали)</code></p>
      <p><code> сосед_диаг( S, S1);</code></p>
      <p><code> сосед_гор( S, S1);</code></p>
      <p><code> сосед_верт( S, S1).</code></p>
      <empty-line/>
      <p><code>конец_игры( Поз) :-</code></p>
      <p><code> мат( Поз).</code></p>
      <empty-line/>
      <p><code>% Предикаты, ограничивающие ходы</code></p>
      <p><code>% Специализированное генераторы ходов вида:</code></p>
      <p><code>% ход( Ограничение, Поз, Ход, Поз1)</code></p>
      <p><code>ход( глубина &lt; Макс, Поз, Ход, Поз1) :-</code></p>
      <p><code> глуб( Поз, Г),</code></p>
      <p><code> Г &lt; Макс, !.</code></p>
      <p><code>ход( глубина = Г, Поз, Ход, Поз1) :-</code></p>
      <p><code> глуб( Поз, Г), !.</code></p>
      <p><code>ход( сначала диаг, б..Б..Л..Ч..Г, Б-Б1,</code></p>
      <p><code> ч..Б1..Л..Ч..Г1) :-</code></p>
      <p><code> Г1 is Г + l,</code></p>
      <p><code> сосед( Б, Б1),</code></p>
      <p><code>  % "сосед" порождает сначала диагональные ходы</code></p>
      <p><code> not сосед( Б1, Ч), % Не попасть под шах</code></p>
      <p><code> Б1 \== Л.          % Не столкнуться с ладьей</code></p>
      <p><code>ход( ход ладьей, б..Б..Лх : Лу..Ч..Г, Лх : Лу-Л,</code></p>
      <p><code> ч..Б..Л..Ч..Г1) :-</code></p>
      <p><code> Г1 is Г + 1,</code></p>
      <p><code> коорд( I),                       % Число между 1 и 8</code></p>
      <p><code> ( Л = Лх : I; Л = I : Лу),</code></p>
      <p><code>  % По горизонтали или по вертикали</code></p>
      <p><code> Л \== Лх : Лу,                   % Обязательно двигаться</code></p>
      <p><code> not мешает( Лх : Лу, Б, Л).      % Мешает белый король</code></p>
      <p><code>ход( ход_шах, Поз, Л-Лх : Лу, Поз1) :-</code></p>
      <p><code> бл( Поз, Л),</code></p>
      <p><code> чк( Поз, Чх : Чу),</code></p>
      <p><code> ( Лх = Чх; Лу = Чу),</code></p>
      <p><code>  % Ладья и черный король на одной линии</code></p>
      <p><code> ход( ход_ладьей, Поз, Л-Лх : Лу, Поз1).</code></p>
      <p><code>ход( разреш, б..П, М, П1) :-</code></p>
      <p><code> ( Огр = сначала_диаг; Огр = ход ладьей),</code></p>
      <p><code> ход( Огр, б..П, М, П1).</code></p>
      <p><code>ход( разреш, ч..Б..Л..Ч..Г, Ч-Ч1, б..Б..Л..Ч1..Г1) :-</code></p>
      <p><code> Г1 is Г + 1,</code></p>
      <p><code> сосед( Ч, Ч1),</code></p>
      <p><code> not шах( б..Б..Л..Ч1..Г1).</code></p>
      <empty-line/>
      <p><code>разрход( Поз, Ход, Поз1) :-</code></p>
      <p><code> ход( разреш, Поз, Ход, Поз1).</code></p>
      <p><code> шах( _..Б..Лх : Лу..Чх : Чу.._ ) :-</code></p>
      <p><code> сосед( Б, Чх : Чу);              % Короли рядом</code></p>
      <p><code> ( Лх = Чх; Лу = Чу),</code></p>
      <p><code> Лх : Лу \== Чх : Чу,             % Нет взятия ладьи</code></p>
      <p><code> not мешает( Лх : Лу, Б, Чх : Чу).</code></p>
      <empty-line/>
      <p><code>мешает( S, S1, S1) :- !.</code></p>
      <p><code>мешает( X1 : Y, X2 : Y, Х3 : Y) :-</code></p>
      <p><code> упоряд( X1, Х2, Х3), !.</code></p>
      <p><code>мешает( X : Y1, X : Y2, X : Y3) :-</code></p>
      <p><code> упоряд( Y1, Y2, Y3).</code></p>
      <empty-line/>
      <p><code>упоряд( N1, N2, N3) :-</code></p>
      <p><code> N1 &lt; N2, N2 &lt; N3;</code></p>
      <p><code> N3 &lt; N2, N2 &lt; N1.</code></p>
      <empty-line/>
      <p><code>коорд( 1). коорд( 2). коорд( 3). коорд( 4).</code></p>
      <p><code>коорд( 5). коорд( 6). коорд( 7). коорд( 8).</code></p>
      <empty-line/>
      <p><code>% Предикаты целей</code></p>
      <p><code>любая_поз( Поз).</code></p>
      <empty-line/>
      <p><code>ход_противника( б.._ ).           % Противник ходит белыми</code></p>
      <empty-line/>
      <p><code>мат( Поз) :-</code></p>
      <p><code> чей_ход( Поз, ч),</code></p>
      <p><code> шах( Поз),</code></p>
      <p><code> not разрход( Поз, _, _ ).</code></p>
      <empty-line/>
      <p><code>пат( Поз) :-</code></p>
      <p><code> чей_ход( Поз, ч),</code></p>
      <p><code> not шах( Поз),</code></p>
      <p><code> not разрход( Поз, _, _ ).</code></p>
      <empty-line/>
      <p><code>уменьш_простр( Поз, КорнПоз) :-</code></p>
      <p><code> простр( Поз, Пр),</code></p>
      <p><code> простр( КорнПоз, КорнПр),</code></p>
      <p><code> Пр &lt; КорнПр.</code></p>
      <empty-line/>
      <p><code>ладья_под_боем( ЧейХод..Б..Л..Ч.._ ) :-</code></p>
      <p><code> расст( Б, Л, P1),</code></p>
      <p><code> расст( Ч, Л, Р2),</code></p>
      <p><code> ( ЧейХод = б, !, P1 &gt; Р2 + 1;</code></p>
      <p><code>   ЧейХод = ч,  !,  P1 &gt; Р2 ).</code></p>
      <empty-line/>
      <p><code>ближе_к_клетке( Поз, КорнПоз) :-</code></p>
      <p><code> расст_до_клетки( Поз, P1),</code></p>
      <p><code> расст_до_клетки( КорнПоз, Р2),</code></p>
      <p><code> P1 &lt; Р2.</code></p>
      <empty-line/>
      <p><code>расст_до_клетки( Поз, Мрасст) :-</code></p>
      <p><code>               % Манхеттеновское расстояние</code></p>
      <p><code> бк( Поз, БК), % между БК и критической клеткой</code></p>
      <p><code> кк( Поз, КК), % Критическая клетка</code></p>
      <p><code> манх_расст( БК, КК, Мрасст).</code></p>
      <empty-line/>
      <p><code>раздел( _..Бх : Бу..Лх : Лу.. Чх : Чу.._ ) :-</code></p>
      <p><code> упоряд( Бх, Лх, Чх), !;</code></p>
      <p><code> упоряд( Бу, Лу, Чу).</code></p>
      <empty-line/>
      <p><code>l_конфиг( _..Б..Л..Ч.._ ) :-      % L - конфигурация</code></p>
      <p><code> манх_расст( Б, Ч, 2),</code></p>
      <p><code> манх_расст( Л, Ч, 3).</code></p>
      <empty-line/>
      <p><code>не дальше_от_ладьи( _..Б..Л.._, _..Б1..Л1.._ ) :-</code></p>
      <p><code> расст( Б, Л, P),</code></p>
      <p><code> расст( Б1, Л1, P1),</code></p>
      <p><code> P =&lt; P1.</code></p>
      <empty-line/>
      <p><code>простр_больше_2( Поз) :-</code></p>
      <p><code> простр( Поз, Пр),</code></p>
      <p><code> Пр &gt; 2.</code></p>
      <empty-line/>
      <p><code>наш_король_на_краю( _..X : Y.._ ) :-</code></p>
      <p><code>  % Белый король на краю</code></p>
      <p><code> ( X = 1, !; X = 8, !; Y = 1, !; Y = 8).</code></p>
      <empty-line/>
      <p><code>король_противника_на_краю( _..Б..Л..X : Y.._ ) :-</code></p>
      <p><code>  % Черный король на краю</code></p>
      <p><code> ( X = 1, !; X = 8, !; Y = 1, !; Y = 8).</code></p>
      <empty-line/>
      <p><code>короли_рядом( Поз) :-             % Расстояние между королями  &lt;  4</code></p>
      <p><code> бк( Поз, БК), чк( Поз, ЧК),</code></p>
      <p><code> расст( БК, ЧК, P),</code></p>
      <p><code> P &lt; 4.</code></p>
      <empty-line/>
      <p><code>потеря_ладьи( _..Б..Л..Л.._ )- % Ладья взята</code></p>
      <p><code>потеря_ладьи( ч..Б..Л..Ч.._ ) :-</code></p>
      <p><code> сосед( Ч, Л),                 % Черный король напал на ладью</code></p>
      <p><code> not сосед( Б, Л).             % Белый король не защищает ладью</code></p>
      <empty-line/>
      <p><code>расст( X : Y, X1 : Y1, P) :-   % Расстояние до короля</code></p>
      <p><code> абс_разн( X, X1, Рх),</code></p>
      <p><code> абс_разн( Y, Y1, Ру),</code></p>
      <p><code> макс( Рх, Ру, P).</code></p>
      <empty-line/>
      <p><code>абс_разн( А, В, С) :-</code></p>
      <p><code> А &gt; В, !, С is A - В;</code></p>
      <p><code> С is В - А.</code></p>
      <empty-line/>
      <p><code>макс( А, В, М) :-</code></p>
      <p><code> А &gt;= В, !, М = А;</code></p>
      <p><code> М = В.</code></p>
      <empty-line/>
      <p><code>манх_расст( X : Y, X1 : Y1, P) :- % Манхеттеновское расстояние</code></p>
      <p><code> абс_разн( X, X1, Рх),</code></p>
      <p><code> абс_разн( Y, Y1, Ру),</code></p>
      <p><code> P is Рх + Ру.</code></p>
      <empty-line/>
      <p><code>простр( Поз, Пр) :-</code></p>
      <p><code>  % Область, в которой "заперт" черный король</code></p>
      <p><code> бл( Поз, Лх : Лу),</code></p>
      <p><code> чк( Поз, Чх : Чу),</code></p>
      <p><code> ( Чх &lt; Лх, СторонаХ is Лх - 1;</code></p>
      <p><code>   Чх &gt; Лх, СторонаХ is 8 - Лх ),</code></p>
      <p><code> ( Чу &lt; Лу, СторонаY is Лу - 1;</code></p>
      <p><code>   Чу &gt; Лу, СторонаY is 8 - Лу ),</code></p>
      <p><code> Пр is СторонаХ * СторонаY, !;</code></p>
      <p><code> Пр = 64. % Ладья и черный король на одной линии</code></p>
      <empty-line/>
      <p><code>кк( _..Б..Лх : Лу.. Чх : Чу.._, Кх : Ку) :-</code></p>
      <p><code>  % Критическая клетка</code></p>
      <p><code> ( Чх &lt; Лх, !, Кх is Лх - 1; Кх is Лх + 1),</code></p>
      <p><code> ( Чу &lt; Лу, !, Ку is Лу - 1; Ку is Лу + 1).</code></p>
      <empty-line/>
      <p><code>% Процедуры для отображения позиций</code></p>
      <p><code>отобр( Поз) :-</code></p>
      <p><code> nl,</code></p>
      <p><code> коорд( Y), nl,</code></p>
      <p><code> коорд( X),</code></p>
      <p><code> печ_фиг( X : Y, Поз),</code></p>
      <p><code> fail.</code></p>
      <p><code>отобр( Поз) :-</code></p>
      <p><code> чей_ход( Поз, ЧХ), глуб( Поз, Г),</code></p>
      <p><code> nl, write( 'ЧейХод='), write( ЧХ),</code></p>
      <p><code> write( 'Глубина='), write( Г), nl.</code></p>
      <empty-line/>
      <p><code>печ_фиг( Клетка, Поз):-</code></p>
      <p><code> бк( Поз, Клетка), !, write( 'Б');</code></p>
      <p><code> бл( Поз, Клетка), !, write( 'Л');</code></p>
      <p><code> чк( Поз, Клетка), !, write( 'Ч');</code></p>
      <p><code> write( '.').</code></p>
      <empty-line/>
      <p><code>показать_ход( Ход) :-</code></p>
      <p><code> nl, write( Ход), nl.</code></p>
      <p><strong>Рис. 15.10.</strong> Библиотека предикатов для окончания "король и ладья против короля".</p>
      <subtitle>Проект</subtitle>
      <p>Рассмотрите какой-нибудь другой простой эндшпиль, например "король и пешка против короля", и напишите для него программу на языке AL0 (вместе с определениями соответствующих предикатов).</p>
     </section>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Игры двух лиц поддаются формальному представлению в виде И/ИЛИ-графов. Поэтому процедуры поиска в И/ИЛИ-графах применимы для поиска в игровых деревьях.</p>
     <p>• Простой алгоритм поиска в глубину в игровых деревьях легко программируется, но для игр, представляющих интерес, он не эффективен. Более реалистичный подход — минимаксный принцип в сочетании с оценочной функцией и поиском, ограниченным по глубине.</p>
     <p>• Альфа-бета алгоритм является эффективной реализацией минимаксного принципа. Эффективность альфа-бета алгоритма зависит от порядка, в котором просматриваются варианты ходов. Применение альфа-бета алгоритма приводит, в лучшем случае, к уменьшению коэффициента ветвления дерева поиска, соответствующему извлечению из него квадратного корня.</p>
     <p>• В альфа-бета алгоритм можно внести ряд усовершенствований. Среди них: продолжение поиска за пределы ограничения по глубине вплоть до спокойных позиций, последовательное углубление и эвристическое отсечение ветвей.</p>
     <p>• Численная оценка позиций является весьма ограниченной формой представления знаний о конкретной игре. Более богатый по своим возможностям метод представления знаний должен предусматривать внесение в программу знаний о типовых ситуациях. Язык Советов (Advice Language) реализует такой подход. На этом языке знания представляются в терминах целей и средств для их достижения.</p>
     <p>• В данной главе мы составили следующие программы: программная реализация минимаксного принципа и альфа-бета процедуры, интерпретатор языка AL0 и таблица советов для окончания "король и ладья против короля".</p>
     <p>• Были введены и обсуждены следующие понятия:</p>
     <p>  игры двух лиц с полной информацией</p>
     <p>  игровые деревья</p>
     <p>  оценочная функция, минимаксный принцип</p>
     <p>  статические оценки, рабочие оценки</p>
     <p>  альфа-бета алгоритм</p>
     <p>  последовательное углубление,</p>
     <p>  эвристическое отсечение,</p>
     <p>  эвристики для обнаружения спокойных позиций</p>
     <p>Языки Советов</p>
     <p>  цели, ограничения, элементарные советы,</p>
     <p>  таблица советов</p>
     <subtitle>Литература</subtitle>
     <p>Минимаксный принцип, реализованный в форме альфа-бета алгоритма, — это наиболее популярный метод в игровом программировании. Особенно часто он применяется в шахматных программах. Минимаксный принцип был впервые предложен Шенноном (Shannon 1950). Возникновение и становление альфа-бета алгоритма имеет довольно запутанную историю. Несколько исследователей независимо друг от друга открыли либо реализовали этот метод полностью или частично. Эта интересная история описана в статье Knuth and Moore (1978). Там же приводится более компактная формулировка альфа-бета алгоритма, использующая вместо минимаксного принципа принцип "него-макса" ("neg-max" principle), и приводится математический анализ производительности алгоритма. Наиболее полный обзор различных минимаксных алгоритмов вместе с их теоретическим анализом содержится в книге Pearl (1984). Существует еще один интересный вопрос, относящийся к минимаксному принципу. Мы знаем, что статическим оценкам следует доверять только до некоторой степени. Можно ли считать, что рабочие оценки являются более надежными, чем исходные статические оценки, из которых они получены? В книге Pearl (1984) собран ряд математических результатов, имеющих отношение к ответу на этот вопрос. Приведенные в этой книге результаты, касающиеся распространения ошибок по минимаксному дереву, объясняют, в каких случаях и почему минимаксный принцип оказывается полезным.</p>
     <p>Сборник статей Bramer (1983) охватывает несколько аспектов игрового программирования. Frey (1983) — хороший сборник статей по шахматным программам. Текущие разработки в области машинных шахмат регулярно освещаются в серии Advances in Computer Chess и в журнале ICCA.</p>
     <p>Метод Языка Советов, позволяющий использовать знания о типовых ситуациях, был предложен Д. Мики. Дальнейшее развитие этого метода отражено в Bratko and Michi (1980 a, b) и Bratko (1982, 1984, 1985). Программа для игры в эндшпиле "король и ладья против короля", описанная в этой главе, совпадает с точностью до незначительных модификаций с таблицей советов, корректность которой была математически доказана в статье Bratko (1978). Ван Эмден также запрограммировал эту таблицу советов на Прологе (van Emden 1982).</p>
     <p>Среди других интересных экспериментов в области машинных шахмат, преследующих цель повысить эффективность знаний (а не перебора), следует отметить Berliner (1977), Pitrat (1977) и Wilkins (1980).</p>
     <empty-line/>
     <p><emphasis>Advances in Computer Chess Series</emphasis> (M.R.B. Clarke, ed). Edinburgh University Press (Vols. 1-2), Pergamon Press (Vol. 3).</p>
     <p>Berliner M. A. (1977); A representation and some mechanisms for a problem solving chess program. In: <emphasis>Advances in Computer Chess 1</emphasis> (M.R.B. Clarke, ed). Edinburgh University Press.</p>
     <p>Bramer M. A; (1983, ed). <emphasis>Computer Game Playing: Theory and Practice.</emphasis> Ellis Horwood and John Wiley.</p>
     <p>Bratko I. (1978) Proving correctness of strategies in the AL1 assertional language. <emphasis>Information Processing Letters 7</emphasis>: 223-230.</p>
     <p>Bratko I. (1982). Knowledge-based problem solving in AL3. In: <emphasis>Machine Intelligence 10</emphasis> (J. Hayes, D. Michie, J. H. Pao, eds.). Ellis Horwood (an abbreviated version also appears in Bramer 1983).</p>
     <p>Bratko I. (1984). Advise and planning in chess end-games. In: <emphasis>Artificial and Human Intelligence</emphasis> (S. Amarel, A. Elithorn, R. Banerji, eds.). North-Holland.</p>
     <p>Bratko I. (1985). Symbolic derivation of chess patterns. In: <emphasis>Progress Artificial Intelligence</emphasis> (L. Steels, J. A. Campbell, eds.). Ellis Horwood and John Wiley.</p>
     <p>Bratko I. and Michie D. (1980a). A representation of pattern-knowledge in chess end-games. In: <emphasis>Advances in Computer Chess</emphasis> 2 (M.R.B. Clarke, ed). Edinburgh University Press.</p>
     <p>Bratko I. and Michie D. (1980b). An advice program for a complex chess programming task. <emphasis>Computer Journal</emphasis> <strong>23</strong>: 353-359.</p>
     <p>Frey P. W. (1983, ed.). <emphasis>Chess Skill in Man and Machine</emphasis> (second edition). Springer-Verlag.</p>
     <p>Knuth D. E. and Moore R. W. (1975). An analysis of alpha-beta pruning. <emphasis>Artificial Intelligence</emphasis> <strong>6</strong>: 93-326.</p>
     <p>Pearl J. (1984). Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley.</p>
     <p>Pitrat J. (1977). A chess combination program which uses plans <emphasis>Artificial Intelligence</emphasis> <strong>8</strong>: 275-321.</p>
     <p>Shannon C.E. (1950). Programming a computer for playing chess. <emphasis>Philosophical Magazine</emphasis> <strong>41</strong>: 256-275. [В сб. Шеннон К. Работы по теории информации и кибернетике. — М.: ИЛ., 1963.]</p>
     <p>van Emden M. (1982). Chess end-game advice: a case study in computer utilisation of knowledge. In: <emphasis>Machine Intelligence 10</emphasis> (J. Hayes, D. Michie, J.H. Pao, eds). Ellis Hordwood.</p>
     <p>Wilkins D.E. (1980). Using patterns and plans in chess. <emphasis>Artificial Intelligence</emphasis> <strong>14</strong>: 165-203. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 16</p>
     <p>Программирование в терминах типовых конфигураций</p>
    </title>
    <section>
     <p>В этой главе мы будем заниматься системами, ориентированными на типовые конфигурации ("образцы"), рассматривая их как некоторый специальный подход к программированию. Языком, ориентированным на образцы, можно считать и сам Пролог. Мы реализуем небольшой интерпретатор для простых программ этого типа и постараемся передать дух такого "конфигурационной" программирования на нескольких примерах.</p>
    </section>
    <section>
     <title>
      <p>16.1. Архитектура, ориентированная на типовые конфигурации </p>
     </title>
     <section>
      <title>
       <p>16.1.1. Основные понятия</p>
      </title>
      <p>Под <emphasis>системами, ориентированными на типовые конфигурации (образцы)</emphasis>, мы будем понимать программные системы специальной архитектуры. Для некоторых конкретных типов задач такая архитектура дает преимущества по сравнению с традиционным способом организации. Среди задач, которые естественным образом вписываются в этот вид архитектуры, находятся многие приложения искусственного интеллекта, в том числе экспертные системы. Основное различие между традиционными системами и системами, ориентированными на образцы, заключается в механизме запуска программных модулей. Традиционная архитектура предполагает, что модули системы обращаются друг к другу в соответствии с фиксированной, заранее заданной и явным образом сформулированной схемой. Каждый программный модуль сам принимает решение о том, какой из других модулей следует запустить в данный момент, причем в нем содержится <emphasis>явное</emphasis> обращение к этим модулям. Соответствующая временная структура передач управления от одних модулей к другим оказывается последовательной и детерминированной.</p>
      <p>В противоположность этому организация, ориентированная на образцы, не предполагает прямого обращения из одних модулей к другим. Модули запускаются <emphasis>конфигурациями</emphasis>, возникающими в их "информационной среде". Такие программные модули называют модулями, <emphasis>управляемыми типовыми конфигурациями</emphasis> (или <emphasis>образцами</emphasis>). Программа, управляемая образцами, представляет из себя набор модулей. Каждый модуль определяется</p>
      <p>(1) образцом, соответствующим предварительному условию запуска, и</p>
      <p>(2) тем действием, которое следует выполнить, если информационная среда согласуется с заданным образцом.</p>
      <p>Запуск модулей на выполнение происходит при появлении тех или иных конфигураций в информационной среде системы. Такую информационную среду обычно называют <emphasis>базой данных</emphasis>. Наглядное представление о системе рассматриваемого типа дает рис. 16.1.</p>
      <image l:href="#_111.png"/>
      <p><strong>Рис. 16.1.</strong> Система, управляемая типовыми конфигурациями (образцами)</p>
      <p>Следует сделать несколько важных замечаний относительно рис. 16.1. Совокупность модулей не имеет иерархической структуры. Отсутствуют явные указания на то, какие модули могут обращаться к каким-либо другим модулям. Модули связаны скорее с базой данных, чем непосредственно друг с другом. В принципе такая структура допускает параллельное выполнение сразу нескольких модулей, поскольку текущее состояние базы данных может прийти в соответствие сразу с несколькими предварительными условиями, а следовательно, в принципе могут запуститься несколько модулей одновременно. В связи с этим, подобную организацию можно рассматривать как естественную модель параллельных вычислений, имея в виду, что каждый модуль физически реализован на отдельном процессоре.</p>
      <p>Архитектура, ориентированная на образцы, обладает рядом достоинств. Одно из ее главных преимуществ состоит в том, что, разрабатывая подобную систему, мы не должны тщательно продумывать и заранее определять все связи между модулями. Следовательно, каждый модуль может быть разработан и реализован относительно автономно. Это придает системе высокую степень модульности, проявляющуюся, например, в том, что удаление из системы какого-либо модуля не обязательно приводит к фатальным последствиям. После удаления модуля система во многих случаях сохранит свою способность к решению задач, измениться может только <emphasis>способ</emphasis> их решения. Аналогичное соображение верно и в случае добавления новых модулей или изменения уже существующих. Заметим, что при введении подобных модификаций в традиционные системы потребовалось бы, как минимум, пересмотреть связи между модулями.</p>
      <p>Высокая степень модульности особенно желательна в системах со сложными базами знаний, поскольку очень трудно предсказать заранее все возможные взаимодействия между отдельными фрагментами знаний. Архитектура, ориентированная на образцы, обеспечивает простое решение этой проблемы: каждый фрагмент знаний, представленный в виде "если-то"-правила, можно считать отдельным модулем, запускаемым своим собственным образцом.</p>
      <p>Перейдем теперь к более детальной проработке нашей базовой схемы для систем, ориентированных на образцы, и рассмотрим вопросы реализации. Как следует из рис. 16.1, параллельная реализация была бы для нашей системы наиболее естественным решением. Тем не менее предположим, что нам предстоит реализовать ее на традиционном последовательном процессоре. Тогда если в базе знаний окажется сразу несколько "пусковых" конфигураций, относящихся к нескольким модулям, то возникнет конфликтная ситуация: нам придется принять решение о том, какой из этих потенциально активных модулей будет запущен в действительности. Совокупность всех потенциально активных модулей назовем <emphasis>конфликтным множеством</emphasis>. Очевидно, что реализация схемы рис. 16.1 на последовательном процессоре потребует введения в систему дополнительного,  <emphasis>управляющего модуля</emphasis>. Задача управляющего модуля — выбрать и активизировать один из модулей конфликтного множества и тем самым разрешить конфликт. Одно из возможных простых правил разрешения конфликта может основываться, например, на предварительном упорядочивании множества модулей системы.</p>
      <p>Основной цикл работы системы, ориентированной на образцы, состоит, таким образом, из трех шагов:</p>
      <p>(1) <emphasis>Сопоставление с образцами</emphasis>: найти в базе данных все конфигурации, сопоставимые с пусковыми образцами программных модулей. Результат — конфликтное множество.</p>
      <p>(2) <emphasis>Разрешение конфликта</emphasis>: выбрать один из модулей, входящих в конфликтное множество.</p>
      <p>(3) <emphasis>Выполнение</emphasis>: запустить модуль, выбранный на предыдущем шаге.</p>
      <p>Этот принцип реализации показан в виде схемы на рис. 16.2.</p>
     </section>
     <section>
      <title>
       <p>16.1.2. Прологовские программы как системы, управляемые образцами</p>
      </title>
      <p>Программы, написанные на Прологе, можно рассматривать как системы, управляемые образцами. Между пролог-программами и этими системами можно установить соответствие примерно следующим образом:</p>
      <p>• Каждое предложение прологовской программы можно считать отдельным модулем со своим пусковым образцом. Голова предложения соответствует образцу, тело - тому действию, которое выполняет модуль.</p>
      <p>• База данных системы — это текущий список целей, которые пролог-система пытается удовлетворить.</p>
      <p>• Предложение пролог-системы "запускается", если его голова сопоставима с целью, расположенной первой в базе данных.</p>
      <p>• Выполнить действие модуля (т.е. тело предложения) — это значит: поместить в базу данных вместо первой из целей весь список целей тела предложения (с соответствующей конкретизацией переменных).</p>
      <p>• Процесс активизации модулей (предложений) не детерминирован в том смысле, что с первой целью базы данных могут удачно сопоставить свою голову сразу несколько предложений, и, вообще говоря, любое из них может быть запущено. В Прологе этот недетерминизм реализован при помощи механизма возвратов.</p>
      <image l:href="#_112.png"/>
      <p><strong>Рис. 16.2.</strong> Основной цикл работы системы, управляемой образцами. В этом примере база данных согласуется с пусковыми образцами модулей 1, 3 и 4; для выполнения выбран модуль 3.</p>
     </section>
     <section>
      <title>
       <p>16.1.3. Пример составления программы</p>
      </title>
      <p>С системами, управляемыми образцами, связан свой особый стиль программирования, требующий специфического программистского мышления. Мы говорим в этом случае о <emphasis>программировании в терминах образцов</emphasis>.</p>
      <p>В качестве иллюстрации, рассмотрим элементарное упражнение по программированию — вычисление наибольшего общего делителя <emphasis>D</emphasis> двух целых чисел <emphasis>А</emphasis> и <emphasis>В</emphasis>. Рассмотрим классический алгоритм Евклида:</p>
      <cite>
       <p>Для того, чтобы вычислить наибольший общий делитель <emphasis>D</emphasis> чисел <emphasis>А</emphasis> и <emphasis>В</emphasis>, необходимо:</p>
       <p> Повторять циклически, пока <emphasis>А</emphasis> и <emphasis>В</emphasis> не совпадут:</p>
       <p>  если <emphasis>А &gt; В</emphasis>, то заменить <emphasis>А</emphasis> на <emphasis>А - В</emphasis>,</p>
       <p>  иначе заменить <emphasis>В</emphasis> на <emphasis>В - А</emphasis>.</p>
       <p> После выхода из цикла <emphasis>А</emphasis> и <emphasis>В</emphasis> совпадают; наибольший общий делитель <emphasis>D</emphasis> равен <emphasis>А</emphasis> (или <emphasis>В</emphasis>).</p>
      </cite>
      <p>Тот же самый процесс можно описать при помощи двух модулей, управляемых образцами:</p>
      <p><strong>Модуль 1</strong></p>
      <p><emphasis>Условие</emphasis> В базе данных существуют такие два числа <emphasis>X</emphasis> и <emphasis>Y</emphasis>, что <emphasis>X &gt; Y</emphasis>.</p>
      <p><emphasis>Действие</emphasis> Заменить <emphasis>X</emphasis> на разность <emphasis>X - Y</emphasis>.</p>
      <p><strong>Модуль 2</strong></p>
      <p><emphasis>Условие</emphasis> В  базе данных имеется число <emphasis>X</emphasis>.</p>
      <p><emphasis>Действие</emphasis> Выдать результат <emphasis>X</emphasis> и остановиться.</p>
      <p>Очевидно, что всегда, когда условие Модуля 1 удовлетворяется, удовлетворяется также и условие Модуля 2, и мы имеем конфликт. В нашем случае конфликт можно разрешить при помощи простого управляющего правила: всегда отдавать предпочтение Модулю 1. База данных первоначально содержит числа <emphasis>А</emphasis> и <emphasis>В</emphasis>.</p>
      <p>Здесь нас ждет приятный сюрприз: оказывается, что наша программа способна решать более общую задачу, а именно, она может вычислять наибольший общий делитель для любого количества чисел. Если в базу данных загрузить несколько целых чисел, то программа выведет их наибольший общий делитель. На рис. 16.3 показана возможная последовательность изменений, которые претерпевает база данных прежде, чем будет получен результат. Обратите внимание на то, что предварительные условия модулей могут удовлетворяться одновременно в нескольких местах базы данных.</p>
      <image l:href="#_113.png"/>
      <p><strong>Рис. 16.3.</strong> Процесс вычисления наибольшего общего делителя множества чисел. Первоначально база данных содержит числа 25, 10, 15 и 30. Вертикальная стрелка соединяет число с его "заменителем". Конечное состояние базы данных: 5, 5, 5, 5.</p>
      <p>В данной главе мы реализуем интерпретатор простого языка для описания систем, управляемых образцами, и проиллюстрируем на примерах дух программирования в терминах образцов.</p>
     </section>
    </section>
    <section>
     <title>
      <p>16.2. Простой интерпретатор программ, управляемых образцами</p>
     </title>
     <p>Для описания модулей, управляемых образцами, мы применим следующую синтаксическую конструкцию:</p>
     <p><code>ЧастьУсловия ---&gt; ЧастьДействия</code></p>
     <p>Часть условия представляет собой список условий:</p>
     <p><code>[ Условие1, Условие2, Условие3, ...]</code></p>
     <p>где <code>Условие1</code>, <code>Условие2</code> и т.д. — обычные прологовские цели. Предварительное условие запуска модуля считается выполненным, если все цели, содержащиеся в списке, достигнуты. Часть действия — это список действий:</p>
     <p><code>[ Действие1, Действие2, ...]</code></p>
     <p>Каждое отдельное действие — это, как и раньше, прологовская цель. Для того, чтобы выполнить список действий, нужно выполнить все действия из списка. Другими словами, все соответствующие цели должны быть удовлетворены. Среди допустимых действий будут действия, соответствующие манипулированию базой данных: <code>добавить</code>, <code>удалить</code> или <code>заменить</code> те или иные объекты базы данных.</p>
     <p>На рис. 16.4 показано, как выглядит наша программа вычисления наибольшего общего делителя, записанная в соответствии с введенным нами синтаксисом.</p>
     <empty-line/>
     <p><code>% Продукционные правила для нахождения наибольшего общего</code></p>
     <p><code>% делителя (алгоритм Евклида)</code></p>
     <p><code>:- op( 300, fx, число).</code></p>
     <empty-line/>
     <p><code>[ число X, число Y, X &gt; Y ] ---&gt;</code></p>
     <p><code> [ НовХ is X - Y, заменить( число X, число НовХ) ].</code></p>
     <p><code>[ число X ] ---&gt; [ write( X), стоп ].</code></p>
     <empty-line/>
     <p><code>% Начальное состояние базы данных</code></p>
     <p><code>число 25.</code></p>
     <p><code>число 10.</code></p>
     <p><code>число 15.</code></p>
     <p><code>число 30.</code></p>
     <p><strong>Рис. 16.4.</strong> Программа, управляемая образцами, для получения наибольшего общего делителя множества чисел.</p>
     <empty-line/>
     <p>Самый простой способ реализации этого языка — использовать механизмы управления базой данных, встроенные в Пролог. Добавить объект в базу данных или удалить объект из базы данных можно, применяя встроенные процедуры</p>
     <p><code>assert ( Объект)   retract( Объект)</code></p>
     <p>Заменить один объект на другой также просто:</p>
     <p><code>заменить( Объект1, Объект2) :-</code></p>
     <p><code> retract( Объект1), !,</code></p>
     <p><code> assert( Объект2).</code></p>
     <p>Здесь задача оператора отсечения — не допустить, чтобы оператор <code>retract</code> удалил из базы данных более чем один объект (при возвратах).</p>
     <empty-line/>
     <p><code>% Простой интерпретатор для программ, управляемых образцами</code></p>
     <p><code>% Работа с базой данных производится при помощи процедур</code></p>
     <p><code>% assert и retract</code></p>
     <empty-line/>
     <p><code>:- op( 800, xfx, ---&gt;).</code></p>
     <empty-line/>
     <p><code>пуск :-</code></p>
     <p><code> Условие ---&gt; Действие,          % правило</code></p>
     <p><code> проверить( Условие),            % Условие выполнено?</code></p>
     <p><code> выполнить( Действие).</code></p>
     <empty-line/>
     <p><code>проверить( []).                  % Пустое условие</code></p>
     <p><code>проверить( [Усл | Остальные]) :- % проверить конъюнкцию</code></p>
     <p><code> call( Усл),                     % условий</code></p>
     <p><code> проверить( Остальные).</code></p>
     <empty-line/>
     <p><code>выполнить( [ стоп] ) :- !. % Прекратить выполнение</code></p>
     <p><code>выполнить( []) :-          % Пустое действие (цикл завершен)</code></p>
     <p><code> пуск.                     % Перейти к следующему циклу</code></p>
     <p><code>выполнить [Д | Остальные] ) :-</code></p>
     <p><code> саll( Д),</code></p>
     <p><code> выполнить( Остальные).</code></p>
     <empty-line/>
     <p><code>заменить( А, В) :-         % Заменить в базе данных А на В</code></p>
     <p><code> retract( A), !,</code></p>
     <p><code> assert( В).</code></p>
     <p><strong>Рис. 16.5.</strong> Простой интерпретатор для программ, управляемых образцами.</p>
     <empty-line/>
     <p>Простой интерпретатор для программ, управляемых образцами, показан на рис. 16.5. Следует признать, что в интерпретаторе допущены значительные упрощения. Так, например, в него заложено чрезвычайно простое и жесткое правило разрешения конфликтов: всегда запускать <emphasis>первый</emphasis> из потенциально активных модулей (в соответствии с тем порядком, в котором модули записаны в программе). Таким образом, программисту предоставлено единственное средство управления процессом интерпретации — он может указать тот или иной порядок следования модулей. Начальное состояние базы данных задается в виде прологовских предложений, записанных в исходной программе. Запуск программы производится при помощи вопроса</p>
     <p><code>?- пуск.</code></p>
    </section>
    <section>
     <title>
      <p>16.3. Простая программа для автоматического доказательства теорем</p>
     </title>
     <p>В настоящем разделе мы реализуем простую программу для автоматического доказательства теорем в виде системы, управляемой образцами. Эта программа будет основана на <emphasis>принципе резолюции</emphasis> — популярном методе, обычно используемом в машинном доказательстве теорем. Мы ограничимся случаем <emphasis>пропозициональной логики</emphasis>, поскольку нашей целью будет дать всего лишь простую иллюстрацию используемого принципа. На самом деле, принцип резолюции можно легко обобщить на случай исчисления высказываний первого порядка (с применением логических формул, содержащих переменные). Базовый Пролог можно рассматривать как частный случай системы доказательства теорем, основанной на принципе резолюции.</p>
     <p>Задачу доказательства теорем можно сформулировать так: дана формула, необходимо показать, что эта формула является теоремой, т.е. она верна всегда, независимо от интерпретации встречающихся в ней символов. Например, утверждение, записанное в виде формулы</p>
     <p><emphasis>p</emphasis>  v  <emphasis>~ p</emphasis></p>
     <p>и означающее "<emphasis>p</emphasis> или не <emphasis>p</emphasis>", верно всегда, независимо от смысла утверждения <emphasis>p</emphasis>.</p>
     <p>Мы будем использовать в качестве операторов следующие символы:</p>
     <p>~     отрицание, читается как  "не"</p>
     <p>&amp;    конъюнкцию, читается как  "и"</p>
     <p>v    дизъюнкцию, читается как  "или"</p>
     <p>=&gt;  импликацию, читается как  "следует"</p>
     <p>Согласно правилам предпочтения операторов, оператор "не" связывает утверждения сильнее, чем "и", "или" и "следует".</p>
     <p>Метод резолюции предполагает, что мы рассматриваем отрицание исходной формулы и пытаемся показать, что полученная формула противоречива. Если это действительно так, то исходная формула представляет собой тавтологию. Таким образом, основную идею можно сформулировать так: доказательство противоречивости формулы с отрицанием эквивалентно доказательству того, что исходная формула (без отрицания) есть теорема (т.е. верна всегда). Процесс, приводящий к искомому противоречию, состоит из отдельных шагов, на каждом из которых применяется резолюция.</p>
     <p>Давайте проиллюстрируем этот принцип на примере. Предположим, что мы хотим доказать, что теоремой является следующая пропозициональная формула:</p>
     <p>(<emphasis>а  =&gt;  b</emphasis>) &amp; (<emphasis>b  =&gt;  с</emphasis>) =&gt; (<emphasis>а  =&gt;  с</emphasis>)</p>
     <p>Смысл этой формулы таков: если из <emphasis>а</emphasis> следует <emphasis>b</emphasis> и из <emphasis>b</emphasis> следует <emphasis>с</emphasis>, то из <emphasis>а</emphasis> следует <emphasis>с</emphasis>.</p>
     <p>Прежде чем начать применять процесс резолюции ("резолюционный процесс"), необходимо представить отрицание нашей формулы в наиболее приспособленной для этого форме. Такой формой является <emphasis>конъюнктивная нормальная форма</emphasis>, имеющая вид</p>
     <p>(<emphasis>р</emphasis><sub>1</sub>  v  <emphasis>p</emphasis><sub>2</sub>  v  …)  &amp;  (<emphasis>q</emphasis><sub>1</sub>  v  <emphasis>q</emphasis><sub>2</sub>  v  …)</p>
     <p>      &amp;  (<emphasis>r</emphasis><sub>1</sub>  v  <emphasis>r</emphasis><sub>2</sub>  v  …)  &amp;  …</p>
     <p>Здесь <emphasis>р<sub>i</sub></emphasis>, <emphasis>q<sub>i</sub></emphasis>, <emphasis>r<sub>i</sub></emphasis> — элементарные утверждения или их отрицания. Конъюнктивная нормальная форма есть конъюнкция членов, называемых <emphasis>дизъюнктами</emphasis>, например (<emphasis>p</emphasis><sub>1</sub> v <emphasis>p</emphasis><sub>2</sub> v …) — это дизъюнкт.</p>
     <p>Любую пропозициональную формулу нетрудно преобразовать в такую форму. В нашем случае это делается следующим образом. У нас есть исходная формула</p>
     <p>(<emphasis>а  =&gt;  b</emphasis>)  &amp;  (<emphasis>b  =&gt;  с</emphasis>)  =&gt;  (<emphasis>а  =&gt;  с</emphasis>)</p>
     <p>Ее отрицание имеет вид</p>
     <p>~((<emphasis>а  =&gt;  b</emphasis>) &amp; (<emphasis>b  =&gt;  с</emphasis>) =&gt; (<emphasis>а  =&gt;  с</emphasis>))</p>
     <p>Для преобразования этой формулы в конъюнктивную нормальную форму можно использовать следующие известные правила:</p>
     <p>(1) <emphasis>x =&gt; у</emphasis>  эквивалентно  <emphasis>~x</emphasis> v <emphasis>у</emphasis></p>
     <p>(2) <emphasis>~</emphasis>(<emphasis>x</emphasis> v <emphasis>y</emphasis>)  эквивалентно <emphasis>~x</emphasis> &amp; <emphasis>~у</emphasis></p>
     <p>(3) <emphasis>~</emphasis>(<emphasis>x</emphasis> &amp; <emphasis>у</emphasis>)  эквивалентно  <emphasis>~x</emphasis> v <emphasis>~у</emphasis></p>
     <p>(4) <emphasis>~</emphasis>(<emphasis>~x</emphasis>)  эквивалентно  <emphasis>x</emphasis></p>
     <p>Применяя правило 1, получаем</p>
     <p>~(~((<emphasis>a  =&gt;  b</emphasis>)  &amp;  (<emphasis>b  =&gt;  с</emphasis>))  v  (<emphasis>а  =&gt;  с</emphasis>))</p>
     <p>Далее, правила 2 и 4 дают</p>
     <p>(<emphasis>а  =&gt;  b</emphasis>)  &amp;  (<emphasis>b  =&gt;  с</emphasis>)  &amp;  ~(<emphasis>а  =&gt;  с</emphasis>)</p>
     <p>Трижды применив правило 1, получаем</p>
     <p>(<emphasis>~а</emphasis>  v  <emphasis>b</emphasis>)  &amp;  (<emphasis>~b</emphasis>  v  <emphasis>с</emphasis>)  &amp;  <emphasis>~</emphasis>(<emphasis>~а</emphasis>  v  <emphasis>с</emphasis>)</p>
     <p>И наконец, после применения правила 2 получаем искомую конъюнктивную нормальную форму</p>
     <p>(<emphasis>~а</emphasis>  v  <emphasis>b</emphasis>)  &amp;  (<emphasis>~b</emphasis>  v  <emphasis>с</emphasis>)  &amp;  <emphasis>а</emphasis>  &amp;  <emphasis>~с</emphasis></p>
     <p>состоящую из четырех дизъюнктов. Теперь можно приступить к резолюционному процессу.</p>
     <p>Элементарный шаг резолюции выполняется всегда, когда имеется два дизъюнкта, в одном из которых встретилось элементарное утверждение <emphasis>p</emphasis>, а в другом — <emphasis>~p</emphasis>. Пусть этими двумя дизъюнктами будут</p>
     <p><emphasis>p</emphasis> v <emphasis>Y</emphasis>  и  <emphasis>~p</emphasis> v <emphasis>Z</emphasis></p>
     <p>Шаг резолюции порождает третий дизъюнкт:</p>
     <p><emphasis>Y</emphasis>  v  <emphasis>Z</emphasis></p>
     <p>Нетрудно показать, что этот дизъюнкт логически следует из тех двух дизъюнктов, из которых он получен. Таким образом, добавив выражение (<emphasis>Y</emphasis> v <emphasis>Z</emphasis>) к нашей исходной формуле, мы не изменим ее истинности. Резолюционный процесс порождает новые дизъюнкты. Появление "пустого дизъюнкта" (обычно записываемого как "nil") сигнализирует о противоречии. Действительно, пустой дизъюнкт <emphasis>nil</emphasis> порождается двумя дизъюнктами вида</p>
     <p><emphasis>x</emphasis>  и  <emphasis>~x</emphasis></p>
     <p>которые явно противоречат друг другу.</p>
     <image l:href="#_114.png"/>
     <p><strong>Рис. 16.6.</strong> Доказательство теоремы (<emphasis>а=&gt;b</emphasis>)&amp;(<emphasis>b=&gt;с</emphasis>)=&gt;(<emphasis>a=&gt;с</emphasis>) методом резолюции. Верхняя строка — отрицание теоремы в конъюнктивной нормальной форме. Пустой дизъюнкт внизу сигнализирует, что отрицание теоремы противоречиво.</p>
     <p>На рис. 16.6 показан процесс применения резолюций, начинающийся с отрицания нашей предполагаемой теоремы и заканчивающийся пустым дизъюнктом.</p>
     <p>На рис. 16.7 мы видим, как резолюционный процесс можно сформулировать в форме программы, управляемой образцами. Программа работает с дизъюнктами, записанными в базе данных. В терминах образцов принцип резолюции формулируется следующим образом:</p>
     <p><emphasis>если</emphasis></p>
     <p> существуют два таких дизъюнкта <emphasis>C1</emphasis> и <emphasis>C2</emphasis>, что <emphasis>P</emphasis> является (дизъюнктивным) подвыражением <emphasis>C1</emphasis>, а <emphasis>~P</emphasis> — подвыражением <emphasis>C2</emphasis></p>
     <p><emphasis>то</emphasis></p>
     <p> удалить <emphasis>P </emphasis>из <emphasis>C1 </emphasis>(результат — <emphasis>CA</emphasis>), удалить <emphasis>~P </emphasis>из <emphasis>C2 </emphasis>(результат — <emphasis>CB</emphasis>) и добавить в базу данных новый дизъюнкт <emphasis>CA</emphasis> v <emphasis>CB</emphasis>.</p>
     <p>На нашем формальном языке это можно записать так:</p>
     <p><code>[ дизъюнкт( C1), удалить( P, C1, CA),</code></p>
     <p><code>  дизъюнкт( C2), удалить( ~P, C2, CB) ] ---&gt;</code></p>
     <p><code> [ assert( дизъюнкт( СА v СВ) ) ].</code></p>
     <p>Это правило нуждается в небольшой доработке. Дело в том, что мы не должны допускать повторных взаимодействий между дизъюнктами, так как они порождают новые копии уже существующих формул. Для этого в программе рис. 16.7 предусматривается запись в базу данных информации об уже произведенных взаимодействиях в форме утверждений вида</p>
     <p><code>сделано( C1, C2, P)</code></p>
     <p>В условных частях правил производится распознавание подобных утверждений и обход соответствующих повторных действий.</p>
     <p>Правила, показанные на рис. 16.7, предусматривают также обработку специальных случаев, в которых требуется избежать явного представления пустого дизъюнкта. Кроме того, имеются два правила для упрощения дизъюнктов. Одно из них убирает избыточные подвыражения. Например, это правило превращает выражение</p>
     <p><emphasis>a</emphasis>  v  <emphasis>b</emphasis>  v  <emphasis>a</emphasis></p>
     <p>в более простое выражение <emphasis>a</emphasis> v <emphasis>b</emphasis>. Другое правило распознает те дизъюнкты, которые всегда истинны, например,</p>
     <p><emphasis>a</emphasis>  v  <emphasis>b</emphasis>  v  <emphasis>~а</emphasis></p>
     <p>и удаляет их из базы данных, поскольку они бесполезны при поиске противоречия.</p>
     <empty-line/>
     <p><code>% Продукционные правила для задачи автоматического</code></p>
     <p><code>% доказательства теорем</code></p>
     <empty-line/>
     <p><code>% Противоречие</code></p>
     <p><code>[ дизъюнкт( X), дизъзюнкт( ~X) ] ---&gt;</code></p>
     <p><code> [ write( 'Обнаружено противоречие'), стоп].</code></p>
     <empty-line/>
     <p><code>% Удалить тривиально истинный дизъюнкт</code></p>
     <p><code>[ дизъюнкт( С), внутри( P, С), внутри( ~P, С) ] ---&gt;</code></p>
     <p><code> [ retract( С) ].</code></p>
     <empty-line/>
     <p><code>% Упростить дизъюнкт</code></p>
     <p><code>[ дизъюнкт( С), удалить( P, С, C1), внутри( P, C1) ] ---&gt;</code></p>
     <p><code> [ заменить( дизъюнкт( С), дизъюнкт( C1) ) ].</code></p>
     <empty-line/>
     <p><code>% Шаг резолюции, специальный случай</code></p>
     <p><code>[ дизъюнкт( P), дизъюнкт( С), удалить( ~P, С, C1),</code></p>
     <p><code>  not сделано( P, С, P) ] ---&gt;</code></p>
     <p><code> [ аssеrt( дизъюнкт( C1)), аssert( сделано( P, С, P))].</code></p>
     <empty-line/>
     <p><code>% Шаг резолюции, специальный случай</code></p>
     <p><code>[ дизъюнкт( ~P), дизъюнкт( С), удалить( P, С, C1),</code></p>
     <p><code>  not сделано( ~P, С, P) ] ---&gt;</code></p>
     <p><code> [ assert( дизъюнкт( C1)), аssert( сделано( ~P, С, P))].</code></p>
     <empty-line/>
     <p><code>% Шаг резолюции, общий случай</code></p>
     <p><code>[ дизъюнкт( C1), удалить( P, C1, CA),</code></p>
     <p><code>  дизъюнкт( C2), удалить( ~P, C2, CB),</code></p>
     <p><code>  not сделано( C1, C2, P) ] ---&gt;</code></p>
     <p><code> [ assert( дизъюнкт( CA v CB) ),</code></p>
     <p><code>   assert( сделано( C1, C2, P) ) ].</code></p>
     <empty-line/>
     <p><code>% Последнее правило: тупик</code></p>
     <p><code>[] ---&gt; [ write( 'Нет противоречия'), стоп ].</code></p>
     <empty-line/>
     <p><code>% удалить( P, E, E1) означает, получить из выражения E</code></p>
     <p><code>% выражение E1, удалив из него подвыражение P</code></p>
     <p><code>удалить( X, X v Y, Y).</code></p>
     <p><code>удалить( X, Y v X, Y).</code></p>
     <p><code>удалить( X, Y v Z, Y v Z1) :-</code></p>
     <p><code> удалить( X, Z, Z1).</code></p>
     <p><code>удалить( X, Y v Z, Y1 v Z) :-</code></p>
     <p><code> удалить( X, Y, Y1).</code></p>
     <empty-line/>
     <p><code>% внутри( P, E) означает P есть дизъюнктивное подвыражение</code></p>
     <p><code>% выражения E</code></p>
     <p><code>внутри( X, X).</code></p>
     <p><code>внутри( X, Y) :-</code></p>
     <p><code> удалить( X, Y, _ ).</code></p>
     <p><strong>Рис. 16.7.</strong> Программа, управляемая образцами, для автоматического доказательства теорем.</p>
     <empty-line/>
     <p>Остается еще один вопрос: как преобразовать заданную пропозициональную формулу в конъюнктивную нормальную форму? Это несложное преобразование выполняется с помощью программы, показанной на рис. 16.8. Процедура</p>
     <p><code>транс( Формула)</code></p>
     <p>транслирует заданную формулу в множество дизъюнктов C1, C2 и т.д. и записывает их при помощи <code>assert</code> в базу данных в виде утверждений</p>
     <p><code>дизъюнкт( C1).</code></p>
     <p><code>дизъюнкт( C2).</code></p>
     <p><code>...</code></p>
     <p>Программа, управляемая образцами, для автоматического доказательства теорем запускается при помощи цели <code>пуск</code>. Таким образом, для того чтобы доказать при помощи этой программы некоторую теорему, мы транслируем ее отрицание в конъюнктивную нормальную форму, а затем запускаем резолюционный процесс. В нашем примере это можно сделать так:</p>
     <p><code>?- транс(~(( а=&gt;b) &amp; ( b=&gt;c) =&gt; ( а=&gt;с)) ), пуск.</code></p>
     <p>Ответ программы "Обнаружено противоречие" будет означать, что исходная формула является теоремой.</p>
     <empty-line/>
     <p><code>% Преобразование пропозициональной формулы в множество</code></p>
     <p><code>% дизъюнктов с записью их в базу данных при помощи assert</code></p>
     <p><code>:- op( 100, fy, ~).           % Отрицание</code></p>
     <p><code>:- op( 110, xfy, &amp;).          % Конъюнкция</code></p>
     <p><code>:- op( 120, xfy, v).          % Дизъюнкция</code></p>
     <p><code>:- op( 130, xfy, =&gt;).         % Импликация</code></p>
     <empty-line/>
     <p><code>транс( F &amp; G) :- !,     % Транслировать конъюнктивную формулу</code></p>
     <p><code> транс( F),</code></p>
     <p><code> транс( G).</code></p>
     <p><code>транс( Формула) :-</code></p>
     <p><code> тр( Формула, НовФ), !, % Шаг трансформации</code></p>
     <p><code> транс( НовФ).</code></p>
     <p><code>транс( Формула) :-      % Дальнейшая трансформация невозможна</code></p>
     <p><code> assert( дизъюнкт( Формула) ).</code></p>
     <empty-line/>
     <p><code>% Правила трансформаций для пропозициональных формул</code></p>
     <p><code>тр( ~( ~X), X) :- !.          % Двойное отрицание</code></p>
     <p><code>тр( X =&gt; Y, ~X v Y) :- !.     % Устранение импликации</code></p>
     <p><code>тр( ~( X &amp; Y), ~X v ~Y) :- !. % Закон де Моргана</code></p>
     <p><code>тр( ~( X v Y), ~X &amp; ~Y) :- !. % Закон де Моргана</code></p>
     <p><code>тр( X &amp; Y v Z, (X v Z) &amp; (Y v Z) ) :- !.</code></p>
     <p><code>  % Распределительный закон</code></p>
     <p><code>тр( X v Y &amp; Z, (X v Y) &amp; (X v Z) ) :- !.</code></p>
     <p><code>  % Распределительный закон</code></p>
     <p><code>тр( X v Y, X1 v Y) :-         % Трансформация подвыражения</code></p>
     <p><code> тр( X, X1), !.</code></p>
     <p><code>тр( X v Y, X v Y1) :-         % Трансформация подвыражения</code></p>
     <p><code> тр( Y, Y1), !.</code></p>
     <p><code>тр( ~X, ~Х1) :-               % Трансформация подвыражения</code></p>
     <p><code> тр( X, X1).</code></p>
     <p><strong>Рис. 16.8.</strong> Преобразование пропозициональных формул в множество дизъюнктов с записью их в базу данных при помощи <code>assert</code>.</p>
    </section>
    <section>
     <title>
      <p>16.4. Заключительные замечания</p>
     </title>
     <p>Нашего простого интерпретатора было вполне достаточно для того, чтобы проиллюстрировать некоторые идеи, лежащие в основе программирования в терминах образцов. Применение этого интерпретатора для более сложных приложений потребовало бы его доработки в целом ряде направлений. Ниже приводится несколько критических замечаний, а также ряд конкретных предложений по усовершенствованию алгоритма интерпретации.</p>
     <p>Задача разрешения конфликтов была сведена в нашем интерпретаторе к введению заранее заданного фиксированного порядка рассмотрения модулей. Часто возникает необходимость в более гибких механизмах. Для обеспечения более тонкого управления интерпретацией следует подавать все обнаруженные потенциально активные модули на вход специального управляющего модуля, запрограммированного пользователем.</p>
     <p>Когда база данных велика, а программа содержит большое количество модулей, процесс сопоставления с образцами становится крайне неэффективным. Неэффективность можно уменьшить, усложнив организацию базы данных. В частности, можно ввести индексирование информации, записанной в базе данных, или разбить эту информацию на отдельные "подбазы данных", или же разбить все множество модулей на отдельные подмножества. Идея разбиения — в каждый момент дать доступ только к некоторому <emphasis>подмножеству</emphasis> базы данных или набора модулей, ограничив тем самым сопоставление образцов только этим подмножеством. Разумеется, в этом случае механизм управления должен усложниться, поскольку он должен будет обеспечить переход от одних подмножеств к другим с целью их активизации либо деактивизации. Для этого можно применить специальные метаправила.</p>
     <p>К сожалению, наш интерпретатор запрограммирован таким образом, что он блокирует механизм автоматических возвратов, так как для манипулирования базой данных он использует процедуры <code>assert</code> и <code>retract</code>. Это положение можно исправить, применив другой способ реализации базы данных, не требующий обращения к этим встроенным процедурам. Например, все состоять базы данных можно представить одним прологовским термом, передаваемым в процедуру <code>пуск</code> в качестве аргумента. Простейший способ реализации этой идеи — организовать этот терм в виде списка объектов базы данных. Тогда верхний уровень базы данных примет вид:</p>
     <p><code>пуск( Состояние) :-</code></p>
     <p><code> Условие ---&gt; Действие,</code></p>
     <p><code> проверить( Условие, Состояние),</code></p>
     <p><code> выполнить( Действие, Состояние).</code></p>
     <p>Задача процедуры <code>выполнить</code> — получить новое состояние базы данных и обратиться к процедуре <code>пуск</code>, подав на ее вход это новое состояние.</p>
     <subtitle>Проект</subtitle>
     <p>Запрограммируйте интерпретатор, который, в соответствии с приведенным выше замечанием, реализует базу данных как аргумент пусковой процедуры и не использует для этого внутренней базы данных пролог-системы (т.е. обходится без <code>assert</code> и <code>retract</code>). Эта новая версия интерпретатора будет допускать автоматические возвраты. Попытайтесь разработать такое представление базы данных, которое облегчало бы сопоставление с образцами.</p>
    </section>
    <section>
     <title>
      <p>Резюме</p>
     </title>
     <p>• Архитектура, ориентированная на типовые конфигурации (образцы), хорошо приспособлена для решения многих задач искусственного интеллекта.</p>
     <p>• Программа, управляемая образцами, состоит из модулей, запускаемых при возникновении в базе данных тех или иных конфигураций.</p>
     <p>• Прологовские программы можно рассматривать как частный случай систем, управляемых образцами.</p>
     <p>• Параллельная реализация — наиболее естественный способ реализации систем, управляемых образцами. Реализация на последовательной машине требует разрешения конфликтов между модулями, содержащимися в конфликтном множестве.</p>
     <p>• В этой главе был реализован простой интерпретатор для программ, управляемых образцами. Он был затем применен к задаче автоматического доказательства теорем пропозициональной логики.</p>
     <p>• Были рассмотрены следующие понятия:</p>
     <p>   системы, управляемые образцами</p>
     <p>   архитектуры, ориентированные на образцы</p>
     <p>   программирование в терминах образцов</p>
     <p>   модули, управляемые образцами</p>
     <p>   конфликтное множество, разрешение конфликтов</p>
     <p>   принцип резолюции</p>
     <p>   автоматическое доказательство теорем на основе принципа резолюции</p>
     <subtitle>Литература</subtitle>
     <p>Waterman and Hayes-Roth (1978) — классическая книга по системам, управляемым образцами. В книге Nilsson (1980) можно найти фундаментальные понятия, относящиеся к задаче автоматического доказательства теорем, включая алгоритм преобразования логических формул в конъюнктивную нормальную форму. Прологовская программа для выполнения этого преобразования приведена в Clocksin and Mellish (1981).</p>
     <empty-line/>
     <p>Clocksin F. W. and Mellish С S. (1981). <emphasis>Programming in Prolog.</emphasis> Springer-Verlag. [Имеется перевод: Клоксин У., Мелиш К. Программирование на языке Пролог. — М.: Мир, 1987.]</p>
     <p>Nilsson N. J. (1980). <emphasis>Principles of Artificial Intelligence.</emphasis> Tioga; Springer-Verlag.</p>
     <p>Waterman D. A. and Hayes-Roth F. (1978, eds). <emphasis>Pattern-Directed Inference Systems.</emphasis> Academic Press.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Ответы к некоторым упражнениям</p>
   </title>
   <subtitle>Глава 1</subtitle>
   <p><strong>1.1</strong></p>
   <p>(a) <code>no</code></p>
   <p>(b) <code>X = пат</code></p>
   <p>(c) <code>X = боб</code></p>
   <p>(d) <code>X = боб, Y = пат</code></p>
   <p><strong>1.2</strong></p>
   <p>(a) <code>?- родитель( X, пат).</code></p>
   <p>(b) <code>?- родитель( лиз, X).</code></p>
   <p>(c) <code>?- родитель( Y, пат), родитель( X, Y).</code></p>
   <p><strong>1.3</strong></p>
   <p>(a) <code>счастлив( X) :-</code> </p>
   <p><code>    родитель( X, Y).</code></p>
   <p>(b) <code>имеетдвухдетей( X) :-</code> </p>
   <p><code>    родитель( X, Y),</code></p>
   <p><code>    сестра( Z, Y).</code></p>
   <p><strong>1.4</strong></p>
   <p><code>внук( X, Z) :-</code></p>
   <p><code> родитель( Y, X),</code></p>
   <p><code> родитель( Z, Y).</code></p>
   <p><strong>1.5</strong></p>
   <p><code>тетя( X, Y) :-</code></p>
   <p><code> родитель( Z, Y),</code></p>
   <p><code> сестра( X, Z).</code></p>
   <p><strong>1.6</strong></p>
   <p>Да. (Определение верно)</p>
   <p><strong>1.7</strong></p>
   <p>(a) возвратов не будет</p>
   <p>(b) возвратов не будет</p>
   <p>(c) возвратов не будет</p>
   <p>(d) возвраты будут</p>
   <subtitle>Глава 2</subtitle>
   <p><strong>2.1</strong></p>
   <p>(a) переменная</p>
   <p>(b) атом</p>
   <p>(c) атом</p>
   <p>(d) переменная</p>
   <p>(e) атом</p>
   <p>(f) структура</p>
   <p>(g) число</p>
   <p>(h) синтаксически неправильное выражение</p>
   <p>(i) структура</p>
   <p>(j) структура</p>
   <p><strong>2.3</strong></p>
   <p>(a) успех</p>
   <p>(b) неуспех</p>
   <p>(c) неуспех</p>
   <p>(d) D = 2, E = 2</p>
   <p>(e) <code>P1 = точка(-1, 0)</code> </p>
   <p><code>   Р2 = точка( 1, 0)</code></p>
   <p><code>   Р3 = точка( 0, Y)</code></p>
   <p>Такая конкретизация определяет семейство треугольников, у которых две вершины располагаются на оси <emphasis>x</emphasis> в точках 1 и -1, а третья — в произвольной точке оси <emphasis>у</emphasis>.</p>
   <p><strong>2.4</strong></p>
   <p><code>отр( точка( 5, Y1), точка( 5, Y2) )</code></p>
   <p><strong>2.5</strong></p>
   <p><code>регулярный( прямоугольник( точка( X1, Y1),</code></p>
   <p><code> точка( Х2, Y1), точкa( X2, Y3),</code></p>
   <p><code> точка( X1, Y3) ) ).</code></p>
   <p>Здесь предполагается, что первая точка соответствует нижней левой вершине прямоугольника.</p>
   <p><strong>2.6</strong></p>
   <p>(a) <code>А = два</code></p>
   <p>(b) <code>no</code></p>
   <p>(c) <code>С = один</code></p>
   <p>(d) <code>D = s(s(1));</code></p>
   <p><code>   D = s(s(s(s(s(1)))))</code></p>
   <p><strong>2.7</strong></p>
   <p><code>родственники( X, Y) :-</code></p>
   <p><code> предок( X, Y);</code></p>
   <p><code> предок( Y, X);</code></p>
   <p><code> предок( Z, X),</code></p>
   <p><code> предок( Z, Y);</code></p>
   <p><code> предок( X, Z),</code></p>
   <p><code> предок( Y, Z).</code></p>
   <p><strong>2.8</strong></p>
   <p><code>преобразовать( 1, один).</code></p>
   <p><code>преобразовать( 2, два).</code></p>
   <p><code>преобразовать( 3, три).</code></p>
   <p><strong>2.9</strong></p>
   <p>В случае, изображенном на рис. 2.10, пролог-система выполняет несколько больший объем работы.</p>
   <p><strong>2.10</strong></p>
   <p>В соответствии с определением сопоставления, приведенном в разд. 2.2, данное сопоставление будет успешным. X приобретает вид циклической структуры, в которой сам X присутствует в качестве одного из аргументов.</p>
   <subtitle>Глава 3</subtitle>
   <p><strong>3.1</strong></p>
   <p>(a) <code>конк( L1, [ _, _, _ ], L)</code></p>
   <p>(b)<code> конк( [ _, _, _ ], L1, L),</code></p>
   <p><code>     % Удалить 3 первые элемента L</code></p>
   <p><code>    конк( L2, [ _, _, _ ], L1)</code></p>
   <p><code>     % Удалить 3 последние элемента L1</code></p>
   <p>Вот более короткий вариант, предложенный I. Tvrdy:</p>
   <p><code>конк( [ _, _, _ | L2], [ _, _, _ ], L)</code></p>
   <p><strong>3.2</strong></p>
   <p>(а) <code>последний( Элемент, Список) :-</code> </p>
   <p><code>   конк( _, [Элемент], Список).</code></p>
   <p>(b)<code> последний( Элемент, [Элемент]).</code></p>
   <p><code>   последний( Элемент, [Первый | Остальные]):-</code></p>
   <p><code>    последний( Элемент, Остальные). </code></p>
   <p><strong>3.3</strong></p>
   <p><code>четнаядлина( [] ).</code></p>
   <p><code>четнаядлина( [Первый | Остальные] ) :-</code></p>
   <p><code> нечетнаядлина( Остальные).</code></p>
   <p><code>нечетнаядлина( [ _ ] ).</code></p>
   <p><code>нечетнаядлина( [Первый | Остальные] ) :-</code></p>
   <p><code> четнаядлина( Остальные).</code></p>
   <p><strong>3.4</strong></p>
   <p><code>обращение( [], []).</code></p>
   <p><code>обращение( [Первый | Остальные], ОбращСпис): -</code></p>
   <p><code> обращение( Остальные, ОбращСписОстальных),</code></p>
   <p><code> конк( О6ращСписОстальных, [Первый], ОбращСпис).</code></p>
   <p><strong>3.5</strong></p>
   <p><code>% Такой предикат легко определить при помощи отношения обратить</code></p>
   <p><code>палиндром( Список) :-</code></p>
   <p><code> обратить( Список, Список).</code></p>
   <empty-line/>
   <p><code>% Вот другое решение, не использующее обратить</code></p>
   <p><code>палиндром1( [] ).</code></p>
   <p><code>палиндром1( [ _ ] ).</code></p>
   <p><code>палиндром1 [Первый | Остальные] ) :-</code></p>
   <p><code> конк( Середина, [Первый], Остальные),</code></p>
   <p><code> палиндром1( Середина).</code></p>
   <p><strong>3.6</strong></p>
   <p><code>сдвиг( [Первый | Остальные], Сдвинут) :-</code></p>
   <p><code> конк( Остальные, [Первый], Сдвинут).</code></p>
   <p><strong>3.7</strong></p>
   <p><code>перевод( [], []).</code></p>
   <p><code>перевод( [Голова | Хвост], [Голова1 | Хвост1]) :-</code></p>
   <p><code> означает( Голова, Голова1),</code></p>
   <p><code> перевод( Хвост, Хвост1).</code></p>
   <p><strong>3.8</strong></p>
   <p><code>подмножество( [], [] ).</code></p>
   <p><code>подмножество( [Первый | Остальные], [Первый | Подмн]):-</code></p>
   <p><code>  % Оставить первый элемент в подмножестве</code></p>
   <p><code> подмножество( Остальные, Подмн).</code></p>
   <p><code>подмножество( [Первый | Остальные], Подмн) :-</code></p>
   <p><code>  % Убрать первый элемент из подмножества</code></p>
   <p><code> подмножество( Остальные, Подмн).</code></p>
   <p><strong>3.9</strong></p>
   <p><code>разбиениесписка( [], [], []). % Разбивать нечего</code></p>
   <p><code>разбиениесписка( [X], [X], []).</code></p>
   <p><code> % Разбиение одноэлементного списка</code></p>
   <p><code>разбиениесписка( [X, Y | Список], [X | Список1],</code></p>
   <p><code> [Y | Список2]) :-</code></p>
   <p><code> разбиениесписка( Список, Список1, Список2).</code></p>
   <p><strong>3.10</strong></p>
   <p><code>можетзавладеть( состояние( _, _, _, имеет), [] ).</code></p>
   <p><code>  % Ничего не надо делать</code></p>
   <p><code>можетзавладеть( Состояние, [Действие | Действия]):-</code></p>
   <p><code> ход( Состояние, Действие, НовоеСостояние),</code></p>
   <p><code>  % Первое действие</code></p>
   <p><code> можетзавладеть( НовоеСостояние, Действия).</code></p>
   <p><code>  % Оставшиеся действия</code></p>
   <p><strong>3.11</strong></p>
   <p><code>линеаризация( [Голова | Хвост], ЛинейныйСписок ) :-</code></p>
   <p><code>  % Линеаризация непустого списка</code></p>
   <p><code> линеаризация( Голова, ЛинейнаяГолова ),</code></p>
   <p><code> линеаризация( Хвост, ЛинейныйХвост ),</code></p>
   <p><code> конк( ЛинейнаяГолова, ЛинейныйХвост,</code></p>
   <p><code> ЛинейныйСписок ).</code></p>
   <p><code>линеаризация( [], [] ). % Линеаризация пустого списка</code></p>
   <p><code>линеаризация( X, [X] ).</code></p>
   <p><code> % Линеаризация объекта, не являющегося списком</code></p>
   <empty-line/>
   <p><code>% Замечание: при попытке получить от этой программы более</code></p>
   <p><code>% одного варианта решения выдается бессмыслица</code></p>
   <p><strong>3.12</strong></p>
   <p><code>Терм1 = играет_в( джимми, и( футбол, сквош) )</code></p>
   <p><code>Терм2 = играет_в( сьюзан, и( теннис,</code></p>
   <p><code> и( баскетбол, волейбол) ) )</code></p>
   <p><strong>3.13</strong></p>
   <p><code>:- op( 300, xfx, работает)</code></p>
   <p><code>:- op( 200, xfx, в)</code></p>
   <p><code>:- op( 100, xfx, нашем)</code></p>
   <p><strong>3.14</strong></p>
   <p>(a) А = 1 + 0</p>
   <p>(b) В = 1 + 1 + 0</p>
   <p>(c) С = 1 + 1 + 1 + 1 + 0</p>
   <p>(d) D = 1 + 1 + 0 + 1</p>
   <p><strong>3.15</strong></p>
   <p><code>:- op( 100, xfx, входит_в)</code></p>
   <p><code>:- op( 300, fx, конкатенация_списков)</code></p>
   <p><code>:- op( 200, xfx, дает)</code></p>
   <p><code>:- op( 100, xfx, и)</code></p>
   <p><code>:- op( 300, fx, удаление_элемента)</code></p>
   <p><code>:- op( 100, xfx, из_списка) % Принадлежность к списку</code></p>
   <empty-line/>
   <p><code>Элемент входит_в [Элемент | Список].</code></p>
   <p><code>Элемент входит_в [Первый | СписокОстальных] :-</code></p>
   <p><code> Элемент входит_в СписокОстальных.</code></p>
   <empty-line/>
   <p><code>% Конкатенация списков</code></p>
   <p><code>конкатенация_списков [] и Список дает Список.</code></p>
   <p><code>конкатенация_списков [X | L1] и L2 дает [X | L3] :-</code></p>
   <p><code> конкатенация_списков L1 и L2 дает L3.</code></p>
   <empty-line/>
   <p><code>% Удаление элемента из списка</code></p>
   <p><code>удаление_элемента Элемент из_списка</code></p>
   <p><code> [Элемент | ОстальныеЭлементы]</code></p>
   <p><code> дает ОстальныеЭлементы.</code></p>
   <p><code>удаление_элемента Элемент из_списка</code></p>
   <p><code> [Первый | ОстальныеЭлементы]</code></p>
   <p><code> дает [Первый | НовСписОстЭлементов] :-</code></p>
   <p><code> удаление_элемента Элемент из_списка</code></p>
   <p><code> ОстальныеЭлементы дает НовСписОстЭлементов.</code></p>
   <p><strong>3.16</strong></p>
   <p><code>max( X, Y, X) :-</code></p>
   <p><code> X &gt;= Y.</code></p>
   <p><code>max( X, Y, Y) :-</code></p>
   <p><code> X &lt;Y.</code></p>
   <p><strong>3.17</strong></p>
   <p><code>максспис( [X], X).</code></p>
   <p><code>  % Максимум в одноэлементном списке</code></p>
   <p><code>максспис( [X, Y | Остальные], Мах) :-</code></p>
   <p><code>  % В списке есть по крайней мере два элемента?</code></p>
   <p><code>максспис( [Y | Остальные], МаксОстальные),</code></p>
   <p><code> mах( X, МаксОстальные, Мах).</code></p>
   <p><code>  % Мах наибольшее из чисел X и МаксОстальные</code></p>
   <p><strong>3.18</strong></p>
   <p><code>сумспис( [], 0).</code></p>
   <p><code>сумспис( [Первый | Остальные], Сумма) :-</code></p>
   <p><code> сумспис( Остальные, СуммаОстальных),</code></p>
   <p><code> Сумма is Первый + СуммаОстальных.</code></p>
   <p><strong>3.19</strong></p>
   <p><code>упорядоченный ([]).</code></p>
   <p><code>  % Одноэлементный список является упорядоченным</code></p>
   <p><code>упорядоченный( [X, Y | Остальные] :-</code></p>
   <p><code> X =&lt; Y,</code></p>
   <p><code> упорядоченный( [Y | Остальные] ).</code></p>
   <p><strong>3.20</strong></p>
   <p><code>подсумма( [], 0, []).</code></p>
   <p><code>подсумма( [N | Список], Сумма, [N | Подмн]) :-</code></p>
   <p><code>  % N принадлежит подмножеству</code></p>
   <empty-line/>
   <p><code>Сумма1 is Сумма - N,</code></p>
   <p><code> подсумма( Список, Сумма1, Подмн).</code></p>
   <empty-line/>
   <p><code>подсумма( [N | Список], Сумма, Подмн) :-</code></p>
   <p><code>  % N не принадлежит подмножеству</code></p>
   <p><code> подсумма( Список, Сумма, Подмн).</code></p>
   <p><strong>3.21</strong></p>
   <p><code>между( N1, N2, N1) :-</code></p>
   <p><code> N1 =&lt; N2.</code></p>
   <p><code>между( N1, N2, X) :-</code></p>
   <p><code> N1 &lt; N2,</code></p>
   <p><code> HoвoeN1 is N1 + 1,</code></p>
   <p><code> между( HoвoeN1, N2, X).</code></p>
   <p><strong>3.22</strong></p>
   <p><code>:- op( 900, fx, если).</code></p>
   <p><code>:- op( 800, xfx, то).</code></p>
   <p><code>:- op( 700, xfx, иначе).</code></p>
   <p><code>:- op( 600, xfx, :=).</code></p>
   <empty-line/>
   <p><code>если Вел1 &gt; Вел2 то Перем := Вел3</code></p>
   <p><code> иначе ЧтоУгодно :-</code></p>
   <p><code> Вел1 &gt; Вел2,</code></p>
   <p><code> Перем = Вел3.</code></p>
   <p><code>если Вел1 &gt; Вел2 то ЧтоУгодно</code></p>
   <p><code> иначе Перем := Вел4 :-</code></p>
   <p><code> Вел1 =&lt; Вел2,</code></p>
   <p><code> Перем = Вел4.</code></p>
   <subtitle>Глава 4</subtitle>
   <p><strong>4.1</strong></p>
   <p>(a)<code> ?- семья(членсемьи( _, Фамилия, _, _ ), _, []).</code></p>
   <p>(b)<code> ?- ребенок( членсемьи( Имя, Фамилия, _,</code> </p>
   <p><code>    работает( _, _ ) )).</code></p>
   <p>(c)<code> семья(членсемьи( _, Фамилия, _, неработает),</code></p>
   <p><code>    членсемьи( _, _, _, работает( _, _ ) ),_ ).</code></p>
   <p>(d)<code> ?- семья( Муж, Жена, Дети),</code></p>
   <p><code>    датарождения( Муж, дата( _, _, Год1) ),</code></p>
   <p><code>    датарождения( Жена, дата( _, _, Год2) ),</code></p>
   <p><code>    ( Год1 - Год2 &gt;= 15;</code></p>
   <p><code>      Год2 - Год1 &gt;= 15 ),</code></p>
   <p><code>    принадлежит( Ребенок, Дети).</code></p>
   <p><strong>4.2</strong></p>
   <p><code>близнецы( Ребенок1, Ребенок2) :-</code></p>
   <p><code> семья( _, _, Дети),</code></p>
   <p><code> удалить( Ребенок1, Дети, ДругиеДети),</code></p>
   <p><code>  % Выделить первого ребенка</code></p>
   <p><code> принадлежит( Ребенок2, ДругиеДети),</code></p>
   <p><code> принадлежит( Ребенок1, Дата),</code></p>
   <p><code> принадлежит( Ребенок2, Дата).</code></p>
   <p><strong>4.3</strong></p>
   <p><code><emphasis>n</emphasis>_элемент( 1, [X | L], X).</code></p>
   <p><code>  % X - первый элемент списка [X | L]</code></p>
   <p><code><emphasis>n</emphasis>_элемент( N, [Y | L], X) :-</code></p>
   <p><code>  % X - n-й элемент [Y | L]</code></p>
   <p><code> N1 is N - 1,</code></p>
   <p><code><emphasis> n</emphasis>_элемент( N1, L, X).</code></p>
   <p><strong>4.4</strong></p>
   <p>Входная цепочка укорачивается на каждом неспонтанном цикле, а укорачиваться бесконечно она не может.</p>
   <p><strong>4.5</strong></p>
   <p><code>допускается( S, [], _ ) :-</code></p>
   <p><code> конечное( S).</code></p>
   <p><code>допускается( S, [X | Остальные], Макс_переходов) :-</code></p>
   <p><code> Макс_переходов &gt; 0,</code></p>
   <p><code> переход( S, X, S1),</code></p>
   <p><code> НовыйМакс is Макс_переходов - 1,</code></p>
   <p><code> допускается( S1, Остальные, НовыйМакс).</code></p>
   <p><code>допускается( S, Цепочка, Макс_переходов) :-</code></p>
   <p><code> Макс_переходов &gt; 0,</code></p>
   <p><code> спонтанный( S, S1),</code></p>
   <p><code> НовыйМакс is Макс_переходов - 1,</code></p>
   <p><code> допускается( S1, Цепочка, НовыйМакс).</code></p>
   <p><strong>4.7</strong></p>
   <p>(а)<code> ходконя( X/Y, X1/Y1) :-</code></p>
   <p><code>     % Ход коня с поля X/Y на поле X1/Y1</code></p>
   <p><code>    ( dxy( DX, DY);</code></p>
   <p><code>     % Расстояния по направлениям X и Y</code></p>
   <p><code>    dxy( DY, DX) ),</code></p>
   <p><code>     % Или расстояния по направлениям Y и X</code></p>
   <p><code>    X1 is X + DX,</code></p>
   <p><code>     % X1 расположен в пределах шахматной доски</code></p>
   <p><code>    надоске( X1),</code></p>
   <p><code>    Y1 is Y + DY,</code></p>
   <p><code>     % Y1 расположен в пределах шахматной доски</code></p>
   <p><code>    надоске( Y1).</code></p>
   <empty-line/>
   <p><code>   dxy( 2, 1).   % 2 поля вправо, 1 поле вперед</code></p>
   <p><code>   dxy( 2, -1).  % 2 поля вправо, 1 поле назад</code></p>
   <p><code>   dxy( -2, 1).  % 2 поля влево, 1 поле вперед</code></p>
   <p><code>   dxy( -2, -1). % 2 поля влево, 1 поле назад</code></p>
   <empty-line/>
   <p><code>   надоске( Коорд) :-</code></p>
   <p><code>     % Координаты в пределах доски</code></p>
   <p><code>    0 &lt; Коорд,</code></p>
   <p><code>    Коорд &lt; 9.</code></p>
   <p>(b)<code> путьконя( [ Поле]). % Конь стоит на поле Поле</code></p>
   <p><code>   путьконя( [S1, S2 | Остальные] ) :-</code></p>
   <p><code>    ходконя( S1, S2),</code></p>
   <p><code>    путьконя( [S2 | Остальные]).</code></p>
   <p>(c)<code> ?- путьконя( [2/1, R, 5/4, S, X/8] ).</code></p>
   <subtitle>Глава 5</subtitle>
   <p><strong>5.1</strong></p>
   <p>(a)<code> X = 1;</code></p>
   <p><code>   X = 2</code></p>
   <p>(b)<code> X = 1;</code></p>
   <p><code>   Y = 1;</code></p>
   <empty-line/>
   <p><code>   X = 1;</code></p>
   <p><code>   Y = 2;</code></p>
   <empty-line/>
   <p><code>   X = 2;</code></p>
   <p><code>   Y = 1;</code></p>
   <empty-line/>
   <p><code>   X = 2;</code></p>
   <p><code>   Y = 2;</code></p>
   <p>(c)<code> X = 1;</code></p>
   <p><code>   Y = 1;</code></p>
   <empty-line/>
   <p><code>   X = 1;</code></p>
   <p><code>   Y = 2;</code></p>
   <p><strong>5.2</strong></p>
   <p><code>класс( Число, положительное) :-</code></p>
   <p><code> Число &gt; 0, !.</code></p>
   <p><code>класс( 0, нуль) :- !.</code></p>
   <p><code>класс( Число, отрицательное).</code></p>
   <p><strong>5.3</strong></p>
   <p><code>разбить( [], [], []).</code></p>
   <p><code>разбить( [X | L], [X | L1], L2) :-</code></p>
   <p><code> X &gt;= 0, !,</code></p>
   <p><code> разбить( L, L1, L2).</code></p>
   <p><code>разбить( [X | L], L1, [X | L2]) .</code></p>
   <p><code> разбить( L, L1, L2).</code></p>
   <p><strong>5.4</strong></p>
   <p><code>принадлежит( Некто, Кандидаты),</code></p>
   <p><code> not принадлежит( Некто, Исключенные)</code></p>
   <p><strong>5.5</strong></p>
   <p><code>разность( [], _, []).</code></p>
   <p><code>разность( [X | L1], L2, L):-</code></p>
   <p><code> принадлежит( X, L2), !,</code></p>
   <p><code> разность( L1, L2, L).</code></p>
   <p><code>разность( [X | L1], L2, [X | L]) :-</code></p>
   <p><code> разность( L1, L2, L).</code></p>
   <p><strong>5.6</strong></p>
   <p><code>унифицируемые( [], _, []).</code></p>
   <p><code>унифицируемые( [Первый | Остальные], Терм, Список) : -</code></p>
   <p><code> not( Первый = Терм), !,</code></p>
   <p><code> унифицируемые( Остальные, Терм, Список).</code></p>
   <p><code>унифицируемые( [Первый | Остальные], Терм,</code></p>
   <p><code> [Первый | Список] ) :-</code></p>
   <p><code> унифицируемые( Остальные, Терм, Список).</code></p>
   <subtitle>Глава 6</subtitle>
   <p><strong>6.1</strong></p>
   <p><code>найтитерм( Терм) :-</code></p>
   <p><code>  % Пусть текущий входной поток - это файл f</code></p>
   <p><code> read( Терм), !,</code></p>
   <p><code>  % Текущий терм из f сопоставим с Терм'ом?</code></p>
   <p><code> write( Терм);      % Если да - вывести его на терминал</code></p>
   <p><code>  найтитерм( Терм). % В противном случае - обработать</code></p>
   <p><strong>6.2</strong></p>
   <p><code>найтитермы( Терм) :-</code></p>
   <p><code> read( ТекущийТерм),</code></p>
   <p><code> обработать( ТекущийТерм, Терм).</code></p>
   <empty-line/>
   <p><code>обработать( end_of_file, _ ) :- !.</code></p>
   <p><code>обработать( ТекущийТерм, Терм) :-</code></p>
   <p><code> ( not( ТекущийТерм = Терм), !;</code></p>
   <p><code>    % Термы несопоставимы</code></p>
   <p><code> write( ТекущийТерм), nl),</code></p>
   <p><code>  % В противном случае вывести текущий терм</code></p>
   <p><code> найтивсетермы( Терм).</code></p>
   <p><code>  % Обработать оставшуюся часть файла</code></p>
   <p><strong>6.4</strong></p>
   <p><code>начинается( Атом, Символ) :-</code></p>
   <p><code> name( Символ, [ Код]),</code></p>
   <p><code> name( Атом, [Код | _ ]).</code></p>
   <p><strong>6.5</strong></p>
   <p><code>plural( Существительное, Существительные) :-</code></p>
   <p><code> name( Существительное, СписокКодов),</code></p>
   <p><code> name( s, КодS),</code></p>
   <p><code> конк( СписокКодов, КодS, НовыйСписокКодов),</code></p>
   <p><code> name( Существительные, НовыйСписокКодов).</code></p>
   <subtitle>Глава 7</subtitle>
   <p><strong>7.2</strong></p>
   <p><code>добавить( Элемент, Список) :-</code></p>
   <p><code> var( Список), !,</code></p>
   <p><code>  % Переменная Список представляет пустой список</code></p>
   <p><code>Список = [Элемент | Хвост].</code></p>
   <p><code>добавить( Элемент, [ _ | Хвост]) :-</code></p>
   <p><code> добавить( Элемент, Хвост).</code></p>
   <empty-line/>
   <p><code>принадлежит( X, Список) :-</code></p>
   <p><code> var( Список), !,</code></p>
   <p><code>  % Переменная Список представляет пустой список,</code></p>
   <p><code>  % поэтому X не может ему принадлежать</code></p>
   <p><code> fail.</code></p>
   <p><code>принадлежит( X, [X | Хвост]).</code></p>
   <p><code>принадлежит( X, [ _ | Хвост] ) :-</code></p>
   <p><code> принадлежит( X, Хвост).</code></p>
   <subtitle>Глава 8</subtitle>
   <p><strong>8.2</strong></p>
   <p><code>добавить_в_конец( L1-[Элемент | Z2], Элемент, L1 - Z2).</code></p>
   <p><strong>8.3</strong></p>
   <p><code>обратить( А - Z, L - L) :-</code></p>
   <p><code>  % Результатом является пустой список,</code></p>
   <p><code>  % если A-Z представляет пустой список</code></p>
   <p><code> А == Z, !.</code></p>
   <p><code>обратить( [X | L] - Z, RL - RZ ) :-</code></p>
   <p><code>  % Непустой список</code></p>
   <p><code> обратить( L - Z, RL - [X | RZ].</code></p>
   <subtitle>Глава 9</subtitle>
   <p><strong>9.1</strong></p>
   <p><code>список( []).</code></p>
   <p><code>список( [ _ | Хвост]) :-</code></p>
   <p><code> список( Хвост).</code></p>
   <p><strong>9.2</strong></p>
   <p><code>принадлежит( X, X затем ЧтоУгодно).</code></p>
   <p><code>принадлежит( X, Y затем Спис) :-</code></p>
   <p><code> принадлежит( X, Спис).</code></p>
   <p><strong>9.3</strong></p>
   <p><code>преобр( [ , ничего_не_делать).</code></p>
   <p><code>преобр( [Первый | Хвост], Первый затем Остальные):-</code></p>
   <p><code> преобр( Хвост, Остальные).</code></p>
   <p><strong>9.4</strong></p>
   <p><code>преобр( [ , ПустСпис, _, ПустСпис).</code></p>
   <p><code>  % Случай пустого списка</code></p>
   <p><code>преобр( [Первый | Хвост], НовСпис, Функтор, Пустой) :-</code></p>
   <p><code> НовСпис =.. [Функтор, Первый, НовХвост],</code></p>
   <p><code> преобр( Хвост, НовХвост, Функтор, Пустой).</code></p>
   <p><strong>9.8</strong></p>
   <p><code>сорт1( [], []).</code></p>
   <p><code>сорт1( [X], [X]).</code></p>
   <p><code>сорт1( Спис, УпорСпис) :-</code></p>
   <p><code> разбить( Спис, Спис1, Спис2),</code></p>
   <p><code>  % Разбить на 2 прибл. равных списка</code></p>
   <p><code> сорт1( Спис1, Упор1),</code></p>
   <p><code> сорт1( Спис2, Упор2),</code></p>
   <p><code> слить( Упор1, Упор2, УпорСпис).</code></p>
   <p><code>  % Слить отсортированные списки</code></p>
   <empty-line/>
   <p><code>разбить( [], [], []).</code></p>
   <p><code>разбить( [X], [X], []).</code></p>
   <p><code>разбить( [X, Y | L], [X | L1], [Y | L2]) :-</code></p>
   <p><code>  % X и Y помещаются в разные списки</code></p>
   <p><code> разбить( L, L1, L2).</code></p>
   <p><strong>9.9</strong></p>
   <p>(а)<code> двдерево( nil).</code></p>
   <p><code>   двдерево( д( Лев, Кор, Прав) ) :-</code></p>
   <p><code>    двдерево( Лев),</code></p>
   <p><code>    двдерево( Прав).</code></p>
   <p><strong>9.10</strong></p>
   <p><code>глубина( пусто, 0).</code></p>
   <p><code>глубина( д( Лев, Кор, Прав), Г) :-</code></p>
   <p><code> глубина( Лев, ГЛ),</code></p>
   <p><code> глубина( Прав, ГП),</code></p>
   <p><code> макс( ГЛ, ГП, МГ),</code></p>
   <p><code> Г is МГ + 1.</code></p>
   <empty-line/>
   <p><code>макс( А, В, А) :-</code></p>
   <p><code> А &gt;= В, !.</code></p>
   <p><code>макс( А, В, В).</code></p>
   <p><strong>9.11</strong></p>
   <p><code>линеаризация( nil, []).</code></p>
   <p><code>линеаризация( д( Лев, Кор, Прав), Спис) :-</code></p>
   <p><code> линеаризация( Лев, Спис1),</code></p>
   <p><code> линеаризация( Прав, Спис2),</code></p>
   <p><code> конк( Спис1, [Кор | Спис2], Спис).</code></p>
   <p><strong>9.12</strong></p>
   <p><code>максэлемент( д( _, Кор, nil), Кор) :- !.</code></p>
   <p><code>  % Корень - самый правый элемент</code></p>
   <p><code>максэлемент( д( _, _, Прав,), Макс) :-</code></p>
   <p><code>  % Правое поддерево непустое</code></p>
   <p><code> максэлемент( Прав, Макс).</code></p>
   <p><strong>9.13</strong></p>
   <p><code>внутри( Элем, д( _, Элем, _ ), [ Элем]).</code></p>
   <p><code>внутри( Элем, д( Лев, Кор, _ ), [Кор | Путь]) :-</code></p>
   <p><code> больше( Кор, Элем),</code></p>
   <p><code> внутри( Элем, Лев, Путь).</code></p>
   <p><code>внутри( Элем,д( _, Кор, Прав), [Кор | Путь]) :-</code></p>
   <p><code> больше( Элем, Кор),</code></p>
   <p><code> внутри( Элем, Прав, Путь).</code></p>
   <p><strong>9.14</strong></p>
   <p><code>% Отображение двоичного дерева, растущего сверху вниз</code></p>
   <p><code>% Предполагается, что каждая вершина занимает при печати</code></p>
   <p><code>% один символ</code></p>
   <p><code>отобр( Дер) :-</code></p>
   <p><code> уровни( Дер, 0, да).</code></p>
   <p><code>  % Обработать все уровни</code></p>
   <empty-line/>
   <p><code>уровни( Дер, Уров, нет) :- !.</code></p>
   <p><code>  % Ниже уровня Уров больше нет вершин</code></p>
   <p><code>уровни( Дер, Уров, да) :-</code></p>
   <p><code>  % Обработать все уровни, начиная с Уров</code></p>
   <p><code> вывод( Дер, Уров, 0, Дальше), nl,</code></p>
   <p><code>  % Вывести вершины уровня Уров</code></p>
   <p><code> Уров1 is Уров + 1,</code></p>
   <p><code> уровни( Дер, Уров1, Дальше).</code></p>
   <p><code>  % Обработать следующие уровни</code></p>
   <empty-line/>
   <p><code>вывод( nil, _, _, _, _ ).</code></p>
   <p><code>вывод( д( Лев, X, Прав), Уров, ГлубХ, Дальше) :-</code></p>
   <p><code> Глуб1 is ГлубХ + 1,</code></p>
   <p><code> вывод( Лев, Уров, Глуб1, Дальше),</code></p>
   <p><code>  % Вывод левого поддерева</code></p>
   <p><code> ( Уров = ГлубХ, !,</code></p>
   <p><code>  % X на нашем уровне?</code></p>
   <p><code> write( X), Дальше = да;</code></p>
   <p><code>  % Вывести вершину, продолжить</code></p>
   <p><code> write(' ') ),</code></p>
   <p><code>  % Иначе - оставить место</code></p>
   <p><code> вывод( Прав, Уров, Глуб1, Дальше).</code></p>
   <p><code>  % Вывод левого поддерева</code></p>
   <subtitle>Глава 10</subtitle>
   <p><strong>10.1</strong></p>
   <p><code>внутри( Элем, л( Элем)). % Элемент найден в листе</code></p>
   <p><code>внутри( Элем, в2( Д1, М, Д2) ):-</code></p>
   <p><code>  % Вершина имеет два поддерева</code></p>
   <p><code> больше( М, Элем), !,    % Вершина не во втором поддереве</code></p>
   <p><code> внутри( Элем, Д1);      % Поиск в первом поддереве</code></p>
   <p><code> внутри( Элем, Д2).      % Иначе - во втором поддереве</code></p>
   <p><code>внутри( Элем, в3( Д1, M2, Д2, М3, Д3) ):-</code></p>
   <p><code>  % Вершина имеет три поддерева</code></p>
   <p><code> больше( M2, Элем), !,</code></p>
   <p><code>  % Элемент не во втором и не в третьем поддереве</code></p>
   <p><code> внутри( Элем, Д1);      % Поиск в первом поддереве</code></p>
   <p><code> больше( M3, Элем), !,   % Элемент не в третьем поддереве</code></p>
   <p><code> внутри( Элем, Д2);      % Поиск во втором поддереве</code></p>
   <p><code> внутри( Элем, Д3).      % Поиск в третьем поддереве</code></p>
   <p><strong>10.3</strong></p>
   <p><code>avl( Дер) :-</code></p>
   <p><code> аvl( Дер, Глуб).  % Дер является AVL-деревом глубины Глуб</code></p>
   <p><code>avl( nil, 0).      % Пустое дерево - AVL -дерево глубины 0</code></p>
   <p><code>avl( д( Лев, Кор, Прав), Г) :-</code></p>
   <p><code> avl( Лев, ГЛ),</code></p>
   <p><code> avl( Прав, ГП),</code></p>
   <p><code> ( ГЛ is ГП; ГЛ is ГП + 1; ГЛ is ГП - 1),</code></p>
   <p><code>  % Глубины поддеревьев примерно совпадают</code></p>
   <p><code> макс( ГЛ, ГП, Г).</code></p>
   <empty-line/>
   <p><code>макс1( U, V, М) :- % М = 1 + макс( U, V)</code></p>
   <p><code> U &gt; V, !, М is U + 1;</code></p>
   <p><code> М is V + 1.</code></p>
   <subtitle>Глава 11</subtitle>
   <p><strong>11.1</strong></p>
   <p><code>вглубину1( [Верш | Путь], [Верш | Путь]) :-</code></p>
   <p><code> цель( Верш).</code></p>
   <p><code>вглубину1( [Верш | Путь], Решение) :-</code></p>
   <p><code> после( Верш, Верш1),</code></p>
   <p><code> not принадлежит( Верш1, Путь),</code></p>
   <p><code> вглубину1( [ Верш1, Верш | Путь], Решение).</code></p>
   <p><strong>11.6</strong></p>
   <p><code>решить( СтартМнож, Решение) :-</code></p>
   <p><code>  % СтартМнож - множество стартовых вершин</code></p>
   <p><code> bagof( [Верш], принадлежит( Верш, СтартМнож),</code></p>
   <p><code>  Пути),</code></p>
   <p><code> вширину( Пути, Решение).</code></p>
  </section>
 </body>
 <body name="notes">
  <title>
   <p>Примечания</p>
  </title>
  <section id="n_1">
   <title>
    <p>1</p>
   </title>
   <p>Чем выше приоритет, тем меньше его номер. — <emphasis>Прим. перев</emphasis>.</p>
  </section>
 </body>
 <binary id="_3.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAgEAZABkAAD/7QfGUGhvdG9zaG9wIDMuMAA4QklNA+0AAAAAABAAY//z
AAIAAgBj//MAAgACOEJJTQQNAAAAAAAEAAAAeDhCSU0D8wAAAAAACAAAAAAAAAAAOEJJTQQK
AAAAAAABAAA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAG
AAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAG
AAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA////////
/////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////
////////////////////////A+gAADhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklN
BBQAAAAAAAQAAAATOEJJTQQMAAAAAAY1AAAAAQAAAEgAAABwAAAA2AAAXoAAAAYZABgAAf/Y
/+AAEEpGSUYAAQIBAEgASAAA//4AJkZpbGUgd3JpdHRlbiBieSBBZG9iZSBQaG90b3Nob3Co
IDUuMP/uAA5BZG9iZQBkgAAAAAH/2wCEAAwICAgJCAwJCQwRCwoLERUPDAwPFRgTExUTExgR
DAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBDQsLDQ4NEA4OEBQODg4UFA4O
Dg4UEQwMDAwMEREMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIAHAA
SAMBIgACEQEDEQH/3QAEAAX/xAE/AAABBQEBAQEBAQAAAAAAAAADAAECBAUGBwgJCgsBAAEF
AQEBAQEBAAAAAAAAAAEAAgMEBQYHCAkKCxAAAQQBAwIEAgUHBggFAwwzAQACEQMEIRIxBUFR
YRMicYEyBhSRobFCIyQVUsFiMzRygtFDByWSU/Dh8WNzNRaisoMmRJNUZEXCo3Q2F9JV4mXy
s4TD03Xj80YnlKSFtJXE1OT0pbXF1eX1VmZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3EQACAgEC
BAQDBAUGBwcGBTUBAAIRAyExEgRBUWFxIhMFMoGRFKGxQiPBUtHwMyRi4XKCkkNTFWNzNPEl
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
NjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAC5J
RUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGlu
IElFQzYxOTY2LTIuMQAAAAAAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBp
biBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHZpZXcAAAAAABOk/gAU
Xy4AEM8UAAPtzAAEEwsAA1yeAAAAAVhZWiAAAAAAAEwJVgBQAAAAVx/nbWVhcwAAAAAAAAAB
AAAAAAAAAAAAAAAAAAAAAAAAAo8AAAACc2lnIAAAAABDUlQgY3VydgAAAAAAAAQAAAAABQAK
AA8AFAAZAB4AIwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQ
AJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEBBwENARMBGQEf
ASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGaAaEBqQGxAbkBwQHJAdEB2QHh
AekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQCXQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLg
AusC9QMAAwsDFgMhAy0DOANDA08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQg
BC0EOwRIBFUEYwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWm
BbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkHKwc9B08HYQd0
B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjSCOcI+wkQCSUJOglPCWQJeQmP
CaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4KxQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5
DBIMKgxDDFwMdQyODKcMwAzZDPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62
DtIO7g8JDyUPQQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJ
EegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsUrRTOFPAVEhU0
FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReuF9IX9xgbGEAYZRiKGK8Y1Rj6
GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwbFBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0e
HUcdcB2ZHcMd7B4WHkAeah6UHr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGh
Ic4h+yInIlUigiKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaH
Jrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8rAis2K2krnSvR
LAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+RL8cv/jA1MGwwpDDbMRIxSjGC
Mbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDec
N9c4FDhQOIw4yDkFOUI5fzm8Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4g
PmA+oD7gPyE/YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUS
RVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxLU0uaS+JMKkxy
TLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGbUeZSMVJ8UsdTE1NfU6pT9lRC
VI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9YfVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyG
XNZdJ114XcleGl5sXr1fD19hX7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9
ZZJl52Y9ZpJm6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5r
bsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52m3b4d1Z3s3gR
eG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7CfyN/hH/lgEeAqIEKgWuBzYIw
gpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuHn4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zK
jTGNmI3/jmaOzo82j56QBpBukNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfg
mEyYuJkkmZCZ/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2
o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUStuK4trqGvFq+L
sACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfguFm40blKucK6O7q1uy67p7wh
vJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6
ybnKOMq3yzbLtsw1zLXNNc21zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY
11zX4Nhk2OjZbNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T8
5YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXxcvH/8ozzGfOn
9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26/kv+3P9t/////gAmRmlsZSB3
cml0dGVuIGJ5IEFkb2JlIFBob3Rvc2hvcKggNS4w/+4ADkFkb2JlAGSAAAAAAf/bAIQADAgI
CAkIDAkJDBELCgsRFQ8MDA8VGBMTFRMTGBEMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwM
DAwMDAwMDAENCwsNDg0QDg4QFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMDAwMDAwMDAwM
DAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgDJwIIAwEiAAIRAQMRAf/dAAQAIf/EAT8AAAEFAQEB
AQEBAAAAAAAAAAMAAQIEBQYHCAkKCwEAAQUBAQEBAQEAAAAAAAAAAQACAwQFBgcICQoLEAAB
BAEDAgQCBQcGCAUDDDMBAAIRAwQhEjEFQVFhEyJxgTIGFJGhsUIjJBVSwWIzNHKC0UMHJZJT
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</binary>
 <binary id="_6.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAN0AAAEbAQMAAABkzBNEAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQOCSEVUuRtgAAABQxJREFUeJyl2D1r5EYYB/AFB3IHAZ+rXEJggyF1jiuTgJo0
rgL5BOGuOFzdS5OQBObMFU4qQ/IBXF6ZdBfSjM0VxhDYJkW6sW/hNkVAu7FBq+jlibTWzPyf
kWas1Q3sLtLvkXY0GmmemRH5y3L0JjgSbNfRGHBJ+2hlNAWcUYaYUg6oqECcEQmLkkr8U0XV
Ho21SEC5co1kt+pSxcYGC451bGKwrmpssY7NDCYQ2gcLhtAKGcO4jWVPPNu+Be2XzLdvAf67
s4V4+eMW4uMdxPx0B3E3hDsBfPXhHahtsrx3p+elBFvoWvTeleD9LDjynuB0E96H6lAJKLH3
1aECsJJDi4fmolclZj1+RikeecGelZROEC/FK8ByFGGF4qdjOK1zKQofpKYSiMqL0kVoeN5C
9TfcMt629XfBMfNh0UJoP94TdC2akhB2MF1/QB3bwriNyqCC2AZtE0mIbTDhGHtQtNG0X4mx
DZomKjC2GwuGpv2yDjTtl2CsRtlgjLEelAwVsV+Ouv0kxmjUTSQwthc2baKvN2FYsJ8mVmPJ
TtAE9cKmJrpeJUcJtdSxBhV869h+GMPJdZTBBKqlYw1mcEE6th8W5svGGizNLhtrMwxB2PHL
Nn7twxfV5xeDq1iLL6vPpsXnDJ9V5wLcZ7hR4dsWNxjuEeX2yJLjeYWRPXKP4bxCYfGc4TIf
La3RIh8Ji/l9eg9weUEHkKCN6zzJlHxSjbMWBUu3yohSiyV7s9bZVWkxZW/WVeA3BjNiY1q9
+ZvB+l5Kjn8ZrPubspiEsN7826DKSMZefJlHgPVJ5hb3l8KLUmY4bDn4/H2BeHZjE/CnnQjx
8vSLAB4fho6c+PFPhicfsAr9cWMM10lseOaXsg7ytg3eleD9dHoCx2AfKogl+7z3uf2WsN9S
xCcYrMdXVcVnhSY0A7xP7yIuaAz4/QiTmyrBIvYgsf8kfLILXluOGX/K1sC6NsKH9V2RPlTE
87/+KInnf+R/jXN0BoA10BlXODojUgc6TeQbBTk64ydHBd8ejLtRhlBAtVx0MoxOLDqxCKGT
D3F0MqlulF0Yh1AR/2Woj4hDmHShCKCT33J0MuM10MnGOTp5PEdnerAGKrNDtdHGx2201UjW
w9d2x3/CxYXdgWnPFZ7DjhYe2R1nIczHLh7bHWULcd1pk+PT6ADw4CgCzL87gVPR609PAC8o
hRpW15wCxnxNKrGbq7k9u4kTNs+W/CbC5tWSAaJwFxuCyxTB1Y9sDSwYwkPQXnFxsPRhsgZO
f9iCZyuZ394DTE9/RkzvfgS4OH7G8LMH/Ej8z/STEN59wCuE17m4vWEx2EJO2waRN3zwfjrI
102cbuIsxwjewaJV79Qoeb9VrN9O+DuNL1gldoWqLlO2YLWkKeI/1ZNlkUZjRDXaROQFKtdG
MRTxPd7CIoTZYOx4GdvS8Rq3RQ1GGUIxFLtGQVO6xk9TuoblftiZCujSmUToogajDKEIYHea
1Qe7s7emdCeFTelOJ/ugJ0u9KiqEcjCKAPqS/FXxTQ+uR9+sY1V8k5lV8U6DqlKGkMahI0MI
y05rIuZfbRQhJC/ORws/TvhUmmPkth5gSXZYaGE6eCp97WzZi4qGTqXlG2Fwnj0MH93cfutj
H367++Tzh158NP/Sj1898ePvuwH89eb2O94KvZBDlylqkD4MLo0Eu0lyzVpN7sUitD5UzRhm
XqzmEId+nOJ6sov5Brn4P04vAzYZVDlCAAAAAElFTkSuQmCC</binary>
 <binary id="_5.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMgAAACWAQMAAAChElVaAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQOCSkrW1z6IwAAA2ZJREFUeJzN189q1EAYAPBZtrA9iEE96G1qQXpt8SSK+xI+
QA9F8Sj0UlBmSw85WAh0H6BHn0LcJYewVNiDd0kIWAUPE+shhZBxMn8yfzJf8eDBXZbdyW8y
+eabb7K7iEEP9HfSoikgFE0AWaAxIDP+DMuEURKUFrNmGhR+mGNIaj5UFBTKX3FQCv7KglKq
11BSUDKGSAHIM1YBcgRIzN4AkrArUC5BWYPXSQgU2zkozyFpoRzAeYNzDa8PvKZwHcC1A9cb
XKM31PUCjQCZgXIb7QKCxZRCUU9v2iVh4UNB+4f96/2TBiVT5w0lVtcaSqTiGwpmzEqPJWL+
Jj2WiIMmCZbIgYLSh+EL7UPXklezrc18oiaZ6jaXXwdfHm0frlWxl7otZbJ7mKpkFrotZefx
75W6AtVtLS9WKqqaqDYXWs22H3weq5k0RLW5XLGPzMy+maq2EJOcrsNVP5/CTg5PQuHnQK9M
MsiOXs14ILoC0oGUXg8jutKqgejx6UD0kunojWD1rmukl740Wl/6ctJdejElGPniB9mLKfXM
E7M9Uk/MbdJfBbMNqSdm69aemO2u4u8F96LmrMW6eaiPyO1ond4LMRI5YpKjw9RCLUkdKSwp
HSktKRzJLKGOxJbIJGiJLGkcwbZMLWltkQ1kd9MPR4gt7y35bgM7tiR3ZGnJ0pGFJQtHZpYc
O5JbcuKI+B4UMsOxI81bJKVBY+xIu4WwEIrs35TiGvynZCcLsiCujNqRkBNWu+c0EZ9GJxM3
1azrSAmSSY8c4VE3UyRXwI266rojueypI10hCWFuucl+CZJFVDnSlViM5FHqSHfVTNxHJ1Ht
SFLvCilZ8smT5h1LhWTEFdw+ZaWQb07ttBgzLRVfCLKIasQQzsfNCLP7YeGLkyi5HshaCXWv
Exn5SWpbmJGvXtSRkoLdwt5M2VjkYJi3ROWtAnMNr08XV+lI14pUHYjbQXm6PxHfWIWqg652
RIVcPHx9b4fJeETt8PBbUVXr0fVcnMzrrSaqRrGQJ9fzD92HBvMtJOqa5SI5F3tHczFaO2ay
rnMk99flKY3lFpupvVCbP1Hn8i1HkdxzKPKkRsT/P2dVvifsv5LV3p27G5tZQH4czM8OVvOA
0PzkbH9ZBiR/1Z3zJTTaS2g0HgHa2FwO5Q//dXNK+HbIAwAAAABJRU5ErkJggg==</binary>
 <binary id="_4.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAYEAAACQAQMAAADUakXtAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQOCS43ABwwqwAABEtJREFUeJzt2T+LG0cUAPA1gqgxkcs0yYKbSxfDNTExnhQp
A/kKCRjUCq64iBw3MldcE3xtSIS2TBlSuUixMmdYAkL7AVKsjoObIsGSWbBW1mpe5r3Z1e5G
t7oZh4Mz3BQa7e78NP9nZ+4csAw954YI30bwKUDC6Ks0EpJ7ADOuL1gmXhxhnOKHp5+06AY9
T7mK5hmnxxPHiUP8MsMfdPXvNvEzcTHpW975/ODTzlfpvd53Rx7WaNjLRJEHSwO8jNXFEt4c
dvuyvXO/++cofqgSRhChaL10WBrnIgKBNcYGSuGVFjsPMyHgVIlx+/efeSEECU9iPdjw8feP
PiTxYwPFEnpKPGuzAc9L1XPuwFQ6ThPcxHHc4eNu/wLF6GuVx9BxQN1NvgnYoFnUY6rKhVU8
wbaVh90RiVCXKgb1axDusMFeITysgeSgnq8gE/e7mVD9qcS4XREcfsC0sf5F/uCjuw86T1JX
t66XiV+UWNc864/XUamjRdGDz9QoaTSCu83Zbp4UUt2DrNTRosAvrhy707UwG4lZOC19vzFz
8BrEOX6kNK/y6XeFOMGPhMSYGQiOPbWC5RTnYGgifJwZEmcWLCAwESHVgKGQfMKvFGpGpW2a
URHOqNkGuCSPOQ3jiBZC9s/VeWCpYiqVj7UxqzkKiW2mam4kuGxj66KYQ2BSqmwVBUo72Xz6
/ozdW3Erbq7w8s2JqZCusM4jsBa/Wou2rRhY16PfuH7h2beurZBN6zyKYCZW1sJ6JyN3rfP4
21r8ZS2eW4t9WyHnpQsjUe4OM7G0FuVCmYmptYishW8tuK2QlaubtLb/P6HPtQmHfCsmDygK
jyVfzPQ9MSyL7FzLVFK9GicdilqNhJ9NDumIdPx0U1woQZtQtU/EPEIY76k8xgcCj2zCrwo8
18JuLjwSass+V0LimFqBOK4IOtcWYkpCbVwDJRJ99BR3KoLOtTgS5B7twpVQx3YeniuR8gA3
42JWFvpcSyOBVnxBeaQQvsZSMTy+cJGWhT7X0sSk1TgisYRwITtdYDFqISuCzrXLiBpIBUZC
wLir8ggfxag3hDrX4ikV3KIHIxh/MeCL4Mk+tpv4uCLoXDvBtuK6B+8xqlTzJ3fy7QX1+dOj
irAM7694h3nOrYVfL/yNFFSiyFpsWXdrxJa1vUZseX/UiC3vqBqx5T1YI7a8a+tE/fu8TtTv
GepE/b6kRsjYOo9GKY2ZWFiLcrg+4Z1bCumeWOfBLhWrP8oRhVeRjgc14nk5ovAmE/3WpUL+
Vo4ovM1K2K8543xWiSpiPVCqwq1EGLL1vlb4lYhKCO8qBrZnNdm8vK2Mwq2gEJ9RtCj2LV6r
+rr5rzgdUXS2/kul/KSZ/dejLo8BJV2McgF9IY2EXAtvurIVJ0szsb7jBXMjUbyTvPOJayKK
954Xm4m5n99RE2l7qXR/LIq/HPf32VYx1H0++TIX8oPWdmEUev8CPRD0SQpkE5EAAAAASUVO
RK5CYII=</binary>
 <binary id="_7.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAANoAAADAAQMAAABYnu9lAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQOCTgDPTBxyQAAArxJREFUeJzN2E1rE0EYB/BNC42Fgr2ZQ4sS3+htsQc9FNOj
h970A4h6yU1KD3qQjQS04sGDXoqWfAW9KmVbAg2ByApBCgpOe8pxEytkJZsZ98Uk+/Z/Niyb
tgMbCD+SnZmdfea/KwncdqXJoiEpGFuigrFiMURF/IVoCsEh9p0fA+xZh4qwS6FuHYxCHSEj
0VwoYOS3nU5FoioWKXxPYS0xtiisYmTiE4VPCTRlBc4QOfE2aAjt8x1Q+AWhvYaeIbRWHw+t
zQFyd3VGoyiIY4xaeCQj7PCLobU5RJ4JT9HoztZjMHhZxkfY2wlicHZ9GLwsKWGw2OxKh53S
pXOH2Wj8/ah5Nb+hRQ/Fwqy8UYV4fflPncB7ANudUj7XmHZQDeKx2BkOJQJH42RBPKJQpILi
FFCfDHbTxwyFZRFqaWAtDmGHbOwlQj0p2rUPYocXRLCNV29VolJzhajxfaeW9ER5XypdLuVW
Vjenbs1Lnn1FsT7rb9fevWqubC3V72xfW/VlEwcX9ppzW0t7jUUfMhc/aM0r1i8bfXmAuge/
3nXw+w0v6hZW96XNh/Kc1aEXyzODDjEz5+y8GrdPYIpf3qEMsok7TaZ/nOx/NnnpfDMUH6pi
mwoRr+OyCbiebjZJHRmNz53pAxiTTUhkCLsUuvkW3IJuMgboZmp08zppHGHFvh0QtsQbjMa8
EhzJWd8A2FlDcUI4dqqJwmGqicJhqolGN9WEM5gn1YTRm2oikBjnEYViTOwlxuSBO3nID7Y0
MENhOfyI7kX4AGVjaHf14k+MNbsQYTxPYRajxqcx6ibxt5pRgGjIT4LmLanhhOYvxghP6aUK
QziplypxSCSMpPhxNj91AeHn4vqDmxAft4sY769j/FEk8NtsfgZ26EA9+WxCvl5zwy/APrU0
ycBNRnU65LepxwNOlreIRuM/ooMOePLXjewAAAAASUVORK5CYII=</binary>
 <binary id="_8.png" content-type="image/png">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</binary>
 <binary id="_10.jpg_0" content-type="image/jpeg">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
IiIiIiIiIiIiIiJ//9k=</binary>
 <binary id="_11.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAhsAAAFTAQMAAACqClxiAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQODh8irtPFdwAACiZJREFUeJzt3L+P3MYVB/A9yMA1hldGGhUxtjsgVSSlkQ1F
VGEguECw/oRcAkGCqiiVZeTHWLhChYUcYjWyDYOdgKRJUgUugjnhEC/S5ADVjnnKBlmo2r1s
cdwsd144w+VwyPkOl1zyfCdZT7Dvlsv9cDgkZziPs9eh5nHQOXWIwNpBD38uOoOQsYCrd59h
ZBAxgOzTEG0w/gfDj//ZCKcZWDde5iFDMBoBhNEcrHxEFCAkXndiI5HSrdgnc4u5EhrbTJG5
KowVgSoMLKGwEVkh3F6ZE6wqVbxsmylyRHDvGcGqUqvayIjQ3gvKFTuP8KYIJ7PgGom+69lV
OKcnexgZ3wFIIK6A4zCnwQgdNOLhDCH0FkQOA4iw6H1j7zPkM4hMOUbEzyHSh0h8sUKEegDh
MWKfVjOJeJWRIG4JECJcJfEhsod3x3MgXYj8GSKznqNi+xD5ACJHPkbmQ9lMFJHoPEPI3jo+
2cZP0GlPbVw78X8DjMCSEBkttdme/NNeOQbmHCCyFH+EyNcYCQAiC/6+hZQ0j6iljpeJ7Dg0
aKizEzxFBD4MI3eXMc1erdh5RbkSasSPuzR7o1NHNxpvMzthM0SexvbuCxbhjmfHxDUSnvNQ
HW6fwR3PeMuow+xOaQg7u8jRe8W7j5ARRBxHTdU3gwiIthAcbSG8DURHHmHFVU8Zwush9upl
iHaqIIG1tEVEH88qh7gVBL5TF4HRFqIjj+CO9JtCxnd3z75254wCjPZx/cFa50cdT1Ch53ky
6Fx9c7dbQKYXb3/8u3duFZGHG5987zuPmYX8+++Pf/zuc18isxyy/eidn9rIo7e3H/cQ8sbW
8/s28vCT/90AJXnbf3wdIe/dev4QIX+4UaxUiXyaILMicvP3RSS8u/vm6zfXisj9B2tnv9zq
WcizQefdC4/WiyVZ3JcUEH+uFliHeEi/VD8Do0OSCEEk+QEQShEd8XmCka4D2YNI+ptE7B5z
hdMeI86hZBuIUbGrI3pXjwGxoyZyDyJhDx8hsV4TgSXEyDZGPIzQuvF7hshT0S64E+nWQKIT
QPryf8xCmOP62THWzt3H1kH8GogavFlL6yJwqRMp6YsRElB2O6OR6KyHkN0uRsI1hAzMAUwW
3iEsIPWFBxDfzAPqiPCwWA6l0KCJwbHkxBxDGyHg8E3gu03XQHKa69IKQ9oiEqgtFsunFoIE
5mJwXUS4eqe4NE1gpssLucfi6kxt0UaSe/igGRKoUhaR0vzJMSFcQUVEvkbpIMJXjgOJzqGc
UnTuA5yY2u56gX5VyIIWCj4XV55hpP+Vh1JkKgvKw87hvXN+tjtvTTEy4BD5XJ1W0cc3nl77
SfrujD53IBOE+PTRAtl6ek1/bEYfTeNdLOykRA4ZLIlKpcbIrafXvAzpy5IAJKQYGVnIcIHc
fHrNT9ed09CBRCUIhR/mK3YlJG6G/pqtu0ACiAQWMsoQI5wIdyD3kmW5J0uC7h38xhIkMr7c
zehWH0OUtidVEUfz6ELwo5k5RrjiAwvBD4kiKmntbSR5XFU8OrEQkavfsZGk30kboMIjvCKS
9IA2kvSAFuJ6mCj7YhtJ+mILcTzW7Mm7AoCouwILIccD1i5cnNyf2EhrWQvHPdvpQYLi0jYR
R8WeHsSKlxFBYcLHgNgfOWVIEHXu7j64XoKYGT8DMTJ+8b3Y5sXbG99Xy82M30wjZsbP6GOM
jJ9Ezt/e8NRyI+OXR3TGL4fojJ9EfvB8o5ciacYvj+iMH5mIzvgp5PbG9RRJM35FpDTjF1fs
VV2xRsbPQJZn/Eh2Vl8vlhsZP7MkVTJ+2fM6I+OnI5/xM4ZkfvJjgYz18uUZPwNZPeNnP/Ra
oaEGDwLLkKxiTydix8uIoDDhfNrQ3mTYw4bAGb/tthBuI14tZM+N2AUsS2Aya93IhcgLNG1N
82lDB2IXsAyxQ83Cq46gG+oSZKcGIlyIDxHHg3gGbRcS32f/BSAOI5d+yyYnxAMEcB9fb/Kk
nCYBkHqTJ32aCBtJxjvcRvDkSUbzaN1adwaHl6q+h3bFxhUofmWXZAhHy+rjMxuRr+961sqB
cmwkEYqIPEX+ZK0rP26nqygdFxcR2VnsWes6E5jJCB0hoJVlanPMWh6kyMGZL1/72VbDrMV/
Nx9uXjAR3P9BhC+gGNnevJClgzpwKtpyxN88nyGXUQJTvH6JMYRsv9FbIJ9tXtzSCJ5Z17vj
oamCrP9VdyQL+i+zYgP6BUR++x+MDL7YUQjtiyMjbTgBbdKc/kEYmfD9BUL5PBua9/g38tCk
RXbIFsj9HIJmXc1oQIyB48NCCkbWGRvQDjzEE0EQiYgjxMfIHOdjI2IIuYKRWYARcZQ9VtEZ
P9Fh9rUTI2MPITyKaqQNdw+uAIP4+BJAcFOQXICgYjmV5B6LweQuASRQCGoeub2yQkD2Ebds
jnmPXPIYAW2swA1HIHcUILihdsx7VLlH8EYyedJC8CO88smTFjKEDxOdkyfxc8DwElpbxJcr
jH04edJx4/eh3cmrGF81XmQIjnp3SiUInAwaELpnexEQOOH3xUVgSMQeSK6ApPFiIa4pi+0g
dSo2QG9UQoy0YQ7BaUMHYqQNcwhOGzoRnTYsIiBt6C6JThsWEJA2LEE+dSBp2jANJ5JPG2Zh
pg2XIhUmClZAkh8SYXmEqiNG2jCHmGnDOmcsQ2/URPCFfBIIjpcQSeMbQcIe7rscybrjRDzc
TivEfuZVD1HXVlUk8nBjXxNxHJ9aCDMzUEbs1EM8+IZfA4nvhvFTdN/4vQLSa47QmME3ghrI
QXcMl4cwbeiI3iHOG/blQatYsRGJW/ANT1aKNesDx8z8xp4RQnVAFZEh4YmZSdqwIhI4boUd
k1hwcMfwIBmNVkRY6XeuqyPOKUZMvypHlqcNmyCczBO/HFkyZbEqMsZfg2UqbVitYuc02XdN
WeyOdFmWIa5v9Q6+2K+B9FxTFoOqyExerhwhh6xXHXF95zqkneq7E+FDzCLq25MnXUh45EKG
1ZGpC5kOg8rIZIjP2CgcVUUEHazja2d8OT5jeUWk5ALkFZElUxYbIknLVhHh7uZRUFUkcH/n
el4ZqTdV3hFHtSbtO6Jm2hCH8FxpQ2Hgy24tdl1pwzXjxTLEGQFljcQrRCP6+j5xRMcrRCO6
zfu2I0bacHUEf7+4PqLThk0QnTZshFROG7qiVtrQFUbaUPc8KyDUHDHShqsjabSF6K7+xBEd
r5D2EJms46cCoVaQrjGaOnFEx8rIThuI3w5SdSBZimQJuAan/UFjJFyjXdYU6QvvSeOSxEOV
bA7diogcNGWzGVZE5PAtO91WRGTasDEi04Z+U0SerV5TJKDqGb/jRThVz/gdL8KitTaQSfP2
RP4xwBYQ9GcJ6yK03wbSQhsr/5Rkc0T8sA3k1y2csdG0BSRs4YyVAD8VCP6mc83A33SuGbNc
YrNBv9MYqZU2dEadtKEz+nXShq4Ic2nD/wM+hf3Qedgj6AAAAABJRU5ErkJggg==</binary>
 <binary id="_12.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAOkAAAGsAQMAAAACGxLLAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQODyMlQoZDHAAABQhJREFUeJzN2k9r5DYUAPBQKIH2MD3upQw9NL12A3tcfC/Z
S79B/4RCr3vrYRW60G6htId8gPkiBaXslmUvzQcoRYEJTU91QmA9g0Z6HduSLdt6TyN7nMkc
zMz8xmPJkuWnZ+0B9TrZi+KzKcU6mVO8hBXFGUBCcAogCBbFL1Dmxf+jzAAkzhqCrHBW5ico
P/+RYAmvBclzTvItyyuH8gKG8CqwN33stwnJaUKetR8mJAfOOdligQYN9Jacqb7G6Z56DvAX
wet//o3gJWjGcNbspvG5fX2fTEjWMJAzmiXNimZNc6Bo47KgOaU5G8Syy3ry4J29X/YYVvKD
J4eff3KEVuzgyadP948SYu+nydGM4keGWZfXRfvo57ME40QKW7H8UuqwqaCf9dRh0d0bNmfY
IWc0y0GsUL5OwgwoLwLMhjPDeBXgYssHscBY00wPuYEBOx/uCc7ca6DL52WxMoR5OS5hzEoi
OO9o0s/2FouwCnP/u7+E3+mIa56SgcmNyFljvKR5wUleMZJ1GVIxlBvDJsL+P1c0L2ExJfgt
kDHTn2Aak3uZM8PCy4ybfuZlXQX/XlbV1MHLspp4pD7O6GlLSk96BD1l4vRwX3PmY0ayBpIV
zbJmGc8ZzSmQ9Q6woJlvzMrDbAhrqFlHs9qcoctyEGcRzDqcDmIxiLnLnGboMBuRS7BBUado
TRZtVpuwDYpiWW6Bm4Oiw9mYXI7RF1P3U5v1dE7xyv57h0W+ubW9zM/rb2cECwtZm7nZIKmB
ghmaWMiZSENZRu7ADNycR6doljXOsi/XMw5WvevN7YoFWG2H/VGPtL/R9ccerHCuG1S1uDzJ
zO6HckYwx9JQJYtieoDyFTazyEz5kXlJecgVW4K3aKZE3++TbEcHhHU/FlHcrtiozKNY3yNm
UQw75LiSt74em08mHzz8CWOANwefHf9B8XvHryn+7vglxd8ev8H5hVs01WYGScahzVWmiBUz
L5yLfB2xN3i4yhQNY4hhe1tG4pZYZn3YBkV+roIiP1dBkZ9vq8Sql7Fnc4YFcqsxzJGgSFZH
9EY95ZdoUFSzwkuuwqxxlhhnm7KBAMNW+Gz/xYNXOF+efnz4JV60y9N3D7/CK3Z5+vjwCyfe
6PCjw69xfuUUzdckszznX3LdoPWgOavr7estkyZ7+5r5kiM91bBAgiLDWFBkuAqKtJeroMjP
VVCEsL1+EUZuNZHsr9jd8KgVC7AaxHB/eVjFWiy3ynB/We6AbdQT4MzPi8StV5dZH94wZlox
b9EqhhHZntTUz9CLW73EvnbC4g65ETEMZtgh8xbzKGa9+J9verEA32sXrNucxnDnecmonMUw
3Ck3wtPuw7dRuTmwdR54RjFEsn9gi2RzDNFmc9kY5ltm7jIbxNBhMSanDmuaVTS76WUZzXJz
hmhWg1g7nNIsulx2gY2Ye5hvzJ6SlwfszekgzipWKONryGTFEmcG7vjqsKK5aDJ8DVmAiyZb
AMrcMveyABOnBph5OT/pTs6kzXl189QfwtJN/XVZ0cvydWBZPqOX5fMi9acEwn8Xqb8VR/jf
IpnjtkqDr4vUnzuxafKz9UZdTxG+eLze6At07w8LBoT1+3Ax0S8xhudwNdO/ojyHNGmc1SZL
+C/x5vYsm1VgGAeW5S9pvqFXv92mjTt1kxVcnZN8Flq1r3DWNKOJ4poHLMsXVD8nnoeWr8A6
TW1Tf36Gk/3mx/8BvhkzbhUUy14AAAAASUVORK5CYII=</binary>
 <binary id="_13.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAALUAAACfAQMAAACFqgq6AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQOEgUxj3wkZgAAAbJJREFUeJxj+I8V/GAgVfwBAwZgBom/x1T8e1ScBPF6MHkf
XfwfhHqPLv4HQn1HEv/DUNHY4/lBSeAfk4Exkvg/T6NgNc0vnYL/VaZsRhE3CFaz/HPS87+6
zGcUcePLapIgcbU5aOLBap5A8fkqKOJ/HID2+vxIMpinxJGO7M6f//eC3X8fzf0/of7dj+bf
DwMZ/sNMHFc+hav6g6wFSfx3PXbx7/uxi7+/j138/nvs4vu/YxdvbyfN3lHxUXGqiZ/AIf4C
h/gNFPHG/ka1xE4G9yeTUcVvl9+eue32tvefTmOI7zK8vO3+t9sY4ju3nd4ej0V85rZb2+Pf
bt+BIt7Z37mMsUN5/5t+CXR37gfj/Rj+BRH1WMTlwQWC/GCLl1HxUXH6in/ArDcZQeLItRYU
/B0VJ0X8Ppj8jiG+H0z+xhC3hxkCEz/4mMFB8ABfDUeLPWMPD0L8ycllXi4v59UqudRPVtVB
EedLeNlWbxRUP/m4DYq4X/rLSWDx5WjiaStB4v6T1ZHEHz5mcDGcwW4n0cMv2CSJEH/+vxrq
/vco7n8O9+99FP8eHtjwH17iOPIpAJA4WtPkatJNAAAAAElFTkSuQmCC</binary>
 <binary id="_14.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAWEAAACxAQMAAAAveJ4PAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQOEgkaj3WSKgAAAyxJREFUeJzt2E9o01AcB/DqJu4g0+0UYUN0VRE8zA4Psn8e
dqnUXXbytrVjRbAi6FCZmuIOThCRZofpNnpQehEVJmxI0Uw6pjIkhx0GDmkdYvEwszFYM9O8
Z/50aV7+vqC4DfKDvPKaT9P3vi9t2vigi4r7/pfO+YxVYalZk+Pxnvb0v9FAeaDxtKA8ZPH0
RrlvrznfagVB5ToOFyu7o466mOhNhbp+1jaA4Akc3Z0KXd1IUKDzTB5DR1OhJkmfx9J9qRAl
6rYghubi4iwfr8z0tHQcYBw1XIMDct40Vt5rUFlLEmstv0GkdtQZ6+kdr91dAaHyAbB8M4N+
hfQYB30d6U3Za8Aj3QF7LQjIawV0r17zAHktQPfq9coVUtPjbpDIXodZOozb0572tKe3Qhft
9Ae9BnY6rdeCneYVzRFcbR/xqPJOsNWoc5FccCR8tmbDX9LC1O03o7H0ZXjyrVGvf13/EZtc
Thcnyjr9tL45BmPm+teDa8tTwmShrEcvpfstdWxieUGYZLUjed4PFgesRvJigY8tlmY5wj3p
Ju42g4+rRr0UWboYD1exfMOgmiAvb1JrkiArb1Kr0QU7ndVqcQjiVXrVXItLDtvldruesZ72
tKc97WknPW3xt48z+T8Y92WhoXi1QQt4Wi1a3AgaV5PiNp7F1EDWrKMenPXFG+J1XE0VOZd3
1J+o0PD9+ZbfHUMQT9e9n98Hep/BPJYeY+b9ppqWW1anP3dJOmnQpNwWNDoz6xuKNFbfOkUc
yjCoBuTmMFTNgELpMFnpdoaiNUHtIg5qtTpEWmoUrQkqce6CRt9DZ6/qzaCohzedzipNUFQn
li4FlTDqAgFLt2wUrQmqprJJr9lxWLqlo2htUEjecjHjyiqoWhMUspbTe4eImeQc2N3YVNa6
oMr6O3U0EE7OQf/w67LWl0bvCUSSeXi8bg1LtwZ6RH1sDE+fDvQm8+1+LD0jzZLJtB2pimJo
mOSlH940kreNhlLUJLKW1no/8vzWfw9uS+3uCmg8hHV52k7TZuthqUko2MG/0WCpr9qFXv/y
0oVeybxzc+ysK73oQsNwtN6FxkrwD2bXBDd9SkVsAAAAAElFTkSuQmCC</binary>
 <binary id="_15.png" content-type="image/png">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</binary>
 <binary id="_16.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAUkAAADmAQMAAABieeVkAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQPAzQ0nBN5eQAABL5JREFUeJzt2U1rG0cYB3DVNa4KLlKSi1yKG8qmITmJBEpS
VLuhorZA+NBjD63aCEpuTdpDdckYG5pSAqVacOsGqotpPsYk1BB0yVeYJjEOoQU56UEW0q6q
aHdm53nmbQOGqKAFr3af+Y1n5s9q15Izw7TbeuYoKE1NB8up6SFJTfu4YKZv1h4dz/x5WNjN
Fsp2GlbOtH/8+XFwrt4uPXLRC5d++vWroFS7O/+vi17M3dg+Hbxfb3tPnfQNf0RHE/CeOJb1
1teXT2Q+OizMZrOrDhptfSYOj+YamNIXot3RT5iOdp7vSCrKnu9oKkqFd1IiZuGi0Yq6aWgw
3ot3ro32pQ4O2pWm4aDxgkgKyqIXmoJS0MNKCZiHjfL18GAtlKfEg7VQTngXC+UD84lYqLhO
iJMyfkCdlKI+FkrQTMw0ef91XVRcfDy1NA+jwEXFG4VPxUw7ySFxUJYcUgeluJeZEjwX83NL
Ou7aaSAd9+1UfsYHdtqVjkM77cgnxEqZfEKtlCr9jJQoszHREJx1bTQAZ30bhX86BTbaBWeh
jWq2KZ1YGqolEz1ITx+kpx21hGmYKV1dL94bXNm8ufpqblwa1F7Lr87MFTL4t3rbp3Yafs+7
/e7Zlda40rtyYuvsJ35JmYC3fXp/YbPnPZhb+iKmPX9r6Zo/r6WVVs/bW1qsC3p/seF7Gnpq
v3JrRN9b47Th31/T0PBk6Zs7+XuDq3dvVl+Jl3Vw45/qB99nlWUN1JSGLTbst9RctfTz4d8a
qnzMGm255eHj3ORer1N69JSO911c1lEy3qf5zB3fWAJc19AA9LBSPjJxU74e6qb8HsTclBN8
29JQPjAOVkNJ/IqDVakICQerUiFwsCpNxiWwQaXJaqiLJhkxF00AClalybAoWJUScYSCVagU
EQpWoVI7Clah8qgEtChUXgu1UzkhZqdyMwxWofKgMFiFEukYBqs84uQTGCymoBUGiykcU56N
QuFKqI3CfJiNgkbYEVMwJJwOpgScgUUiiq47EB2i6GoGPRHFNx95PojiWxo1U3yjZGbKhnCT
uyJKh+ZtIp+xU/qS6MPLxwrHdjNF0XSnvDhT+CFfWFHo00rz0/LeTkPQvWZ141zFL/kqbW9c
/+6v/YWEblRfL17anN9U6EG7ef3bvf1KQn+vPjnf9r2WQp9Vmp/VAf2t2j5f8b1bumWViuUP
84Lufrw4N1pWVl2WuoUEnB4RRf/fmaBrYEr/TzR+ZNEUNH5ksRQ0fmRpvm5QaAf0sFIG5mGl
NHpRPhBpKIleNN/NYCoIcVIxMHVSsRzmpCIkY7CCCmEMVlAxrjFYQSmvGIMVlPCKMVhOJUC0
MKHSsFQLEyothjmoFJEpWE6ldlOwnEqjmoLllCYlU7CckqRkCjamoJnooKBgUKqDgoKlMCsF
ARmCjSloNQQbUzCmIdiYUrlmCDamRK4Zgo0oaiQayCkakmogp2ghzEJRPPpgI4ra9MFGFI2o
DzaiFBb1wUaUwKI+2DFVmogKJ+rBOaUvjQ5q5ZNFWHw4uzKzrKG9M8ffacDis/ovOy0NDS82
mwuI1lq339bQYEQrsHhYb/2h+609lYb1Le0EBvndWh4WB7NrX+Y0VCmZtvX/AKs4ONMoIGA6
AAAAAElFTkSuQmCC</binary>
 <binary id="_17.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAW8AAABxAQMAAAAgWbAIAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQPBREwdwARNQAAA6dJREFUeJzt18trE0EcB/DFU3uy8ajFegjttQEPBUFFC6Vg
zR/Qk9Kbtj7wVnR8IQiFQOvB0mAutT1I6c2ihQ7U0l7UHDyVonOokFOZBMVN2M6Mu/PY2cdk
d2sVPHTS7Cazn5n89jubNLHYQRq1/j63Sy5ErPvO7oMsHFdd3sNm89trijdzj0rteLXKd7P5
1jfFSf51n9Ee6y9UqrRrasjlPz77fKC2ZeTzL+YrVZbrLbLZQkPzs7VFI1/sbrp8ePM4K+db
mudr5mIWyj89vlBklTHNm12Xn5iLKX+vfGTDvVdYeWzH5w4yYvdUO24Xn9L+h4Oss7H7KjX3
STd36u69O1vLtKrE3Xh3lmlVdfsXl5iZo1Rt+xxRhs3GcZm7845in0PKO7NyQL1+YwV8BOdI
cereSHZO+ABjw2KJMK/YUgW6GGTmtsehkSNxvWB+gpaagrYL3sSR12UO3psERDj0uDl46HPq
XwTA4+bgobgHOeV/5uCBz4niRI3Ixh1hgUHzORDnjuK26IYZORbdyMCJPI75WgqO9FJk4VBw
U/COLJaPkBwIbgrewNXHjil4W47B/EqxVH3+J1U6dxQFcY7lfJhfWJaagcpTzsAx08th5DTE
keKG4JHmQHKouCF48YIgyIHihuChz6n8jKRMbQzBxzlhoTHhBuQgzN8UliqBBg4mc1tzGNXy
9ZDLHcmx7kcZONL9seDlyWP3ZksONY8Fb+BA81jwssPmAzingSJjwcc5CfBY8LYahfkb2lIT
SAhSuR3k0MyJ5jjIUYRjzaHgKMijwcvnVHMY5NHgkeZAcBDk0eBjnLIgjwYP5R6I70CWAuFR
7bkTdiDM1VOIieB2mMMUjsMchbRfG8KO4Ch8AKfw6IFQ84PC2A5xc/tTLq/D/+t7ZEM9JNDb
NrZOX/B7DLylHu5z1poeqaieVhKXZLro84TZm5cGSpL7xdSvd3blZji7e/HM1Mbjgs/3B8t8
1tZMT4/ieyujS1c/8dd5t3RvbvzNpM9JXzdnrXVdzN7bD5WJr3z2c8s3X17DpzTvlbP/CvD3
O8uCk9XlpdE9fEPzvOSbIzDAVyZkMS4f93hdnup6Bz/VekXnXr///EThCy/m5ND2lY3NXOKq
Ei9JxB868p9AIncCHKbyZs3diJ+lDQpSebwd8SN+xDNw0ubHMFfnY9xp82OYTwXBIbldAW25
swhj/FYCn4vzUgJfPdjsh+bOs7aakS0Q40lBqq81GVdVTUV/Ax6Ql5VQEV6mAAAAAElFTkSu
QmCC</binary>
 <binary id="Bezymjannyjj.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAASsAAADFAQMAAAA2U0axAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQPCw4Z8naqzQAAA8tJREFUeJzt2D9v1DAUAPBKSFRMNzKh+wh8ApSPgpjYOLbC
AIapGzewcyMTMCDBgCDdmKoOHVFxTzdUCHqmqoTv8NkPO84lPvv58ioQf0QjJVKSX/zfz0k2
gLIdbtiDOGfn7PexbRob0hijsR6NbY5J7IiWmqSxqzTW/4v79L9nd+EzgRkJuxQm4BmB6X14
TmG7cIvCDsyUxi6SGFBSM5PimMKg1AQGjCkKC7czTGcie09jT3Fm+hHDI5LprbKbeGqLiF2g
sUxN47JlmI5YphcUJzFJY0KQGKexksYYiRmQFKZxNj6ybdA/KZd3FM6+fQCYiilf3pGgMDZV
rqlMw0SOzfpc6KacHGdj6Vp03rASNMaEsKlx0zCWYbZUvGyYAZzx13YfNExXMmXDbVuNS+Nl
TVWGVRlrWDK5hkllK1g/UdUCZ8HGaaxMGPryw2raMmzWG0gYNk91yvZqtmjL4rt9lb2vI9Ks
aFk1JDmaacgEjfGUDRBWNkk2bIhUgaVseRoMagMk5kekRFkwLxWNyTUs6DMRlSLD+BrGW1bS
GKuO+LJbNlfrydLF3P2dHGPNVVeoV+EMxJmEaKIGLJi9wu9djK9hQQAqIZr2OGMQTfuAtW1u
gMSqdIcQtGTA2mHTPJCyywGTWWaDaTuOgqAfsGHMOMq2fUs219q8VlgVuAp/TYkZb9tBhKwK
DtynIffk4DAtpGPCRiS9ZC8gx9zar+usxAvY2mmYDJlb+78XNRtYxlDmP2P9qJkKI8cjlG2G
bFPL0wnKfEn9OBJCbbURTOWY/PR14EdHhtVBSLuzky6mlOsNU/i7OmVB2LJrAI3Ns2xlRapz
NR2szhVhfIXNaAz61ZElrFxlExrzHZYytspgFD6bZxOUmUj5XLtZNUx4zHTCTmjMdVjCVMJc
h1HYvO3ohsmU2VxDNswwm6uAG/AGgrca7HVqBtIcwLWQ9RAGfWk0vA2YQdlEagXvlsxGJLOJ
scXtkIkcgwcRw8sGh/ciNsow2bA1/9++Gllcgc5v53n9Pd75ie2/x8/2d6U3AtvaB13sNXc/
XZ50sa0S4B587GY7tpM56ypbCRTGaKkxUmrGhgYCW9wvAO7sPcqpsBeYSAMEwkqeznyErdv+
CVb6gKnw01/NdjZI259skL5fV9xicAo+8hT2NvgVuGEjy+z1LzWrn3LsccSUZQuoFjXXGLre
Y+Zyca8M+/5X04xlGPNr/L4PxfPCs7hsLieX6Uu777UsTk3X7KG/5JhCmKvpsa+puZ5hPf99
WrebWyRdg6i4bMReOGfn7KfYD3GUSVj8pKwAAAAAAElFTkSuQmCC</binary>
 <binary id="_19.png" content-type="image/png">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
AElFTkSuQmCC</binary>
 <binary id="_20.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAQkAAACJAQMAAAAFYV9LAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQPCzQR2QT8hgAAAopJREFUeJzd1buR2zAQBmBmDl3CleASWIJLcQlgJyoFoceR
Aoc3HoSMbmBbAa2hAJgggN0fLzG5G+uMmeOR4Efur+VrcEdjGt6G3MRrkN+nQ/Lz6ZDYcqIm
1/E1SDX+f2K2v+t9cnHVJSjJ2S/Gu0SS6xEr/HK5R66w7JAFztUhZ0jUIWMmWyR15NInKafp
kzmdTXSJSiunLhnTiu6RG61demRt4ILMvCo65NRczQgcOrcJBljbBH/GrU2wGVAUyQnJqUXy
G2lukezyQl4g2U0CeYHkjwZfUiAyJ6omeVrIy6R42HmbyVIQW5MiLedlMpbkXJLqvU6ViZRp
eYbIXJHUBSKqIqmXj/xqfifEPDaxH3Iyffx3Wd6G3Bnvk6zZNyIMnZOlehv6p3xFohvPvYz9
jEQVHwk/RHwtRSLbr0MBRGQfqX0YF/MFYl19IVcX8wViXP0+XFzMF8jqXNUYHVkki3PNz8TK
RKc5GDLlC0SR4yFSvkAkVaNhyQUiKDMNQ9V2YmEyjZUy78TAqdMIZXUiKwekoQnuJAaVSBSV
24nGWYfeJKLw3A6r2kQkJnRZdhFJzImNSR2QgdhiGrkKJO3CxqSiOhAqIJhopp5QTMlEcUFP
dDkP2gRCe6AxqaYNhM7PjbFgPaGU3Bj+/dIT29jBWHnCOxhzSe0J9F3wDsYbgatHwRWU3Aj8
VFXZLcZG+AjWVHHLtxE+gmriBRUb4SMoOd4WchrwCFPQPd804BGJ4y2qpyF7TkUR2/NpyJ72
GF3B1Np+wUvcaBNxTNwjkLEWfwoia7K17hdui/pkl2l4QfJ5X1o8mZmGH0g+hVmXk2fc/tIk
32HThktsikLfkKjwT8Dc83Ffvk5/Acofqjg9fe7RAAAAAElFTkSuQmCC</binary>
 <binary id="_21.png" content-type="image/png">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
O96ScAAAAABJRU5ErkJggg==</binary>
 <binary id="_22.png" content-type="image/png">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
anlR9XIOZwAAAABJRU5ErkJggg==</binary>
 <binary id="_23.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAWkAAADsAQMAAACMv8XSAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQQCAcMRFUM/wAAAgVJREFUeJzt2c9LG1EQB/AcejCXomzBeBClhiw9Vk+CuBdR
AvkfcjCQq7e2dOtKKf4iILgnD+LFP0KwrWIiIbT4JxjT0i5emqQrZJ/79o1GNOwuu5vJQYg4
39vwPuwb3m1mYwBQB2xWYsSJEyfev/xgoVl4h+dqnZ1/RHOxnGXnn1CcD5TiBaHw7yqKO69z
p0lAc5jMlUswJpaxfKm4L/bwXK0knZ9YLhJW/PP7L3xmGvf1djQBYOP5kQPQwvPuIY7hlvJ0
Odd64qKrJk6cOHHixIkTJ06c+PPiS1u/h91G1BKQqIZxwarmoZs75lfYrYdxzo/Mb27OmAq7
rSBuDa1LI1xjnQG9MTGYmrI4/DCD+PVcZTMtXPxqQ3+l8zAucpWtDaHcnt+HV/QxiatghPDa
Wtrx8OJL/Tqcs+20vePmZlJvzRjBnL9tSC+acevDA7cWL1LxX4l80Qh9d3C8y4W77UHou4Nm
e5cLoi2qoTwiz5tzH+HR3NK83F0H8Ibi5e46iMd86cJ9zbhrTO8QyaNCnDhx4sSJ+3hfLdR7
5D3u3xEh/hjcOVEKWTy3De0s+iYPN//DGfLH3cX8eCbfhD8mjl9KqTcyQ3Omp2ZlC0w0Xx2V
r3rgf9PyvzyWN8rHGakk1wwcb8fuTDAo7nQmGBTvHuLEb/mxf6qKTl/1Tpw4ceKPzG8AHvUQ
oLCZYYQAAAAASUVORK5CYII=</binary>
 <binary id="_24.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAa0AAABzAQMAAAAR28+fAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQQCyw1b2bHxwAAAmRJREFUeJxj+E8O+MEw4NoeePawPFNStidR27dnZZej1dXu
k6rtXdn3ZHV1eTK0RYeHkWzbs7LPZGh7lNlT8iAomJ9Ebf/f//+OWwvVtR3//5gcbQTBSNT2
p35U26i2UW2j2ka1jWob1TaqbVQb0do+2JOl7ceQ0FZPlrYhEW9/8OrCpo0BAdgHrTakbtvx
kaWtnp7a/hHvyMP//7FMVBQqtGhstLT7MbNDQngyMdoO2P/Py87duuvv2Vt36/5uu3N37XX8
2g5AEgvz/7xX1W2Wf9ffkvv3x+DW34XvibKN/3/ey9qtu/6tv/Xv39/tr/6uJ07bf7Ajd9et
vXW39u+2VwQdCdF2/v8/tYnGQoL2xZ2Wtj9mfreYTFSQ/IeFez2YBI0bILS9JagNGmfvUbR9
xqcNXLT8hLDn/6cgKT9m8EnuPHKG8whC28MeTiEDloZ6fNpub7sde/3ttmtQv/2T5///7d7t
rbtzV+G17f622XfPv2278BKqjZH//8djt5f+znxnj19b9N3rb/ddf/oPWu4Abbt1eOrv1Hf3
CTny9ttNcEeCtf3eujoXv7bnAj6POw+c6IQGyT9+YJC0FAolsRzB60iIYrjAv0FVBNFc2/3/
/9gMlHgeuXNM/mCsbih5RMjAgwhtB///z70dtbps99bc37mzbpq93V4dQUzulgdqi99TsLvn
4+/EXZIGD9uldxBXBAG17Qbblr/r1/a327Pxa0PYdj0apG0t0JG3tgG1EePIg8CyxEBdRsmd
Y8JH4+VGM48ICRATJPeB+Pt+qBCEJjneyNQmT562/yNRGy0bTwDkz/IbNhLi2wAAAABJRU5E
rkJggg==</binary>
 <binary id="_25.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAToAAABoAQMAAABbva5XAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQQDTcCemDV4AAAAwBJREFUeJzt17+L01AcAPCIh1oQuW4nCIoedT245YaDFAQP
jnKTy4GDYGfByUWM2MF2EttJB7MUHP0TcuJJKQpZBMc4WDIGiRhzL83zJe/n9+VXlwNBH0f7
+n2f9+ubl5Az8GrlyDh9+GO2fuPptdtmI1yM74y2Oz27Efrjx/PtcxevrgQHnV7zGhfju/NJ
p+c1wnC2c39rlc1UlP/w1KCzxAGOm2FqIRyRz0YY4wxipxH6BCKM3UbokfEIDBuhSeASZ3/1
MMFkz0tc2E0BogympGI3QD9bZUortdDmEDVAK0+hlS+2DmbNFJLt18FQDEpWUAddCf1aSETK
RovrYJZmDmHKNZiNkl28gI1eCSMVujUwa0OsAzxAGjRVuKyGCZ8+v35gNxAiAMEBgjDPcSBm
9SuhDSGqhPmiPEyTDg8QgLRBQvUAAUgT54ix1ZQD6OowqoCOXCitxuWQJViBSspVSPvTfXjq
HDqMitAthTRKcx3QUFgKzSJMyiALImUZPE0QojJol0BfhQgGAWSdIwBRCbRUyG+DpAh5KABQ
HCAJQwBTHnYLkGWOXRMBowK0ARQJjHUoDooDIY8LKI6eA75ERUBxmC0Nuhp0Nejx36EGTb4m
rMEEQpEOXuHZ4lNwKPayLEAbQL8a+gDaPMyPi7ylEYBWNUxUKO+NSOuAWUIYDOugq0C5dF5T
HuCRAu06GEuoPGM89p1KmLdSqDy1SmB+QCiMYDAvcpJ8NxS69TAU0JRB0e7IWMKhup4ymAVz
qOxF9vEUaDPoN0GfQVuGZJ4DDMrf9TL8T8Djtd2zQ/ojvb7V/tbSye/h8YW9DcNYHBy25iy2
+Wrz5yfa+nLUfkGDybg/HO93CdxpvWfw/GUOk+nHyU0G1+9Nn13qGuHB4ZyP2CEj+gzOBjMG
J9+nb57kcKRM/YXCtP9h8pbD/vT1g65xsrZ7S2zmTPvzIwbnfGqymY29K4bxK4IviuwcPhy1
BzA9X7U3ynd0xGIeiXquRuz886QI9QgtK/zPVVGO/gAfwI6mO57XNwAAAABJRU5ErkJg
gg==</binary>
 <binary id="_26.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAcQAAABdAQMAAAABj4RjAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQQDgAUHPV+3AAAA65JREFUeJzt2Mtr1EAYAPApCtuDsOpZjAcVPEhbLNSCOAel
IqKFHkXagsWyt/4FjuJBD8XH1oOP6p7Uq/9B6oNKQUlp7067K4inbMxiEjeb8ZtHxrGb1riK
UNhZWGYm8/u+bB5fwiLWYaujv5S1N51K791/ltWRQv1FR9KbG210JqOOZQhyuiPZmBv91pn8
NFKonupIsiT4Y/cPrr6u7Mq/kgt6dP3PZIyLahBetVQv6UkXxDuyGMyC9OEj22f4yOYlWPVq
MW5zjL2JCUiHtdS4wpqq58AnnatkSJgFabOEyDFhsdqC9X4QvR9GA/AZJDBbjsVC1VP7AaGa
7RI2NuuIr6fpWMVoyTBMsFa75LN1xDe46VjFaOrsgY5hNj5bR00tAy0Dnd3VMczGZ2eEDPT6
jTFcHcNsVMhAS/eXHtVrsuVLIZsbJNXZqY5hNh5rGblxH1YyvIQ3SjtbhhNcRu+xPPDUf2DJ
GBRi/JRumyR+RUhXSkL9VSETZkMMmZ1kyAgkZWvIDZUsUI9WhCza/mqFy1jLyJChRTwhYyIl
mgiZlMj2qC1kMZWhZcgeEjIuEwvHiDcrxnYoejhMxLGKkZbqhq2L7QRuPZDsjszZQ5lFRM4d
dowttYbx6LwZOQuEWVw2HSktGjwVZzbBNrPuiJwFnbNoSEKCu0RK+ftp8MSVZ8UOKo6QREs+
fQynZyV4iNdQEDnplaDPBQ3mHNmzzbPyU/oP8TIKvu8rKtnoT6V/j255DTWGuWTmdS5LB20c
x1tKFoHMusv4tyxhdBPpWS8za0K+u6zFzBpi6+y2jkHapKwJCTPqlur9UoeyZSKrJhZjqKKq
8rb0+uZmFQxqH9TrdJttVFlVs1uZVTMS9RZORHoLOUZlV/UZgvrtEmYDkJGu/77xNEnnsJ4z
G8yCTJClxjHCqlfTz6F3DLP25iR4k2e2vDF5CzMX1Hu24RtGV3bldpLVnQOzCL3eU74s32HX
e5cG8r0bfz09degAqh5cWTonxt7e0tSzfHs6NlnoR18Orr+SpaZRnlnLeCXNyjk2jblccFI5
OZ1XXhnicuVDKktX8snqroHbu9EiHKGbYlyDI5T/X5DtcyV0ZT65Pnuid2GWB6gv7t85OaKf
Yr+VXw6Pl0uHjjD+n03f2cHy/dw5/cWT86XCccgU1awLgzfmcV4ZPR9/VMLDsD5e7Ts/WJmv
5JaHL5ZLQ0LOHT07+Di/rF0bvoVu74a99Rb2vUVnenPvLf/+qMcuyedA/gA3I5WKkmdUygAA
AABJRU5ErkJggg==</binary>
 <binary id="_27.png" content-type="image/png">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
gg==</binary>
 <binary id="_281.png" content-type="image/png">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
QmCC</binary>
 <binary id="_282.png" content-type="image/png">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</binary>
 <binary id="_29.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAATsAAAEBAQMAAAA985BPAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQQEhY7voCsRgAAA/pJREFUeJzt2L1qFUEUB/AQ7cXOShGLtOoLCDYmWPgKFgEf
YwQh2oqCWOVRjrEL+AJWR7CwHKxWSXZG7+zM7JnZPR8WiZG46H7k/jh75s+d2U22om37svXH
MDz4a1DZ/ikYYgQTHGNEEzyJ0ZvgkP4ZoE9FDRBTmwYIaeAG6PJ/DYZcVYWpPzTANGIpyAKH
ulOgr2UViLVRBcJmJwVZoCN7CQZSV4S5O1RhHq8QZIY5QSHIDHMpIcgMc3NCkBnCdCUEmaHL
l45zGdZKoMDaGyqwjpYPcoI1Pz7ICdZCfJATrK3xQU4QyiUf5ARdvXaMmyCpAyIknaEIyVjZ
IBMk6bFBJkjKsEEmSBpjg0wQ5ms2yAQd+YFbdwk2VUCATV8oQPFpQKFp+w8V+P3VKxs8PT5u
fvKVgz+OjmzQXLGHbI/mwVjU+UDPfOEXEJmpvYDATO0FdMzU7mGIzNTu4aZBtMDNkFfXyB4O
kVkje+gjs3L0ECOzRvYQIrNG9tDVnQxDLavAqT3U4TTgtSA7OJC9CD2pK8Kpu7UgOwhpvxZk
B11z4GEpBRoszaEGy3BXgmzh0B1ZWCqtBNnC0ttKkC2EfFwJsoVucbIO50Igw7k1lOE82GWQ
DRxWzlbhXGcZZAPnzpZBNhDq2TLIBrrV0yWkZUCCtDGUIB3qIkgKaXiLICmkVRZBUkj7WgR5
kR6alwpu39u++sgCd9/f339HP+j/6FXgpxt3nx6a4M/7+zb4ubs11+PB78E8sUB1Oz849lOb
gyf91Obg0E9tDvp+anMQ+6nNQeinNgddv0YyMGSswjHfXoVpIGiAKRpvgL5qBWK9vwJhsxsN
0G12QYeBcBGOpAER5mGgCnMwXoW+8QLEpgMBwnQYVeimQ9BgBU6B9ZagwDoIVGCNxSuwfj4o
sN7xRIFQTkYFunISZEg+diIkNwQRkiGgCEkoXoQk5kGE8/1IF2sQ5tNRhG4+DRJs5r0TYLOS
gACbtQmlHle3//CM4Pbtaza4+/pWc/2Vg5/eHp4xZHs8uGMcDLedP8QyMzQIZa5p0JXZq8AQ
y9RW4BjL1FbgZiRogZtlz1ugj2WNVCDGssQoEGJZtBToYlkGZRiqVuBY76/AaRyowykZr0M/
cxni3IAMIe1HHbq0DyosTxynwfLEAQ2WJw5qsDyEvQbLg3vQIJIWRAj5OGrQ5WNQ4PzgdjKc
H9wgw/nBjTKc32W8DOf3n0GGSJuQINSzUYaungUR0vcfJ0H6/gMSpO8/KEH6S4qXIP21Z5Ag
Nm0IEJqrC/zQvNQw3Nxi/qCx9XHvOr12z5mKe98evzHB3WcvX9gq7lwxVRz3dmy3Pv3w0DiY
brukkPtSLDf79/EXIwN26wZQ86AAAAAASUVORK5CYII=</binary>
 <binary id="_31.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAXcAAAHbAQMAAAAK0EgoAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQQEigukphT0AAACdFJREFUeJzt239sE9cdAPBAIgITavpDWglFmJUpVicmQjxt
uIp8lYq2IWVF2h9UlLJSEi1oCEgbEfCgPrL9EaFuWNTq1KiB26RW+adjk1gwqbs5bVJMNMZJ
Q6UrTuokplxRcc7HAb7jzvf2nn/77nL33hBLKff9wzqdP/rme++93J19X9cAotBq/p8+XWOM
BgufMcnIO34+/G1Ko4ALCDSm5ymNBgyQo5ieLfiEpZdqZuraF9Z1HKtxNWiH6D7QyFp69Y1X
O8YHN/5g+CmXW/NTIW2Lne/aLgz+dP0BL+PWAtD77fNfG9yY9iL/Gp4ff3fj34a9TFPA7w75
bOqRDs/Uba8Z6zj2MPtc4FD9IOVlrMdThK8H0SYPAnQGRO3GXyxtahrFA9pufqeBPr4m6/OB
8KTnz3Kw5rvn9GFCf5DMawqhz5L5rEbmFUATefifReSnDlBEnnQ8He94xzv+G+YPm1zvaix8
1Cyj4+/Od0ngLMU3HKViQADgcTuvySq8meeZPooFMgBv23m14Dvz/rilP/K7Z/qRb+AZjmKD
Ep0csPQfN7VtQd7NMzzFumXqn9Y+1rTUX/AJio3JFGvtR5vavPIE8sejFDto68eb2vrlAQ76
/j432+T32NQDj3cgvayT3cQvqHezv/l1N9dvO/7w7oRFd5E/YgGt2I8/vPPhY9Bra2MavK+x
nd98lO9S5319PkCe9HyIouJO2+Sm2OhvlTezNIafrfhTUQyfKCfNJDB8tOx5LF8uQvddgrmn
y0kTxs9jBq9VLP2o8VOMwasr60vb9b0Y9Xxe3sxEHe94xzve8fPoq/fae+oe54+yI6HmVT9+
ff0xt9GrtNGHU+fjPZHNk5GtRq+7Zud8X2riiZ7I0RVPP2tSj9GfiaYmFJg/O/ySmacWto30
Ll8zs4GpqOfTzXPUA/6RCHt2X05t7UntLXgXO3axuW6O4wUBV7hr9+XZ9V3XGkBpfhPlodN5
bQaEu1Mw/+0v6ApfRjqfRfVse6GyHhjBOb1EUY+1jTxSebzVYTK/dHkfni/vwvEaReYr4y68
NLCjjsSrW1p2EHl/czuR97a8bPTSW2NL5vD9LR1Gr/6842Nzb3686qvbY+a+EHrf0jFK5N/o
GCfxcx+vudeF4x3veMd/Y7y2lsxnq5+k2nrF6nmumVe7Vo81flQ3s+EEnlci24Y2p3blb0/w
fPRAcmf+dgnDfwV9T2pX/nYJY3zikW3hHvx6tNZXVl9Y/8wG3OPVxdfPS7qddj5DkXmeMD8v
jAQf7lz82JFHD+L52VTPJ1uH/hwfimL7bPL3fxp9h8LzJ6GPD/0l/iZe/Zk9qZ7JOH49kjAW
XD+9APt49XscT+SlQ7TwkS8t3aDwvKrRIheQVZHA39BkVcH2XR4B+gxBfhk9syLIL5H4WVq8
qckT2P4CLc4G5AFcLy2lxDFfehmN6WGIuQcB+F5AXsP3oOJBA/l6mxZAzDW3V9u1tNqu+lqL
XpQBy1h4EU6WRwusIPCKR3vtRNmPWPq0JoOWRfRx3Pw3AjLo1ugobn7otRuLaLrkh23zT4pa
Dyh5r60f8Gi/dBX9VLO1v6mll3nUupKHL5YeLYZSl2HeW84vDX2y2leFYf1ole+SrzchqIwK
QQkt8CSOF1mFS7My+gcSTetHXbJgxWq+Ibi66K9beIC6XoFvP890enJ+VOHUc40CaFC75/bU
Wp7hTuX8uMJlWfkKcMumXgJ9mreWcvEM2130yrlGCXrTem7QIXUYUAzPxMSi38/KN+fyKvRy
LRWE9RT91S5YD9vkN63nDvKA2sQfL/iLysh2Vk5veu6QeT2dodZh4OP4/r15j55owvHkAW3q
Jfegzw9an+UXBHNeQB7Ob0IznV8V9fLBetBjPTG/fqqf6hnmF3XJwjnmc8sUf73lPwfM+/X6
DkXm5YTOX7364vj5aO/RdfU1OxYbveHzzu1PX/jiJB3f937k9K1Jk/q/XJdeF1q+ZsnVpXmf
Dj+f2gPi++TIaU/cxH/rpLLnfOoXly6/l/e3gs+nVkJ/J3L6k69M/Oyssmdi1vef0Wjep8I/
jO+G9USePn3JxCs5D/MnCv560P/ZE51Hjr6yaNWT+40++/ksqmfbpfgHhfFE56PCg+SM0cPP
O8K6i8vXLO5cUfB3QKmdgjepH0UCZPnieKImmWIwc/pi4K2f8tfZ874+pZ/AjWmBA0l0Gq36
ftXUq2hgxOsc4NBpser7W1OvvYS8mjHzGTNP9QpAlPlarg80VnsqkzQ5XgpcASKslQtpW6o9
Uztu4l29EqwH1ELv13leMKmHATeB+EEuv97XXjP6LAuusOL3kffp60mY1CP1gfSmqXXQD1Le
Kp+lolMm9YPC6uXQaRRvPSTQSxKdRud/vTne8ffYm/1qo97Cm/0qpLjP8f+jV/piTNKV6Uu6
0IWFtvUZlmM4JsNOM+hCEbX1HMslkP8s5xOWXm3bUceyXJTry7Aygy4srKXXnmrZAT08hWdY
hUEXFhvvbW4v+gzyfhvf2PIyeyHnL/A4fmNLB3ueE6E/Px1CFxZrj46XOzwqcoOZwx+G0IWF
sR9/OGUcen0bXVjsxx/etMPLMdx8HF1Y7Oc3Hxn9xn2znu9jT3o+LIWmf8/GY/WvVnis/tW7
uF5g9a9Wepz+1QqP079a6XH6Vyt9/W/JPNb4jBD6inD83XvhkXJTMo6Xv/sukZdWcWT53YS+
qdrrlrTJ8Zbba5AXq9+2HU+7/Aavqks8C+t2njryKD129skmW68EJv4V3jW0Oz4UnQm5v23r
pcDkh+FdZ6ZH36GSofqVtv51bZKF+ffG3wTTIfdDWPXsy9dzJeS2rV9Q1Z95ajZgHy+MbMWv
wXDWc+VvgXG8ROgrw/GOf6C8rn3B1uvaF2y9rn3B3le3L9j76vYFLF/RvmDvq9sX7Menun3B
fvyr2xfmfT043vEPss89irB6PqLzoswBrtwjiOEzhJ6vJfOAMD8gyz9MmN9L5qeayTwKUk8y
v7qYd19oX4gVfvhjP/759gUOaPj+OonPty9Mg7OYvti+8Ad8r5xrvAJO4Pv9KD++z7cv4NaT
b1+4xl7A9MX2BczxLLUvYM6v7hPqvK/PLwk9R5N50vtJ8MfYyNm2nX91v+XB8ur3IqmIZ+jg
1l+dwssfgb77jNL+EGb9OQ/zB/B85mCunv1b94hYXhJiYzF4vN8Z6MarHwVd2sT1xcDyFT9I
m/f1OS0A4BLwvZgGgCq3YNj764RelVw+L4HPAtA6TOAVydVKUk8Y5ifxzWT1TK0CwOfH9yhI
xhMFyfzq4r7yaYrMm4Tj78L3usj8vzeR+YtBwy5rT5iftJ7eesMuS/934657Pl//Bb4eMwdU
BOnTAAAAAElFTkSuQmCC</binary>
 <binary id="_30.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAXkAAAEZAQAAAABajGjKAAAAAmJLR0QAAd2KE6QAAAAJcEhZ
cwAACxIAAAsSAdLdfvwAAAAJdnBBZwAAAXkAAAEZAAVKKZsAAAQESURBVGje7ZoxbxMxFMdb
IdGNrgxIN/AB+AIoEeID8AEYKoSYO7aItGZj7IwEug/BwIAUV2Lo2BkBsdpKvaFSXHQil+Su
efjufBc7Zyd+FVETya+6Ko7fz/b98+xr38sG4Oz9hgewwPAs2D9std2BUUw70MYAI4IEhoAE
MjSAXdKYdDgKSNqdUxRwHuw/CDAAAAFAAMMcmCAAKGYAFLDIPJAbwwLh6gG7ywayeDEw2VDs
Xqa2tozAH/twQyPA5yyAmAA2B6D/BaBzALZ6ADcBZOkAzjzggXUCtINv1u7BUG0GBcDpwYAd
pry4DlLRTIqre5Owb5DKV91UXKwAhGNf8yr6xCUG+AmpfJUPxXYKQPj0NK+ir5zqCtJqUuHG
wwIQb3Q1r6KvnCqGtJ70UFwFkAJMiEWTVPworRJIxGOEmv3FYCOleVMCHGDMLDO8g7HKS5UA
BtwCCFnV1ZYq0bOgn0zfvFYfO0LWYrXfL4pmqRKJaU+5NfHH7tSuihsFiM6KZrkkGJEuWIBY
qhT9UIB0CBkxA7VK0UiVNYMxtcxQqRSlqqwZGTALUKkUJaqsY9JXZB39MqgU7aqyJu2eIuvo
k0Gly1eqrOdBV5H1+qGiQKXS8TNVJXvwzcTS4uCbiSWH4NNjySH4KpWk7VRbtD/dU/VJMHeL
9jSvclPO2aKirXklyqED2qRSJU47utf00BGyqpOyW518gDMPeOCOgYmjN11hYGHq4LYAqQG6
HCC/VQmcOgE3U2DRv6ylXUyBrHGEbelHWGHbMCeWhvDB+L49+FoECfwGJHC1dCBZPQA8sJZA
Zkl/W4HJQYgECBrALokEy17SHhZ4Q3FAdh950zbzgAc84AEPeMADHvCAB+4EmJurnLGgzIay
bqaVUAzVmqq7KuuMtRKKoVoju1lV1hmohRZTtUZ2szpnrCeMm9Ua2c3qnLGeMNa9ygHCvHun
yqx3qZumYZ1ZZ24AqzPr3Mlfyip+DxInQMqal3XSRqcs5GgmZc3LOqTRKesymslkf17WaaoU
jZqATPbnZZ2mSpEpRxXWZZ2mSpHhOxNV8GXEoJJpSVXwjYlBpeitVaW8rNPsvHxpVSkv6zRl
PX5tV0mgFJwsRAZfpZJz8Fm36Oy+WbhFKXaLMsNUVNmiotNc02kMEtZlHesBNjPIrY5Kt4+s
Ng944C4B4u5NF36lavUBsvCrbUaAO/vLKk3kDMgqTeoMxCWQtV2BoxKA4+aJtQnXhnOMgDWW
Ju0jyyy24GMECfQBCfzFAjEWSFcPAA+sI/DoMd8+OUEArT0efokQQPsJD2MUEPAwQgEhDy9Q
wBF2SS/4ZxTQivjHrxjg6XO+eYJaUv4MwABBDmA+abA/ZdYmvNcM+Ac8reyhWLEq6gAAACV0
RVh0Y3JlYXRlLWRhdGUAMjAxMi0wNC0xNlQxODo1MDozNyswMDowMPc+hfsAAAARdEVYdGpw
ZWc6Y29sb3JzcGFjZQAxtXwEJQAAABh0RVh0anBlZzpzYW1wbGluZy1mYWN0b3IAMXgxFq6D
2wAAACV0RVh0bW9kaWZ5LWRhdGUAMjAxMi0wNC0xNlQxODo1MDozNyswMDowMKiP888AAAAA
SUVORK5CYII=</binary>
 <binary id="_32.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAfAAAAEZAQAAAABAnEoBAAAAAmJLR0QAAd2KE6QAAAAJcEhZ
cwAACxIAAAsSAdLdfvwAAAAJdnBBZwAAAfAAAAEZADz1bIsAAAXCSURBVHja7Zq7b+REHMc3
RCLNSUlEkwLh4oCTqO7RoARhUR0UUWqqSNfcnwCnZHd4nCANipRrKBBbXX3lIa2yDgLpFCnK
lhS54KDABRRlnZO1sY09M4wf81h7Yjs7yS2b+Cftyh7PZ2b8nfFv7JlfDStZrcIrnFugK+EI
VPig+Gdq+H0lPJhQwstahV8y3BhlfHGYOLKUcM9Rwp+5pXG3ljUNSxLHpfizchURFwRkuF4W
x00JjkrT2JLgsDzunD/ul8f988dLjq9zwOH540pW4RU+gviexCFv1KQ2JsEts+5bRt2Jfm3o
mG0fh0lt3zEbvhX9khzrEvwgYeJfmHkJ/06OtEypzq4EP3RoBbSSFt4lxJN0qXX/SIIf+bQC
WskO3iGZn6ZLbcOeBO9m0g7xb6SUVrpUs+HJpAOpJGjjDvHpWZ1wXYYbqSRElCcTUjuLS5U3
02lEefJvgEzmPuV/uusuhconp8fsjaAV5dNw5kKf8stWAEPlk1MvoBeI8u5d9ISeei5th6g8
aiwGSFCe40T5wIJPGX5CcaL8xsTU9Zmp62+v1JAeIMCV5zhRHi36LYazrzIyTfz56NG787Of
PN78GCe4kcIhUR7pvOM89gJRD/GvJ76b/eiXn7ewFuFUeYZHHafzjvPY3LQe1X5jfnbhy80t
1Ay6gCvvPRc7TsMau+MdoeOixr83/3hzC24F20BQ/geh41BTUP57WhDJ+iuRrvY6ke6bzx+6
1wTlj2doLtJxsMOVP54SO65JpvnodgHCUDbmw45zv+XKc/Ow8HJmQPK6IBnz+Y/MZF9K6KxS
mc74yGTS4keGKc8t31kZcmfVKOmsTLmzMvKdFeTeMAZSzsrMd1aCI48Bojw5WE+XSq7KcMGR
JwAOgbafmUBkyitOUkpW4RVe4SOPW/LM/hXGnVeDOxeCWyVxXw0/ZTGmWRJHfGKaFFbEQElc
MPsg72ohDk0lHBlqOBgmjkcaxxVe4WfE9x/W/3DdgfGDbWi7y4Pjf0H7RAHfhzZSwG2CB4Pj
L6ENFfB/oN1SwJ9D+32Fe1+p791UwMPpbvDG74f44KMOF+x8/K+fuAHxQFfCRzt0Ybh4FThR
4SOH61cXR6YSDi0l3LaV8Mmg3M0TfE+yqIllq51jUny1XDtPC5wAZXFJFM2ZAidMCX6GyAdL
gp8hdEExcOIC8FcXOHEBuJJV+FXFRVcHjiUOjqeNS3BL2LgCJ8ImWj3ZRHPYttiSDBc2rkBP
CAXwk3gDXnpLhgsbV8AWAhGcJNrBZqXvSHAx8gGIe2PJRhrusdIPJbiQBoFjpq4jD5+wE1uC
CxuMCDhGOkMPO4Aey553IfLBBDwrNaI8LRJx3H/ZeCuRjhMWOMmUT5RnN8Q7znkBdIBZ5IO7
HJ44gO11BovJwXp0x0jTcLi3Te3gAOgGZtu4QfT54APbSq57zeSgHkccfNjB4d42HpuZ/mL6
zXsL+1hvcuVjXFDeSw4QjJXXQ5xkXZt/Z3Pt01sLxxQ/4rigPPtq9mLlo8x2iN/Y/OrBrU4A
ErzLcUH5QOcdFxapr8bKh/jag5udLphrcuVjXFRe4x1n0sYv0cbfXnih3Wly5YNuSnmfSrcb
j7W5Tqz89MwbK9Mf3Lv/94/juqD89mnKr8fK3zZj5ZPIAYe8KgCuvHtN71f+X3rv9Uh5NK7F
ytPGYSN6Kyka88gTxrzskRGjfSRjvicd8xwXxrwpGfNH0jEv4Ly9Fsju7+8KM3iusyJ+BnDH
ZLDQrLLOqsGcFRQCFoqclRD5AJhTZgFS5JFh3k/qrITIB+D0O3lyhXQcD9eS4IqzjJJVeIVX
eIWPIp7/QVv4GThcPH8poTD2YLh4/jKKdcF4/hqQWYiv5tBIL8T7Z2iw0T9XF+L91tRxvuXj
XayE94aKFy5IXWK80Cr8MuLxR//gteuTSni0ZqBQuyJuquGGEj4HlPA7kyo4ek0JL7YKv5r4
fy9sVUqqXp+pAAAAJXRFWHRjcmVhdGUtZGF0ZQAyMDEyLTA0LTE0VDA5OjIzOjU2KzAwOjAw
khM02AAAABF0RVh0anBlZzpjb2xvcnNwYWNlADG1fAQlAAAAGHRFWHRqcGVnOnNhbXBsaW5n
LWZhY3RvcgAxeDEWroPbAAAAJXRFWHRtb2RpZnktZGF0ZQAyMDEyLTA0LTE0VDA5OjIzOjU2
KzAwOjAwzaJC7AAAAABJRU5ErkJggg==</binary>
 <binary id="_33.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAW0AAADKAQMAAABUoYODAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQREhkzj39f3gAABItJREFUeJztmV1oHFUUxzdaog9LF+lLQSWVQvskJj5oWkvm
oS8RKj75JDTWCgV1WqsSK8lmKpVqIE0KPoj0Yx8LhcQH6QQVdiMWC7rJgg9KM+5uJMgqYTIb
lma2nY/rnZ2PTfbec+dekoWG7oGFmTm/OXvmv+fcvXduAolYPdFefClBNwBfdczyjGWWs/gz
ZhnltGXk0qaRBXADM/OmjzjNu0YhHIMrxqbA3l0PALyCA+KP05LOOoDjyGnstlrSWQVwHSHX
UAhHCcC9MKdJB6gMjjxNOlwIzyH0G+mwAbziPmVVolMlPIKEXEGvOAYZExJSR1+7XkItOCTk
KppCZxQCh4Q0lAKaIZMBhczdQfMkDiljoBvWSgRFDw2WGPrIiYS0C+ERWGLuc01l6qnQwSix
pjJNY5XYDOlgldg86QCV8Zsv6A/e5gsaj7f5gqDxzYdBIwoatSyoDA52OgoajQWQMoKDHkIm
1dPBHzGccoOzg3Fr+3CKTxCn/xg+Tnkug7wU4a5CODIMHJ0P2r+rGg4EZIANeGguPQcIR0Nt
xSUxPPcw4TH26OJ2CkYpuCNWkR28DfgXYniBpLeMu93vFPYeTA4+wRld/u6lxSvq4rec+Psv
d7vLk9eXeaObA66mHtfRAm8yJU0t6SjP9agHPi4cOZE8dhSd54rO7MWt48tiOMs6OCf+05Ii
ghv0JTaEm/Q5FYRb9FkPiMf8NWxNmTZPUHJieIx18DbhuR2MD7UT52wPsdWB4NpDcGUjuG4S
XJVtfYn4UC1vtxHntg6+g/BqgjQGfo9/I8PDa/wbGY2K5N/IaOD8GxkNfKxlwwZ+l+rhlG+G
3qU2lCEdYwy8Rjqgl9JAr7KFDE9HleAIP87fa8RX9gdChufR0I2FrN1vxd1zPq4QeImBR0I2
8ayPz+WvLne/fTL5an1ufO9XAX6PxEd9XFffe/MNtaiq6/piUQ7wGok/CPCL/w6VeouT50z9
d3stzD1Uxl7doEzte9SjZ1fKRS+6qf/qyO4HLcosbFTmkJ+Mh//hJTPtvrVZmXpSaiqz1IvQ
7YWrlcnHTiYHP7093n/ZTsSV2OYZOlhiowycUmJhzdgKiW/u6vjmK4s1X+tuKbv5zDSRDqv5
1lsGGe8uBi446DVMogIQ7orhthje3M1sB14Vw+fE8CUOuoH7066qGB5WbHUqBvdnOuE88345
BvfHlkxwxc7F4P6EWUG79+X79vXYSjVx4bOJrl35wcsKFQ/s1k1VezfnKpY8qw1r03h0oUcP
7JL1y+GRKVey5DsYly8+28/Eb1nq3ZFZB+N/asPFE9m/fmDjP6rayKyVMZ+f1T4spuOS2X12
rq8vtZaqPrl//MvJen7wc+ajhtYYYKEdf+pl1iyVapRxkIXTbVvwZ/YbKerrMTo+8ImRoSZP
x6UXOPDHXzw1sWd8om8Xkno4cPXuFfk1bXhRR1KGB3/6gnL25+FD/yFpige3MoqMo/+DpNeN
azzJnJG9SkcDFeObWHzP4VPXexuPeuSo0RUvZLTOk/C4IID3YDz+V90w9wLW3PX/AblmlsNS
pi9rAAAAAElFTkSuQmCC</binary>
 <binary id="_34.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAQsAAACHAQMAAAA7nu4GAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQSECcKgI63KwAAApFJREFUeJzt1z2O3CAUAGBHOUjKHMOHyAX2JhxhixzAR0FR
ilWqKXIALKXYJpI3mQJZ2BBj4P3As0e7SbFR8gozAx/mGTOM3YVbMXYvIfqvIk9vXk8uf4jU
0RAVgj8nSzz0p8TFgzklj3A4JEM8zKdExYM/I0sq+hNyTcXlhEypsCdkSMV8TLzipUDW8kEf
kmv5cDkkl8Y2BM6/HhHMkubLCLnW4YCQGZsOCLmO6wHp8eMiE7YGlEjYnRlEwtbjo0gMJU4k
PSWLRJbAoheI48QIhP968CshAyezQBQnviVVtpgvkmtNLg2ZamIbMtRkrgn76bAaIGstYLED
abKFfIE02UK+L/vj+4fIfdu2qOcS/6ElPwdO3rbk6R0fyLTEV+m+b8ncP5scx3/yu8QL99Fx
sor7i6fEVX/fMaa8/WVim213H1kTMgkbjM75ZWKaJ6h9lIkQHcR91xKiQvM8t4acXyI+D0bD
ZZbJmlOmYUvXRFypIzGVBBKx4DBMuYxEJhgNQxeXiIGcMVTpm4jGyhIeck5E4alLpGFdIZ4k
WMIB3ElOlE2MheF24mhtYF5lYum5AxtVZzLRDAO0ZbmT3EN6fpky0byacptJadJIyqAuERjA
IHFII4E0ycSUCfCJuLqearUTaCETA2PqnUAPMjEabSTQg0yMwhEj0W0DYrsTaJCed10k5PQG
GxBvhCQJiePl+0jIpdrGbmlshEwYaIN1eiOkh/QeYDZCekDmiuS3EdKjNNHFZTdCehROl6gb
O7YcTZV25GPHFrXwfuTlDZ796GRibpPweskPofaekyeBVG+f328T9lj+kIrPpGq54/foYyq+
kKr5rmPb1zeBjB3bBL+KhF2RPNBIySd2spTu+AsvwpdKwiq1YwAAAABJRU5ErkJggg==</binary>
 <binary id="_35.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAdcAAADKAQMAAADNdZhzAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQSEQ4QOGi7jQAAB35JREFUeJztms+LHEUUxwcURBD2kJOgGVhCcpTgxYMweFMw
ePSmSA4iks1/kIrswZMMMeBBwb2IOQgePSikIjnsSRdCyCG6W8EVF39kezcTtnfS0112/Xr1
XnVV9ZBJiMi+OLPTVfV59a33qrurqx3Ih7Zm8F9hP0q2vfZY+z1i/9csl2WiadHLMlklWCFn
ebaRsk6wXDnOsbXGo8Y0nmErGXpHilrZObaUoXekKAhXyBYd71gRTUHIio53rIimIGR5xztW
RFMQsqzjHSuiKQhYXRlPMHeuU2wNDjrGwEGCrXyzwIxDkWFLLy8wMxCSgoAtut6JIpKCgBVd
70QRSUHA8q53ooikIGBZ1ztRRFJAWVsVSzDHzmNsTVxEFJEUULaiDbuKSAoo64KEvRNFJAWU
dTXYO1WEU0BZx3QT7BicAsryiHfqDaeAsizinSrCKSAsVHQT7BThFBAWkG6CAeG+jLBVt2nH
mUiwPkTIO1WEU0BYX468B4pQCgjriTDBnkApICyPtA19oRQQlsW8B4pQCjCLisMEe0WoA8xi
OXtLhPUAcoNZLHRpHx1cvIAORJTF4R81vqsZ+wSxPmyYRYmZCrkGB5P2X6wHYJvB4F3UoECe
NuR9xFYXB8OAbZfrF5GEkkzQwg9A3mHqP8zutYfMx1ZU5MQQHA5mx9uvVcKO1ZePLQ9OSAE1
29oBQ6w9GMVYusAZ+q4sawO57mXSiwiwdlm4j9ixKZrGWLI42rbjYMC6iQB/Ld9l19Bfw06D
qg7rgg6zbQfYHYmKNNsGzzXDizLoZAqskLSukVPM7ndvKUqAYUft53AoIUCNcuLZ34HdaD+z
JYtoFp30LMYeAsuhobAsjMIFK9B837HoxNyxLDpxC8vOoprRlaWyLDpxJ5ZFAynbE6UCwFlt
2TVSpIwF86oCoc5a+ZplqCjO2lEJ37ANm2LJXY/ZCj82xHLUUGiWXIy56wDGhs4jJLAtUiy5
CQj37aeQ9OFHVmq2tMqYhFYFjgtzHt3KXBhAsYVxY+Sa7iY4LtyNpLIOCvNXscL2JKBeNRih
Ydj55ASWpn/FcjvCAnS1Vy70zLnjoukE2icDYDm40/bjqmen7kpT2C/jiiuW2YBUiEWzXjbP
DZ1489UA2zjEuEOQM3c7cgJNG9GytRtm4xvEzQk0bQrHVlAnkigING3KltVYCV32sLqnwrEl
HAn4FTUv0CTasR5LbVEQTLtq2QLklnOwfgIpVnfJoDK1vSGRQBM1yzbBgNKsFqi7UiyXMIvB
QdQKEGg8XDCs7YwR9hCD7Q2qAIFGecsySa5H/uJQMsRWXAP4jLpq2MK7y7NWYIlYgUc0e3b5
7InXTz2j2ebpS6c/PXFs1bJWoHaxNWhg7LaGNb/e2vz89hdvm35XPlz56dyZb1qWe4E1Yhly
x5rNm5vff3ldWPavlc233issawU2hvVnn3XHm80bm9+/Ixz758rmS+cVy7xA/XtXsy4vRr/W
vPWL8JrPn3OsCx8HFuaSdj07s3z2qzffH+v8Nicvnb5x8uV1swCBJAjNkiWQGVJNVuf4WR8m
jorZgWbhnBU9LAgsgRXYnVCTcQhsK3YMLAisgIVeSpm+cDS4Tol/MFDNGXaXYmsssHFsQ+pz
LAhU3WnWn3ZEV4QFgcqLZtGlgmVZdPMWlkWXN55l0TWlsCxqLdIXypoIbFvNFCuIuxRbkapK
sQW5fZVZFgmsLctSzkMWCWwMi5c+dZZFAtsOFUv2WbIsEtj6USy5E7AMS9ZmQrOkcXqvvqK3
jMLEilpGM7Unx3aaPg62c3NdhD0M2WHmHNymBeocHOOCtQyLtyrai6liTz0Ue0+z67jo4wy7
hw8nLVvJK7jocoa9xzos0XxZP6fGrKHsPX1fWMUtLicXowE7tfeUh2HV/ShI+ZX0Ipjdp8cd
NrNwZ8Hx7hNjO/u2YZOk062F2LBt7AWBMREcX12MDaQswvas25FdGITu0mx4MeqyPc8a3hr3
fDQPG9RE2J5nK2+1e6bz1vM8iFwtyAZSRJINMl+6Z2dvPMkGM7BYkG1yDTJuBexROEtP5zAU
HPZGnKWnZJgCBvs5ztLTKnwb6veRHgWbnpKB39rvfTlLT6sgFlVqzy1ukT23yF5fwhgRqPcY
WaK6Y2vkt97bRH0F/4tGYDgYdl9U+JJciujbmu5ebi5F0b1ctH5JLRiMoRFNLIsCzbMsimTh
9syhiIQ8Ymv4l9mrh95yZ5HtzSswLIxy0m1ODOrVyA0LRflQoWBNgIWiUQ8LDTaAdUX5WYWF
jTy74ZXkbYI6sax92zWOtsdmXnCZVbhlzdsuW5E1436IWHkdvnpsD76AnY3Mp9+W7Ae9W7w2
mj01Dyr3lqRl/PvQa/OhLexfg85JROyIPWKP2EfMNqfXkw2pbb/AArbe/WFOdutvHrCzudmf
gXV7+XKlj73zxrHnl197ZXTg+7V7+fLbPvbgj+/+uXXzNn+AWLOXPwe7+/XdmwfHJWbNXv48
7Gd3bxw0hDV7+f3j1ZoPtqQfr9vLP9zvy+9vHxx7cfnsq2zs89vk16DI8G7mQuy/rEte1RLA
1PEAAAAASUVORK5CYII=</binary>
 <binary id="_36.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAASsAAADsAQMAAAAW8BJPAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQSETARDqqQZgAAA5pJREFUeJzt2EFu1DAUBuA5Ab1Cb8ARZsEBegS4Ait2fSxZ
0SP0KO6OJReo5EGgoq6MVCRTufYwk3HsZ/v5d6gqlaqNNI7j943tvGSSTFbbavG7j60bN6u6
5Wb3uR2zz6uPx6/WIxZoX34dMT+V9eTa3k53gx4Ne9ue7e1wbkv3dGHexOVpMdoXasTCVOoR
OxxTM2JuKoeH3jIMmGFDA6anMoyYOqxowKjQPTaPpjGb524wmzNhMZvDDrN5MI+ZjuuAmZor
BFmKKsTyWBqxPHODWM6DRSwHHWJ5KI+YTrWAmMpVAozFVJ/xkXSf8XmbPuNZsH3GQ67P+EC+
zzSrhz5TfIO6jEeK7xSsPEC6x8rDbXqsPHlsj5Wnouux8sT2PaYLFnpMFYynp2BUMiWz+kqq
ZVZfl43M6qu8lVl9z3Ayq+9AXma6YkFmqmIsQZxRzZTE6rTxWTBWp43vE2N12niGGGseZdgX
GavTxqfBmG5YkJhqWE4RY9Qy1bI2bWwembVpY3uVWZs2lqPM2rSxr2bWpo1NJDMtsNAyJbCU
pMxIYqphcHlhHfZdOvItu/ywiOkzMXx3smhu4e0jsO36Qdn2Xkz6zT8nFuZLC2Z+vlBh5uZr
F2Z2vnZhZuYAZnobr1SYqfgZMIo9Yhbi/AZs2ks7ZC4VkNnUJWQmRSDTU0kjplIJGaU+EQt5
hojFG5sdMJdXiNncKWImhxDTcU2YqbxGjHKvgKUmA1l6HrCQOVYBLN2ePGTpwSRAplONEFOs
BhixfvuMtRjA2POcBczxap+xu7oHjD3PBcA0q1OfKV7vM+I9d1nRYLpMfjXxH93aXti/srAm
idWL/8LZ2UWP/eFb73usXE6Pn8Cj+x0tYrfqQdmyQX/LfwRq9kNXAS2yqzViNv2Xeb2I/Tpf
xJrlmTPf/GEXmWv+/ovMNi8TRGaaVxMi082LDpGp5rWJyKi5JkksRDpgPg48YK4JiGxKhhky
kyxkOo0MmdoXfshoX/RfMUcWAQ1YHE4NmBMiAoupMAMW43bAYpMbMHXY8ANGh42AWQoTZGkw
BZmTQi1LiTCQpaiFLLU4yNLMPWQ0bwXEWJAAY0MpwJwYaxhLgwGMxSxgrEEe/8BU3vSAUd4M
fVacjNRlxamttuKyY9I76GZ51Eeph2LFnl6kmi6aN6sbvn1Fc+28aH63lF3L7ASxzVZkm83q
m9zbUdXbpcjCz/uxT8S2U97u3nB2sfkLpYZ1992iTwgAAAAASUVORK5CYII=</binary>
 <binary id="_37.png" content-type="image/png">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
ywYEAAAAAElFTkSuQmCC</binary>
 <binary id="_38.png" content-type="image/png">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
plVcbZn/AYwQdwv0kSWvAAAAAElFTkSuQmCC</binary>
 <binary id="_39.png" content-type="image/png">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
gg==</binary>
 <binary id="_40.png" content-type="image/png">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</binary>
 <binary id="_41.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAKUAAACXAQMAAABOVwk/AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQVCxQMECIDBgAAAXpJREFUeJzV1jFuwjAUBmAkhnTjCB4ZewTfrFbFwJjDZOhW
qBhQ1bEHgAgkOrRKowwxwvjVLoS65g/Eiio1WSx9cV6e/zhRegQO2QtS3Ts7bowSTaikvR0y
Owh6C9Ic6rqBplCnsO704twmml/st30Oddo29WWA7g+aQ11CnTbRHaxw1BRqZ/LFuoW6gpo5
Gp10BvX5Rx/7zRVXmMRXOvu/qacB+S48VcLP16rkVp98ZehpfjJnr3sVXqDOO5Yv1iJAV1rx
c33VkjXVBOq9VkALrcHdcGddSx3vnaRSJdCKJXd0c1KG3pZfWlxW5dZ9COi3a/n63wcn9THc
Z31fS6gZ1O9vVAR7iH0ddSzfkNQ35xpDjZDetVYxgFq7H/4s9fb/60GqBM0pJ+I0JkWSU2xV
C5rRu9XYnDQ6PGpiJmlu+i/tIiotaEt7TgNKXS1JWo1obbWqm5kKO06bg1ZzF/bmzFyytmEN
Tz182B5uHVWcRod+mRmMxjVr+wJSfdBvCNuCzQAAAABJRU5ErkJggg==</binary>
 <binary id="_42.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAc8AAACnAQMAAABNZkXrAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQVCzQR5qBLfQAABI5JREFUeJzt2UFoHDcUANDdBuIe0rrgS3ponJMLPTShOSQn
z7nQU8g9xx5C2joxLAlhx0sCLoSQQw8l1LC35BCCb11ak1VDoYuhsEdfQmZLoUsP8awZvLPO
7EiVNJrxzuiPJM+ObRqiy4DQk7600kirqZCiCVeOlY4rmWRni/ayJZJWMSEO8dkD0UcINBOk
y+BpKUIaihfzqO1oaIjs0in2XA0NnqAc+lpLf8qjO1q6YdZquzhdqZpT8t3kCGMLX5RGuGP0
4+whsiVRkqFtC5pNfUT60mzCJE0bL6A53ETE083hMe0UQG1EdnXUo52SKaZDMNRRl3aq1KUe
sIG3Na2yTskB+waUd0qmLqNITfeKU96pukQdglZ11GdlQHpCR11WRqbIgPLq20dNEUxtg2FC
rAxIHQPqwFQ7m3gZmZIjoPLvakJJipawXsfE5C0BBjwFfcOyNa+1qHppvR4PHbJszSs8qr50
qjn8cOpJdNuADhVU2umM6crXBlTeJF+x7BX19N9W0K2GnvZh2sIfFKBtTsnAVtAoMpjWSLhq
TktY6qxVzKbEbH6rUaekgOs0O2TU09BaPh1LEQfpyEAa8Dn8MJfWQYoxtgTdyae0TAjQ8Tzy
OcXZiPcpLRMAdDQrKGnmUF5GpiHLdiP690EpDUbQcS7lnVJRYsE0hGnA3uyOoE4epWVcNc0J
WEWRmgYw9U2pUwoF12tqvevWq8tqtONWL4CtisiyATOa/DHDt6ag35/unTx7/iFAbYk6afrZ
5eXuwq1P09TNp8/36eKd5d9Pfjwj03b27X9XoreXNxe+tAQdKCmij41kk7zw+Y0rlF6MaX2y
U5MUX61m6OrapVPvnf0oHqbe4mSnJmil2jiRoekU9OowXeEB2zS7lUdFwKL6hPIaO2o6whDF
8zx7yEZrXXOWyNC/iDkVkcV0PsrePTgdiNnksUdTTePIBO0egO4mdMAGySq0Ne8RwtuI+sEe
mtNaHBmu9ET1PLtvQP2Ebl6aed9OUcuA8iPX5hdzXyWtbhnQ/j49P7dmFaO9mz/82Yxpi609
TV/j6nFlz5srSgej1dPWJA0NKBYn0yZJhqlmQFvl0Nk0DQxoKB+lTWgtn/oGNJAo9o+YTnuU
xuLeTNVqEhkQ8CFTF6bd4tQpRmt090U6OoAoqdFdS0tpGadU2qLZtm42ieplinXv4Ry6tYND
Ld3hd6YSjS41tUsdoH1x3aqhGPjD7Yk7U80bMQQo3TubBjQgZa5X4nd6JvurC10ujM5oadyp
At+uhlZ0GVjks9eL3+DbEAPKvoEVpAS/o+/oYdFplvqB0zF/V5+eQiObpEBBXSMavhV02/pE
SaM/7Q8g2qtUVXQUzb8qSC01jc7rjZID/t/9OIdHiYJqVk46lbrUA6hYKnXyqHzznk0bxVsN
ZPrj5trS3YaC4qsLS398OOPLtPvPtetPla1aj579vE7PoBJ1tu+7rqpVYv96DrVngIBffnPN
dZWtLv2yTs/fAF2nASspRo+etUD67b/3vI78kWE/hejxXHc+vvpN/TiuItYoockYpqD/AbA+
QhBNRzrAAAAAAElFTkSuQmCC</binary>
 <binary id="_43.png" content-type="image/png">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</binary>
 <binary id="_44.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAS0AAAD2AQMAAAC5o0P1AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQVEgM4J+Lr2gAAAXxJREFUeJzt2DFOwzAUBuBIHeAI3bgGW47DFbqFCcauvUGP
kXbiCkgdEiYYoHHVgUQxNUhI+MXyi35VhpjkeUrlr+/9dio3bWKQUSfDsO0SYseigliOsQxi
tQnJmqDsGJRtMWaECRM2HvYUcTZhwoRNjcmJJEzYxNhzUPaAsbWflVcO859IVdFlN/5q+03y
MxZfbOZnbjVmpXuMuUtg7sLJQMxgDKwWlg2SDWwq2WJoOsZs/hMpjmwx71tETSVbDE3/U7Yl
lu0eq8Y8rriMPmBsUjuVdVlFTqQit1NplxWk2u7WPhg5LCeMVFMOoyvd8U0v/Evouwut8Y4z
PyFgtbBskGxgU8kWQ9ORZyMnUnTZYt63SWYDm0q232maf38dt/6XLlMYKzlG/pHhx9xZQplB
K1XYhjDjTHYgcynPXu2lznim7eVHT9OGTPVUq8k7bDZV8k0JaxTE9IvD3vzskd83siH6GroL
pwXENMZarOk7xqoVxO4u/+qn4kTZJ8GU8IsMeAWpAAAAAElFTkSuQmCC</binary>
 <binary id="_45.png" content-type="image/png">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</binary>
 <binary id="_46.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAZYAAADCAQMAAABQXnaAAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQWCh0aJkPIxwAABKZJREFUeJzt2k9o21YYAHAHh7mHQgu+eJDitYHdCu2phR1C
IYdRGDts7DAoO6RjB2P6Z0yBXpTSQzZIe+ill3VlrFAopOtlctoue3YbYkbLcjIzUVUZwjBr
p3hhrKpxrLcn25Le83tP+aQ5xdmik6L3fk9Pn9738vSSBI58bCYGZf5M9I4JuLG9E7Rrtt04
yRhGj9E3M4Z5dn5yMn08G8kY925amoEimafv3Px99kA0Y7Ru/xb1Psa925ZWiWauXDg5mR6J
FgPc6pxsv9mIYfD/3jhvHEntVSPeJ6+fyaHIZkqPbvIvvotqHuej9s15+1Dya3U438+uiTmu
x0rH96sYX4KbMs59aGjkZGYf1DjH8JhyYIGc3QWbDRvnlPZ9craQhZoV11Tcvv2YgpoJEoPx
o6MqidubQLNJxfonFWb+ot8PgpkV2qzADKKNzZeLjEqbFshsMuNtE2Ra7BhVIcZmDYKYBmtM
iDFZ04AYxBo+2AKjsutrPti8cfp+bgNMf53+NgZluP6rWxsuTmhrw70Pc3sMV4VrhDdoEIYL
Cm/UQRjuhXGGf+1xDDdIAYa7whl+6G+PEcyB6rAYwZyOdrLhp1ouC//zpr+CoJkdYC7OjTzK
fD5a2xfB6Iq+as1/oJhiEzTJmOrLP85VlbLYBE2y97lgzesvdZnxmqTNef1jYj6SGq9Jynz1
5Uw9c3ZuKSUxfpOUCQ6hCZqEG/bYNTvMCOaQOKb/1jvKCH6XxDFoWMwwryle17oqzpovztqS
X/fGMVuve/l1fBwDWMebgzCA75LX9Z0V5xswzrcm99pjmLDv4NpEUIf+rvfaeJXiTZbqC71/
4D9fkzNBF5Bkz8EJMaZkbyPMyPZQwoxsrybMyPaEwkybMcH1MOMwe1xNkJHtpYUaZs+uATM2
bW7ATNMODHk4kHGmAtOkLocZfDEwdaipTfsmKzQl3hSPeWcL1FXKrAuMn16zYOP4BrHGW1+v
/zw3Mp5m0164t05qPOiZ2gtFn56PZhrTSvXct0CTuXrk0N7TrtGV72Hm0mJFV55VE43cF7oC
7NviZUs/u1xMFEkMDgJjsPiDpSurT8k4aDe6V2x8ple7z9iOictdU/lVWa1SY6dOBn5dZOp4
goSM1EjuITEYPU0Z26tdps1a92Kr13sbBWN0A+PSL29lO7WL05Qh83jpybtugff3Cd+MYKwV
8sjG7tTuj50Z8kMSa5rhJsVMvyF31srvoe596PFWS2Ft+TpqYT9lGVM43DP089RUcp9TqCXO
Oa3wades0IZ0StMqrCku71lKd0zp4cHsmijWpeKJ7CxtrPu3cgU/1lhkbK8nvnlQ+OwW0CQz
4/vf75rctc6VNZlZ85/4+fU7ZtfkCxg2RrV145sbxCyVM70YgMydT8TzW5jRTMa4uSCMtVvQ
dmukx6Y6MQiMmwuGyLgFTfE4cGt2Vh2PBLnwt9i4udAxXC6QAolxc6EtzAVSYEkMyYXO6obL
BVJgyO4jywVSUJTnguWec7lACtqSGJBc6P426s8FUiAx8Fz4d2brXOBNcMjGqNTMTVFm+egQ
GDL1B4fwefy/PAamSCHR/7K9SvrmH1vbJfTndA1AAAAAAElFTkSuQmCC</binary>
 <binary id="_47.png" content-type="image/png">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</binary>
 <binary id="_48.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAVMAAAB7AQMAAADzDfHYAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AQdCzInuvRRjQAAAuxJREFUeJztlr2O00AQx31CImUo6cwjUCEaYl6GOmWEkGOQ
kK68litOfoQUFCmi2CmQ6DAdxQk5VFccYg8ZyYlsj9mvWa83sbEVvk7KSGvvrn+eGf+zs1mr
7Gxr60+xxXc1eHVWBo4BbO5r7HarBm+jcmQbbPbYa2Kf+Cb7SGN/VOxVBL7JwnQ/+56yocHm
Uy3fm4qNIrA9ky009ttzNbiIig8GWm4v97PnlLVN9o2W77uHav7kdPPaZG/uaawZtNluHwva
KCy9HSI8skf2yB7Zf8hubDWAQT40URj0YIc662jzud3K5hVbDuEgtuzDVjOU9bR5cEy0xoLG
+uVhrN+DDTU2tyobgtVkd/h5J3QTEropaxEERRqzNs1YI7TNed/NOCumeJsB9kI3kw5m9FUS
ZAnPQXpibQwYQUxRh4FP34rd9Jr7RScZCQhIQIZi2EiMLzmLydGkCEhAOCcs/FLEWXCWKFEy
Aq4pWboQ9xecjasHBEKTzeb8BpsB16x6EEFsssVM+r9iLP/dhmfsOgNM6AueMsGXIT8xzXjX
j9h1DKlEkht0PBK3eM51UCxQHZD9KjvxUtzDidKBswUBPOUlOX6u1GGaKh04SzXzkMWX0jl2
lA4i30hplmAymdShXA9Qh4tI6BAji+4KHxOfoA7nUgfULMGTo4oUpKjDyanQATVbP0B3UrPS
TWvroag0U0akZpCltfXQtnboCb2+HprXDrWPltRBWMvaoR+3YjVEsIZmoJa4KA9aA76LhbNi
NRTjcCxrSFSumB9lWDgrq6geT7GGePHJeMsUu5StwrK1UyUkt4gFwRAvqWZYsbRBtYfgFjGP
MfWnXfcobqZIzfZ/nO2LXxDhLWM9jYVm7CB2z1FEN80VZZ1WVvscysatrLYJUHZt/D/Wx4Ma
W7fcs5tC7K6doDGdXfZzD/a6B5v0YNN92F9mm+3I/gY2HzmdWXD97qzXh+2RQ49665XDpAf7
LOzM5nedzmyLrX8CVmZWow5yL6wAAAAASUVORK5CYII=</binary>
 <binary id="_49.png" content-type="image/png">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</binary>
 <binary id="_50.png" content-type="image/png">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
AYbc11WYwzPaAAAAAElFTkSuQmCC</binary>
 <binary id="_51.png" content-type="image/png">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
gg==</binary>
 <binary id="_52.png" content-type="image/png">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</binary>
 <binary id="_53.png" content-type="image/png">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
rkJggg==</binary>
 <binary id="_54.png" content-type="image/png">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
wr8AAAAASUVORK5CYII=</binary>
 <binary id="_55.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAKYAAABSAQMAAADkRT07AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUBBgcvOWlJzQAAAeBJREFUeJx90b2OEzEQAODQXZdHuDKPkZqnoEHiISisEydR
gqCiQHkMCiQsEZpIK+UFAB+ioAGcY0/yBe/MYO/O2LOJxaaJv531/C2o8QyL/+rNsqWbvqVm
aCgmP1cgsucamxqIXEMPL1p6dP5c/WCbalqKbV23FFoa4qalt8uxXvxGH9dXn2vHo0JPP0z3
82QOx57+UHdXZ7am4eJZ39MtdQfWv4SPCF89THqkrWhYgyd8mfWedqJ+/z0Qvt71vb2r6g6X
MWmKXf1+Uu61OeFwsT3erD6trh+zmrxQ8HtIWwnE9SK/2SP59OPegG95PptDHDOeTieM1Z2q
L6+0unKNVltSajWlPKVI9V1VKG1r5TxurlyTnysfw1z50zhXTgNz5ZJwpuVktJYvrdaSxWkt
FXmtpfqgdS/aa30n+kvre9EvWp+KflWKpd4PWmtvpipUtVVjnU5LQVrOGup8fVVfd9HSIIPI
6iTEa7V187GhTraS1UiIVYpUFYtCWaeRLU+K3LDSSEvRK+4yaaDNFALUzdVODXfcZVKv1Yu6
pG4aw7ahnnbcZVJLb6eQrFHU0JspxKV7lT6Y1NK1AVac0nNfokByMCS9K0WZUNYogwGtQQ7A
Mx71sMhP0vvxz+Wo/wBHnmn03NnBuAAAAABJRU5ErkJggg==</binary>
 <binary id="_56.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAATMAAACkAQMAAADBgltSAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUBBgogHHgqEQAABA9JREFUeJzN2L2K3EgQB3DZBm9i2EeQ36RfxZlfwlALG2w4
b+C57N7itLCBE8PGxgZpWXwTXCDZCjRCUte1pr+qu/VRHD6wgpFAv5ku/UsfPcqQtVTZ/++a
K557PPNcgcByoCTDScSS4ybE+le6QeYdzwmem5DnRubvjcz68Mh0JXPcgpfzCI8cp86qB447
Ad5w3FHgO7HvVHXj+Xrftdg8yFf7Th2rwHvYdZfSmnzPjfozvjQT1+rViz1nWhEXGDsp9Dou
MHa9LfNq253sxs22O7odYstJsFtR6yLXu62odZE7+c2bLZeTPWLdjWQ7LDB0LdkOCwxdcP0E
rQtdUFLQusDR8qLWBa4NXHBuBe4QOlogdRJCRwukrg9ZUCB1p8jR1lF3jB1pHXFxeap1b5Zc
XJ76ZgaJa9PyVIHCDuLcG5Gnrsqf7kI34ueUYXN97EPXxk3Te1+DDF2tbvPpIl+ieWZbV86P
yXSZ0DyzvZNLbrDPbOuK50XXjRC5LwuTB+V6UYeuZ7qW5+DHshvhP47LdV+Xc0nccn5DnN9K
35J+1Mz+dovny/zMhsD9g9+XXAMy/L1v+HHJPR1/hPUVGcCCe6iuo77hwiQS8Q7NXMu4Obxy
wV2jOT7j5lDSyQ3KHE1exs1fSidLOAo014NxHeJSgGdAE6BxNeJSQ5r5oyCuRFy64J7sPusu
34HEPdixrAOHg+XO1m6cdIOHy+URN3inDyEJcI7P7NROR5IEOMdnBtNOiyTAS3y6eO30iEmA
jV4VzukjSAJ80qvSuQLdAHQx09TaOfAD0MXcwzvr7IBlyAYzQxisswcQBfgz1+vJOhtIFGAj
9FpaZ/dHAVam7Ln8i7PjTSuuMM7WHwV4b8ad9yvX+DwgdHajvrhD7nb/RaYYzdWt3ezuRZVJ
+Nvt+2Knp2p57N30YxCfqqwnD+gTibrw3xlxqLKBHGZJogZfrSJV1pHDLHzUkswrFKmymhwm
+Kgn0m715XdZSZ4wcHJuQOFqUBtvs7J3+Uk8uVoH+ySa3Rn/CN0n51ryL7P8CZH707nuDDzX
C+ruQ/d+zUW/92rZnWNHjrf3uZRSHW/d0PzWc1nvh3et6sdKf5O+hecLPQ9s2WoQdR5MZAZW
k5k7+Nn5hL06n4Xf15Jbx3F040ro1PXhLit14n5wh4TPz/6cPRyi/ym3fpO+HWhg6/0QvT1s
OXp72HL09rD5XgqYrmC6kunI/XXTkfvrpiMBbjoS4KYjAW6/1wOmK5iuZDof4LbzAW47H+C2
8wFuOx/gzntRYLqC6UqmcwHuuM4+03fccDiw3AQty432XcHeuDbqXRf9X1hZuvj/x8pSN8B1
JctJ/L3d9GtdN/Fy5vaD29+Jeb5I6FkOjyeeq3Kec/5flz8x7Lj+/swAAAAASUVORK5C
YII=</binary>
 <binary id="_57.png" content-type="image/png">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
YII=</binary>
 <binary id="_58.png" content-type="image/png">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</binary>
 <binary id="_59.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAZcAAACpAQMAAADdr+InAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUBCAcorZPxZAAABVhJREFUeJztmT1vXTUYgK8AqWyFXxAQPwDEikQqgQQTbGwI
JD7GdACpSEU1G2MQHWBBl42RkQ0jOnSoUCaQUAQORCVTcaNGcYivbc7x8ftlO0fph8qH6iHX
533u4+Nzzmsfx3eRbrvExX/AifNf+0fP82/u252c506c+3XfHjgPnPvp7JydcwRFZ3lrzhEU
HRXmuiYoOKshfrITxAWBM7Qz43hBwRmietZhFByXlDnZcTExik6cc+yq59io7G07YX3OOeYt
3pWzmnWOuo5fzjlu/V45+2fnnN/XTOu4xO9m46TuM22d1VNYdd3c6eRbvIDVfr4Neb1e9+hp
7jAKzlGKb1Cvzr37yLmX0hoGDlI0reNUoPsW/9je+PF8WmLAqr9693pz11Hwp92NL3bTJgbM
cs+1jrm55in62vbG6zfSq3isdzgFR+fbAOWVnzd+uRH38FgJCo4S896Xb7748pXVC/ilJGhx
YvFK+ZqqYwmSFieU/lFfePGSFidHDQRXUklOUHBy9MTEtpIWx6LYK0bS4hjsYK9oSYuToyfO
8krS4uRo9drC10dMkk5OZO1hOYBKqOjkBNbvXBZDObNeDnxFJ6dEjbyCrXLgKjo5JWqlAzlq
Kzo5VjQIfVsmcQInHSM6XsqhSuJCkE5OicoHtC86yujklKh8QNCXWH1ODh6p1CmhptnBqO45
vqbZwajpOa6m2cGofbjj2LqSHYwefKhSU/DkeFNGB5JkSGWdmoIULiE739DZt2pjmITqgHRM
b3xfqAPZuQhHuje+L9aB0YnsqbVObEKjE9C59Hg7JxCFwZEdyqjnOg5l4TY5npzP6imUUeE4
yuvNdsnsKHM9dzQ4W61jyXHkWHKu9hxNVXQMpFRMX7WOoYQTDhyk99r7ppsRMjoanfhkz6kH
w+gozDLVmedVk4O10yZK+14anEgjQ6fmP43Ipz0HTqBJZNk6gRzohXTOpx9qxyONUBscjxNc
vJWe7zgRzxjBcQmmu7B6ppkWHToevjc4Fh0/TAe6coiObWvmaIyayjFILdDBkdF6YUHUAB0c
ja2b1D5AohpocSxG60RQ6Cigg6PQGWt1wiHNdy9MTq47jFYDiGigr0yOx2j1gAI6HmlcBAx4
vKjK8ShmGhd0iilqhEPUIuXOFJUPiC7FII0LunxD35JOpD677OyMa46Fwqh8QBMdawop30tT
dNVtoQHBnSg+6kIDjztwAtV1aIBzhyaSXnFEmQNR03UsUebY6lMWQ5Q5EO0vzTVR5kC0vzRX
RJkD0e4DwicQuBObCi+BUXKoeZXaQo5izjFGdcfhlBwPzYeec5iIkuPQMR0HqTfMsdC87z1U
otwx0LzrOUYT7Tm9REBqHXM05lsvEYhyB3djTM/hlDk4FjrJE2n8BL4H6Sl6SifQ6O0knKDM
oVlCNY4nyhzP5p1ZZzgTOI7NYLpxBGUOzZSmcSyj5NjTOeN+EzqGzeJtwgnKHQNNto5mywFy
NHPaJEVqxi1O3O9lb7I24ThFJyb2xuwtFmkJ4btOk3ABqRr/gaC9NHqbNwknKDoeotWeUY9y
h1YaqnIc0PznEu0nshXN6RwLTrXP1KPfMic3X+0zTcUICo6B5ued3PSvtGeXaPVXJ5ykf3LH
QJN1wilBwZHRE53c9CHb56NVc5VwFT0uTl4KjT+KfDRWqm0Eorny0P3+jfL/5hzBr0/frXW+
Jii9F5alsrfecQS9O+fzKyX6xP7HrcMpOZ++U6LPvn2tdTgl55O3IPrB1dbhlJzL1yH6fuc8
nKJz/fJc3wRFZ/fRcpXfP3bzTOMI2smD2R8RR3qPnN9mnYHGvwEziaxAzfFzzQAAAABJRU5E
rkJggg==</binary>
 <binary id="_60.png" content-type="image/png">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
AAAAAElFTkSuQmCC</binary>
 <binary id="_61.png" content-type="image/png">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</binary>
 <binary id="_62.png" content-type="image/png">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</binary>
 <binary id="_63.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAS0AAAB0AQMAAADq2/YmAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUCCCQANDqBEQAABAZJREFUeJyt2L1uHDcQAOATVKgKrkjvfYUALhNkH8GPkEcw
UiVFAkaVShUpXVyZV0hHGyqucIItVDhNTBlXOEXgXeeAcA/8mfBvf2Y4EoTALKSD9C2XHA7/
bgOPKePmk7Bzwu62nLJWYLY7cuwIEjNhOdZDh5gPkGEKNGIOSvW4SDCIGZ6JmZn0QY/hBevS
iMxcYTp90BYzr2RqcV+x/kHWfx1/97ZFzN2qxK4m9uFtZjvMfs+sm2t7wrI/Ccu16Ucz9SDT
nyXmWhyQQ+wpiD0OiAEStzwodBSqwRIi/pRk6O19GdJjJrxk2DW8QczIk6qVfwpfIqZvrvqa
jV994RDrrdA1G8RvHjHlS9dReRnaLNZM+pKAqPwEvpVrJjz4mr3r/VatmOemVhMYXPTwcWYu
MomV7+CFgnMNp5mZyBSprQOh4MysmI6MBm4Xxz9k+cL6yGjgrl1o7pVfMRUZDVxnAnsDYmEy
Mhq4Tqd8kwsTkZHAedWnZ9XMihHYNSqxfpiYy0ySt8rEYs8yM5kpwkR63MxMZ0YC5/Nb3Mz6
zEjgXGZ+ZiozEjiTKhLw3cRkZiRwOj0n4JeJicxI4PrCbgqbiUBMJSbhsjA3MYmYLOysMDMx
hZgo7GVhemJ4+YXC7hIbzvuJ6bu5dX7zY35ewvjDRWCdVRMzzfXELLyYmH96CkxCOzG7DMQR
3mcW6tj67zehpTNL02MVtMIk/LopUyq3bYmwimEqTMAfG5c7WHrKsfC3vzYGsXkg5DTXkh82
ZhU3tQxEZO8SazLzLcfEwcMhsW1mdrewcWGvw9IQ//G2M/ZZWPChWdg/C9uDuEm1dcZ/E5hf
1XZcvRTEq8RUZpZnt2HxSEyW2rbcS+U+zKnEwjRsBxS3sA6sA/J66mlgjg9vjOo+9TQHZD2m
DwxWeF5CPfTrDIlDH5CAOpHW+RYTKWQvQJ2WI+zyXAjsWUzL4XxmfklyvxET88fTfH5LzC1T
BnIjUl/sBWZ0kc7MrE6Dpac1S9s9ZnQDyaynTBHmElOUSZZJygTLBGHVxpvYsvYCu6iWzcJR
Vh0K0tZjKKuOGIlpyuoDS2i96ClTDPPpr4hJlknKRMXixBEfMWPOKyGLPAyYMaefW3AO/saM
OUsdIJwpLWbMyewSjI5vWTPmnHcJ+jnNXlWzV/BvQ7NX1uwOPjS0p6JmI9iLsmdNjAlbODPa
dE1bMSZs4MXYIjY0TNgAzgZArDswYYPRf4tZ65iwhVhcIRZ6oBjWkaN7aH/LMHoRuOdyR++A
R48vKaUIwjTcwxxlTE/nXJ2Z5dnn5L5w4tnP/4vpT8tso2oWdl7MjuxUqML7yMFyj7v+81Oh
SiRoTxzTcR9cs/17jo30i46x4dj8tcl/bJOHdc+eLuQAAAAASUVORK5CYII=</binary>
 <binary id="_64.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAcIAAABiAQMAAAD5vUFcAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUCCCoSWQDd1wAABBBJREFUeJztmM1q3EgQgNvMwXvK5A103GOuDuzShjzIwu4b
5GIMSXrMBjaHkLnsxeBlDkvOOfgBZCcHQwKeFwjIJgQl7EFjdJgZJHWvuquruiXrx9JC2EP6
IFV36av+VVVJTI0sZ+z/Tcry2c24Ph8qlX9z8gV7MpJ8/+fYPj+c/DSSjE9OvjEp769/2BOj
+lSJJw8j34wmF6NJv3wnsaxYWUaRU31peKqXXMFtdzg5h9tGDCVzJP4YSqYo3Oq0j1ySNB9I
cpJuhpHOYSkZoLRiO/1k6smf0MTUWOkhl56c207PwUoPGfqVazDAldmsblKKSm1SXlYTIy96
yKJazcuzPwUx6SHTDk03mbRqih4yatXIHjJsV/FOsrq0teF0kkWHLukks9HkukvXSbZvSjme
TjLq0BVAytuuzSM3vINkQRMZWrJpXBLJqyZUIMlEG1m+OlcNZu39bHrbZyq1z/Q0XgW+r1LW
jCFLx7XHvUSxLBdIXlzIZwLrUAIzdnOE7gUbffcmk0N+UpJ8u9XS1tPBTham3zjWcuy0KaQL
MyaVNM3yKekyeKUzYy+LjF13nhKwO2Ol5V9MyzHp1jDQDESzAPI30kZwKmcsw31zq5vA4mRO
VOp30obwJszYWglLCrL6/Bl0bY4uNJ83kFJEQHIiL83jmoxeCiBnRIqjokauArL6GUlujZTH
gUYkTi2ZFBxIF3LCT0hOShLmssIRSXUqibTvIUXIMEWS8c+WlI6MkcyRpN0ObxSzJUCSskWp
LpDMFpYktxN+NX2W9UnZvSUTIpeOhHk6Vxd+RDKIiEyJ/MuS65upJcm9Ri+EJVWU4ltKdsUx
7orzNyGScHD0A9E1kpLIHUPuu9PnLMwdmXiEtcBhQfbZltpwEfIHMDR9WTvS2t8sYMr7LHc6
uwirA7AqzVxpfjZnuFqaHrQfEqSzwtmh3Vqhmyj62jf0aG1mpck5piu4uDMpFkhKQekJOA05
2RqXpf2tO+l2KudqJqg642QXbrvSuMuiGh3A/jusRqpSwIYNB7W4AnP6u4U0duWykSx0szzA
ai2WrfXoC2uuFgXlI+W7z1r83E6VO771yHtUeb4Ws03Ew6Wu5wl6UV0KXM8TdHLK20juJySy
ojN/IijhDevkrs2dYRtFRSkZdzsm6tH+i00JLw20qA2XMRxsew4G5Ji87/JXnQC0pzVZO/n4
Na9ExlqJO8h4emtxvRK1k4fxj6q+uF4J+8hFCyjbvwCe//xWb0/crNWnqzV7gzPbtkRpB/kP
jqqxLDtIO84F3Dasmhny/m9B8G5nu9XkT5/7O33zQh6w41rTO5A6J7HZpJxQ4/wuZPlFFaBI
grgL6RfMmMzkh/39mHh9DyNzVnp4BvzQPy4bWuH/8K/mX0lpzEYpS5GvAAAAAElFTkSuQmCC
</binary>
 <binary id="_65.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAQoAAACRAQMAAAAB02S+AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUCERQuJF0i0gAAAjpJREFUeJzd2D9u2zAUx/F08tgj+Ag9gnKDnqEn6NChQwd6
6+gxo47QMaN8Ax1BBQpUSwEl1SAJIvnCJLYc899Xg9GhhscP4B+f+cgn3Qh9DjdryINCst8T
saonYsQQmcUSGUQUkG4FMVIBaSYmRpr/jIy4aFfdFeQjEPc3fgHiNoMGYmSSIk+eN2adJ/L9
vWR3ryOjSDbMsdVyYY4kF+ZIcmGOJBfm1PaZMCeSCXMivdgNEC3jCESKNpVnIXWT2p8L6Svp
gGglAxB3yDDZz0CMfGUyJM68q5OOScPkfkKyoUW76q4gj0DcEf5bAXGboQTSSNkCaa2Kr/pM
xk9io2He3LDlyzdLnn+MSTTMJYmG8W77WBiPxMJ4JBbGIy7MTz+PP3mUsvVHCJ+0NmhKn0xT
kMcn9lswQgRT0F0wHwQkHCECEl6VIRkUEmFi/WMxJJqJqOuQisgD1iUcIWJkC2QQ2wKZxUxA
jMxeNwXEqtbrpnCw3m29bgqJ8bspOp5fholP8CWTjknPRDO5uNUTpH4zQiRIL48jEO0WpfJE
inIpTorUailOivwVJPo8QqSIu5NnJDWTH1cgs3w2RCzHtRvOsmLRSFZU1543cPIxV8kfIpU0
BZBGqhpIuzz+Jsn47tRN2afygknNpGeimbyGyZOaSc/EhTkoeFtRSLEHUmsZgPSzTED0IIbe
nHwQS8RV5haIGyF2RAYkVc/EMLH/iDScpfnFhKvbMRn4b5x5M7gRgogbIfBl3G57eAIoPMkR
DPh1FQAAAABJRU5ErkJggg==</binary>
 <binary id="_66.png" content-type="image/png">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
zHYrtv8FGLFw2RG1qF8AAAAASUVORK5CYII=</binary>
 <binary id="_67.png" content-type="image/png">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</binary>
 <binary id="_68.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAeAAAAB0AQMAAABnmnM3AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUCERwVXY9B/gAABJ1JREFUeJzd2D1vGzcYAGAGHTTKRYdmuwYoUHRK0Cw1EODQ
X9AhP6A/owU80EADePTgvfopTJEhyGIPXQPQgVBoMUCrBkqlvCPLryNffpx0toQMeRNJpvQ+
5B2/dCek9gg0PZXDggT4timT5dFrHEvrD2ex8OrZEcCirTR1fAMKm+U8Fi5PntwTg8O4PHkK
8Y+zGn4L8MufIf4e4h++KvGjm4tY+O/ld7Hw+uRbiJ9V8PHNcgRfJpg/v1BFHL//C+DnEP+a
4lrL70GNYhxfPz5Tecij059iaf3kPBZeffMlwKvFomxZ/YErb/p8gBmtYTKKGQVYqflY3pa4
x8L43PA1qtSCUGW1+PQvIpZNpbtv9VLCVds1atMGvPaPJM79owyT+jbgK9N61ootr6rYpH8M
mISnGL3yKWW0vm6H8QbPFE0z7mzzNSuHBpErbdRMsTRF77R6peG0suGY/lSmLeRKXFOeYma7
K55L3M+ExcxjoYeFmfdgUNssgeV4TCLBuIbnkJyNYlnFM4gvMrwK56wwzc+Z2s/JKGYB/3NV
YGazavjOfsLCUK01LofqKRyqiIX9kIZJYiRNsU5p4CSJQ9UNx+Twwsg2xZ15qk9Pczhxeq6G
ZBitGlsYCwUXxkY/lnmKOc6mipcKLkk9HWSRp3eC66pVXWv+x8sK9KjMOUX1hvVXLNyGFBN9
mYLz0QtB3XQMuLJyp2K6DyYCzCUfUuUzNgRxm9QhMBb5/nc/TPOMXuVLPASGWKr7YnDtaXDR
s1NxX8PCb/xlyOSqV+h/RedsxXZwDoC55VnwkW8bV2eKi1a2YxIw2xcXiVypcs7aEAmmNcy2
YprgInEqJmOYVDFPMDY4T6RbMTsIlvY0aAXn77lgJc5XBtmKuYrfz/vifGUQVVZYwaKK8Sim
zjjMB//JMautfOmrrQRRLhvgbGVMxXR/nK0Mexb1vRf7upGv6eEYx83hQFiEGvKQwxPyr8Pm
MBmbFvfGvU9NpxOPeVn0NZwO6i5MHBaHwOm4sOHgihAQ8wdh6jDzb6RdewBMKphDTD1Oe4fu
wCzF6TFOxGQLphXMqjhphuzA3GG8B7b9JIpMAhLToLsx3oGFxXHLSDI/ARYBw2XlZ0xt7yX2
uc8wXBkTMd8Dn35t/kStfuoQHhI2/ibttrxZ80kSKSRbdxfqfnVZDBkr/4PNqrg/7fwN5ka1
qLP3o+6KeWWrsEH9wS3yO2N93+5GYKUocteN3O+94RSJHxBcTFAW1jND3I4os6O9iF3m7+Zk
OdI07GHcY2rbJwHLuHuWF0nD7ikQ25izo7emCvx7H3DjvzHmxUXSR7/pz3rE/sUak3WKe3nl
cVNcJC1lwFRazCzmwzbWK4eFLK9zmP+WZBp3pj/JB3ujBfDC46bAbwYsNcYGX+szT/C5W2xy
XuB3AEuLu7xlf9j+dRybc5b2nFmJ2SimprfNUJG/HY69TV1vy1+K3obYjfMyxWGcZVuM8zBU
Gj94hulbi2RuRzxpbot9VhXP1nNoZnw9c/9TFVNXSOIdOwnO8JB0p4jewxrzp93D5JQ9TL5w
Sd1v+AG/rL/xr2fqf/zDNVlRW3O3AAAAAElFTkSuQmCC</binary>
 <binary id="_69.png" content-type="image/png">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
B1rMH8+Q7u5VAAAAAElFTkSuQmCC</binary>
 <binary id="_70.png" content-type="image/png">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
O1H2mRsD/gclPh8NcFu+tAAAAABJRU5ErkJggg==</binary>
 <binary id="_71.png" content-type="image/png">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</binary>
 <binary id="_72.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAWIAAABfAQMAAADoAV/+AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUEDzgluW1BUgAAAbxJREFUeJzt1T9Lw0AUAPBHEezWjNlK8CMUJ5FA+wEUR5eC
Dh06ODiIFI1DoIKOLg4iTiK0g0PnBsVOQh3ENTo5BqcOlot3TUlyzV2uD23914O0Ke+Xl3eX
yyv4iOEAXh8AQE6OCA1DPtRtengpmn24Mz1F7XL6TqHPOX2K0ssKvcJp80t1DqPJ6yf0Wbru
lzh9+2v2yUyn63/cB02ULqP0FkrvyLWX1Lty3U3q/Zju56Sa7QM6LCvSpMLpy5huj3yPp7tS
XRfoXkzzdW8L9Ls0t0j3ZJoYAu3JdDwWajfSI+vtC9bbjLSv3CfxZ6nWeyhdQ+kKSpfH1ybm
vSQ0ZqG0L9PJPshrVR9sp+ROamuC2kfpSeb+Nk3mUbkLCn2E0gWMJjVOK+omFir31LRyvZdQ
z7L+M3fVn9eOkS2yPpfR7ExeQA+L2uBvK1vUbIC34039qdWg5wu6K9A3GgWdxWZ11TYAHM02
guuCPjo6aOK5ATCYeB5qVpBI00AE4H6Dnay1GvR+pkBf00KYPGlWdTpLGF5Ii5HOMqz2hVYz
+KF3NKEu6WHpAA+2sf54EeQvC9eEBjqtq2CeAiAdzgd/6HpxYz9cYQAAAABJRU5ErkJg
gg==</binary>
 <binary id="_73.png" content-type="image/png">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
SUVORK5CYII=</binary>
 <binary id="_74.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAVkAAAGbAQMAAABUHHEnAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUEEAAnV4Z4yAAAB0VJREFUeJzt2z9z2zYUAPDkOnj0R+DYj9CRYz9Gx44ZOyI5
Dxn1ATpo7Nixgwc6l0FTTkOGDD6fnGrQkEsoVYlJmSJQ4AEg8B5AkUzqK30hjyfrz0/g0xMe
QULmE9F/ef5kOH5iF/LylX0+9TATXJgVLSu7Zo8dF1wsYrgWq1KtCG+4uIzhg1gVTK605aql
ZcHkSnHRjnkQ86YdHwPcFgYXkTDacD0EV8EHXHPxMoZlkrdstR1l3xgHngr26/ECqrtyeK9x
qTHuopdQ3XuHPzPAsrTlLQ+wbPaDxupbOJt7uMb4nY+h0Q3gexHBOeDrANeAq6DlQu+UcBi6
5SKIWTb+wn3AO/8DblOKr1HqdsLDJHUyyRcIFyfy/C1f934I/vhguD6FacFW5m+vgi2GhDEI
iyH44Vo+jV9DAa4DXMpBUA5tsf68CrDsomoMwi1XIJdhGExKOYIjLGvqDz0iYyzb+KxuKf4d
dX6H9ywyaF624OLbcA44jLkGTGLOYcc4i2FZs7tR7swfDA8aYfstE57whCc84QlPeMITnvCE
J3wK49ONDrxCJzLfPa7NXFMvfDCzWH1bFkMwHxLzcQgeFMYDYTVdP4Kv+xHiqboRhh/X7KxU
F4Yf1+wPWz2w7M/3/fC9GIB1pdz1blnuCj71jlk2fsv64or1TZ3+fa0nHknfGAeeChZhPQNf
DunPRc8wYAZ+3w/rGfi6N9737vzcnyf/T3FtEtIXy5pd/99f9yPEgwq2fYngpsFNNz4ye29P
Xwpx2eBtN751b0vJSyF+4XDSiZ82945nnfiiuce7W/bweSf+0d39uQtz5u6vu/DRu7/rwgfv
ftmF/e/YffMt2O89PO3AS/9B0oHn/oNZB0ZbXpzGfpqDRFN8RI9Ioik+oEck0RTjUiKJphgX
KUk0xUv8MDmJ5/ghTjTFeLsk0QTjNNNEE4zTTBNNME4zTTTBdI+FE03wrwTzn9pxUPwC7WcI
Tii+8B9gfAxaPoXp3s3b8wW4DMK4asdbRjHaoWNMd0H+OBBgunMjnQXjPMBo5LQ4/oP31j57
jjAzK/4pvbBr/p3hAvCaYlbwVB7vErwBfEMwZ0UtD47TaMt12LI8fOS0ZY2rCM7a8D6C06KO
43gY1RBcJgNwkLo14Nc0dWlxjOR5JH1jHHiqboTXsNJKkR1JFSzFN7DSSpHVqgo2gmvBPoRY
RPCHKOZZFBeAr+OVEmm5gn+GC1rOojHLdl5EYmZR/DFMncQ8EoZM8qtono/JaPvGOPBUsAi/
F+wQjrA8UaOVoGOK7s+rSBdV/wpJsKypXLAlDUNWtxqUCZY19Rb+BRPjrLhn4QAk8ZvIcJwV
B1XgIb6J4upbcaETEu43FI6M3bJmZyE+qnWcfWMceFDB6iVyZO4vDqtzsGCaCc4mm+N+h9VJ
ZXg2AadtSYBfitbzlHOK4YQtmGbSU1AXFJdqW+GJGExBPad4Czh+InZFMUTQcj74Ko6DMF42
gfv4H6Zu6TmsnoLS1314eANP0LNj/gxuU4L1jAI97zYn7QnBc//FZjFvnhGst0TnCkxYC4yt
SjE2PWuNsd3+HGMzN7LD+IBftYt5b4mxzRnp0SYqM79gsUU40faTmERbbDePE91kMkF4Tl/G
b50hnJINk6AWPnYm9XHzcdc+dluf+7hJ5M7Hh/B19M7Sxy5jKNFNTDrRBjviJ9p9Ep1og93G
/UR7eUw8PI8B/40zDzfBoUR7IS0cvvOEN83kle/frMG37lld/Hoj3o5h6/B7D792OHHPwm5F
Y38CyJsz91v2sBezNxvv4TJpsAP+VkovDNiKxv7O000zoV27w14T3nweGjQWFqO5UvcATUFt
Guw/66aZUG+tAN/agTERpb17Jri9+1SZZslhrMzVrz6VMGuhNqbXGjaVwWj9iDHLj0zhrBKJ
XBXWl+QAls/v1NGqxvLItMoUTiuey1Xhpb7YR+G9yD6pI+amZZGZlnO5mpbl8ePGtMwF++Jh
5vDKYHn8+M7gGmHu4bnBG4cP6nQxDGOFwvjLhXETwRnCvzl8FcHPEP7B4SZ1aV5CzEnFzysO
eV7AlciQup3I3jvc/g0W4+1ID4Kngv16fFSlbcoqAZybXifXtel1Eu8UrjK1QlnJ0lZ4qbC+
EnmlMPwDEftksDyHqz38p8Gy8y8d5grXrMHiF4f1lcjQn784rE6UZSS2uuXtM1dWlSkrv2WW
F65lvUfSVyJXruXaxCzb2aZNzPzMxJwbrGOuDFaz0d4HzA2+NjFrfGfyXKbRPF9wMXN5vh1R
3xgHnqobF6zsRakZjs9lAVZiprC+EhnwFoa20vXnSpguKuuCuf4sTBeFuVQVhuzPIj9AGBLL
Tp4qrK9EBszVpAzbA2b5vbosV+FVxedmONZXIgOuRfbWjlYsP5hKUdiOg/pKZIvfmIIVDHYd
FucOXzp88zVYpSIzMWeA7SGExRXg2mBZszvRHPbwNDzsgcn68fSNceAhBfsvWBIS0MjT/zcA
AAAASUVORK5CYII=</binary>
 <binary id="_75.png" content-type="image/png">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
AABJRU5ErkJggg==</binary>
 <binary id="_76.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAPYAAADDAQMAAACLa36VAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUEEhkrxrRJlQAABGxJREFUeJzF2L+OFDcYAPBFFOnYR9iSMm1oMsoT5BEoKVEq
FIXERFek5AUibZkyBQWlD12xRRRtnQJ8p0M6RQK8p42Y3XjsL/4747E/28UGsRK3c/M725//
feNhAdlnsZquh8X/78+6up+T0/wSTvPbE100HD6z9w3nn7j9hquGy4aLhrfaP9Vpw8knbr/h
fcN5w09tv+Gq4bLh+nPe8G5V9QFuKs70+hIVp3qAZcXNAKuqs6ZHSyh1Yddf2fXs00PDP1Zc
f+iHaIlj/r5R/u+Ka2Fvy25GhtX6B+3x4435qc2f2RwC9kXXscE/8Ge9/XtfV53dNsYPiuNv
AycuDMzNwjWDwwse6ugrLiBOsXh+kQWnvm1VcB26i52U66fjD9xtUVZ01zRHfQq9R93NPkA0
AFn9rqQsOo+iwNxHThA3hQR11y8RN43e+oIXiJugd/76VaH9y859/1xyX/8zxFlU7yXiFFR3
5q8PZJk5gauL56HcV7dI+2vZhcv7iuROFJmCWWeuooVD3UhHbvc9m4LhifPYlZ/pWf1CET65
yB1Gl5j3CibfJm5aVOt+9N8Tl8YfTk6w+lndJZvaf4zEL+nk68RZ2v9kfCg0x09G85OPvy5E
psSQz5/+dFNi2Sbzb1Pf9jj6fng8c7v3d3dHH+4i8xslPonNX5T4pLtO8kfsauamY2zm9lZw
+8c0SpzuQT+vn8ydJa5g7jxxGXvvhiR4SH0kchE5c7dmLpP6eeIqcQbR/Ps/nuePxOno4cEH
v8XORg8PPvVF7Hz0kPknf+juRu3b+R596e5E/mTm5kLSeP9+aX7+ErtaBSf2l9iXsduRslVv
Qm3Gh2VU/2ATaji62tp0kckP3cw7F8ToZztivnZd7GfeOQxPv7P3Nz4Al2ivvTN9JHKRd8fY
j9H64a4jfoW5ryFaP3a7yeT1aHTqhl8kr1fObd6wS6BHXWzXZB+cIa5bFRW/0eH2NmKuSO5b
092Nc+ky4LDf2l5+/1b7Ru9b+tK5QPzC7Nsnzg9I++ZZSx6F8rj/8K2LHy1PAH68X+7fooPz
rjK+i5XqmDv0HrH5WehJ9/M7YO9vd/QA9sy2K0n+/qaXMoPdh862v77OfNCrCq7v2F/7y1Xm
NpP6Yjzp3rg+vLPk9Xacf+8U9ZvxXENQ1/de2X6p9PXZuI3JuUxfv53T4AJ3Es5bPeZ2Stxt
nvzvh/PpxM8aTlE3oXHhuo84M85Chs3nl48ucRfgV51A3Z45ifnFdFLR3MG7faB1mCvTdaX/
jQlu7tI+KwwdMu/1mVkYs57XL/RJtTd77LAs+ruF8RWExDprX/uvxm0Gzn33AOAnM81X9k7m
z//QW8S4W8M0cUVe6L1rzvM25bhjUeQSXmv5BkJmYIkLUDqmK8A/w6I3Gxyuy34cdEj7ouvl
0aWreuYi37Uz/5f8dSyx8SN5Y08yLuX6r8mZT6klz1JuWv/HNOekTmjNb9IpS7xPU27iIk25
iUuTQCuuiKg6rDd1D6+MuP8Hmv3Y9ZYbh6UAAAAASUVORK5CYII=</binary>
 <binary id="_77.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAOoAAAC/AQMAAADKGdJJAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUEEh4OwvELFQAAA3NJREFUeJzl2M9r01AcAPBIi+4gLeJRWUXLhhfZQUQQzMAh
TooePPYw9OKpMhxs/ji8uXkcgnhU6F+wYzc2D+mYbIi4HidESEd1PcbRQ1qS5pnkpd1L8r7f
dO0Ggt+NFPrp+/19yWslikVZOhauJX8tjNUXU88n3icrIa7KVH00c1XNr5bWlj8XVkNcrFDt
51zhR2176dby+uPtINukQTV1rqDmd0vm8lq4dNv5U9WZAlC5SW1aX7q+NbZ3JfVq/FxyM8gG
pcS7eh+NDEyPZcUZuffGAcTgrGne/z/JMT2PYTap/bK7YjLMFm1K5QzINql1VkTEdCHtVgFy
y72Iese44V4UkL0c0HDWQd5zL0a/vOFezIG4DfIbnA2cKWOJoPwJLx3HXyRZxLrPv+8TlHcy
GDd2HoJtmzgbdOj1W2HlPkfXlGOnA7sIa5RWxOz1XAlbkAnKyC5xQ5RLvbMojzkWbRKuazGs
9c00npWTYj2eka4NPjBkUntgZEFdQtLBZdG9g2MbZ+HjgtslFWoAu8SLmjV0BmErQRcRdiIh
Zn/M9imUadlKY9ycORBxN9I2wVgJ5VSISSgrgmyHl51xZznaMWylDYRN+6mIac8sOJBxnMZZ
XLnSE7cB1ny20nWkbWBSu4EviZPr84EnXYg1Jx02otzpb63lHpFAttyNUAQr90LH2cDZxLkd
4cDet4/KwWcciTA9AivHzPpAfKJdi+HApJNoaYIzF4IV4yOQDmWc91lL3LSZAubSM5Cp+3ez
Ty5NEK5Ihefqh+zXkUmZa1vhub6Y3Tg9xDMJcDFbGZnklJ9Ahz9mv49McnfqdoA3tyS3a4e3
hSDTcJgDcUPI3SYNIds408FYx7nT48HGDbHCXqA5r+Dsh41zMFui7ysAF9mLhlde584aPPt9
btE/L0XsPybs4fQ8UrnztbRKRNydz6os4u63i7KQDz+XkUTcPROdZYc/oDStsQUKc+cHAp3l
FFRaY6OI8HaH2+LSRe+qQOzms+mwDbSdcU59MgGZDsvNBMLUeiFhTPHSeNtuxDA8MJ+BaWEB
TioLHVgSPwxax7jF9grE9m0ZY/YzCMz0/+PzY6Op6en93L1sTsQrar60YuZvqM/UcRFfuPPu
ZnNzVn1wUcjmVGndnJpVr4lLf0MrT1weTSWn6zkpm5PggyhxB/YXkO5iltLYad0AAAAASUVO
RK5CYII=</binary>
 <binary id="_78.png" content-type="image/png">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</binary>
 <binary id="_79.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAYsAAAD0AQMAAABQLZhoAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUEExkkV8k+MwAABThJREFUeJzt2s9rHUUcAPBoBb0Fj70YQYjXJr0+unr07tFD
wJIiXupRCp3cehHqsYrYo/+CIvQbUBRKac452EmhELx0Xwx0E+bNjG9n9+3ufOc7M/tNX1OR
DLR5b2c+b78z3zc7++OtWG45WHkN5OBtNrl/yibCcMkcCCbR1gKTKGvlqyeVtSWXmIJNZsAn
4jwC02foCzswxR/kM6RSn4kAkxhhCyaxMNvjkj+Pj7nkZFVziZvLXJKf/CGBcyHyglwQFplm
lliCnGbmMvFNPgt59NElLnn86U9s8tlTLtmbPHv1ZHrn54+ZJHdcoojmk1lSXBz6lkCy5wpL
IRWfqHMh2VU8JNlVnLgYEXwCfCL5JJdLguTOlQiSG2WCmIJNLPvIb+0Rn5hVNrFTwSb2Lp8k
e0OT5DhHLqtT4xwhqQNAhKRmc4SkvmcRkprNsbsK4lwInAuR/1XyG58kTuKWSO78j0hiJr9e
kliXzryX8IBCnsKbAQnXui9z5O+g8i+KzIqefC9QpX5CkX9kT24BqlQSf0hdnh92ZKbwAFXk
8eKJ6ohS+LBdkjP5mu5IpfBNUUnl0hgjbDQvQC0XejjIARGSWi5SxFhJLRcpoq2klosUUfP+
Cx6p0wI8Us6B5BE5J1RiEgQsuY6niCC2pYmrIhKTILqvH0uUC01wSOXaA4eUjkgOka4yTEyC
gKsME5MgwlWGiYmTdnjDxMSJ9uQosngnxpNFv2E8KdsNcjyR7Y6CxMQJtCRITJyIdgdBYqLE
2LYbQWKiRPstxpD+jRhL+l5DhBwUiJRdSDJCXghEZNcdnJgoge49TkxHbq76RHRtwzWkJdc/
9OoGcxgnpiNbPtG4SUie3/DJ8LWIkG2fDPsMNNnd8LtfDgKSNNkrCo/IQXdKmkjwCQy6U9HE
mjXc5e4ttYiEX0vvOKlHER22yZFgTueJC8osbo/DGFK6hlfbd3IMkS6cBSnHEHBkc+ODd9/c
wImJEOFq3vpu/ZPN6/Qqgolp/k0ur79zZQsnhiZtm8np+tebN3BiaNK+muyvf7G5bVFiaNL0
17x35ZLrvp8YmuDjkERkx862EJHWH9kSkX1rMAFEqjwRqBleRvZ3ryFicDB4Lux/+yMiGhOD
yQ4mChMvMXPyyw+YhKc6gMg9TMITKumTld8n7/tEWlxQxyYznH3Awgt1Tm4HRNSNPIfXkRPh
EzekPtGI4K+lq1cPbNAsTtxf/ZXXGZEmzUHMv8iENGlGtPCITBNXPfXEMDEUcUHcXfPIIDEe
aYdS1NvFoUcUSY6V6jdp61/9Bou6I1od9rWKPHhhYm7JPoYKL0SC7MuvhW1a28WVyKAASR42
m8r2P/CIJMnRoFJOhU9KkqhBCPIZ2kuVIoIkpyRpt6zUZe3I7qwMyxsJ0iRNluQ6TJOmyIPo
DdiQVC1BI9Z/Qkia0SxLIdB+46SpKqf4/LBLTEigDY+4oI6R5sNVcK7rLyVD0n74LLjBhq5O
iHt9RfQ+X0AW+98tcFMRI/HnFJALLF4CIqNNF4kJCIRt27IIeQmBRXPeJwaTxCMX4/19qcBS
j4+AJqknm3JpgUGibUUTkSCKJIm0oNssL9MX4j7doAiKpB/rw5ICk8nGJUUgSarlBJZMyyIx
Psk8CDfLCSz3awsISe53AHIpgUGmdRUSkSEqIJm0UIHlf8sZkPRsqYtwzyygJ9kfwdSNze3B
k5GR5UH//CU3W+pS5/rx8YBAltShvygHZFw5ud+TEWmpu+F635IRaTHWz8ts++rlb/74fOPe
o/iLnvwL2i+Wvb20EIEAAAAASUVORK5CYII=</binary>
 <binary id="_80.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAXQAAACgAQMAAAAmdQWdAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUFBg0Fl1//xgAABV1JREFUeJztmb2OJDUQgGd1wRIgzSP0I/AABP0IPMKFhGx2
oQOCDScko0NCLiNB8qELNlweAMkzGtAIcXc9y8C6e9120Xb7p6rbHjESkLCl02llfy6Xy1V2
jXsFF8lx9V/ypgzyHL+9LuHdVY5v+hJ/MCzDs6JBjTeI8CPNCjwDseR1XNZcRk3tklfgtfxN
XhZ57TozfHsRb+oiv1EZXvMCr+CLHK+KvGmzPCvyIsc/lXhtmhzfF9drPsv4p7xfeX9eur9n
4ofl+DPxWWfjk5mCfqjgkyWvml4U7DkMr5a83F6X/NldZfzfBq8tRDlnzHnhOnIiw1lDeB60
LMSayRY8K55YAvzWYN4AlDaA+zGE16FnKczbRHgVZl6Im1nOedeQ3QAd1WG+jYPmouIgzIvY
NRcZjcI8j1rmMhnJZjyLWuYioj7EGzRqJjyOQrzGfVRYtArxCs9NxM8sKe89mdkAnRQiviXD
sKg0LPHGG6L4gpfJrMQPtddSL/hgIsvxplrwfmbrusR3az9uyQcLBeaPFR2HhCW7EO9bzaIm
iCEiEb/ZhdY5L2MIqsR3N/vQ+nZbE/6jT8NfelsH/gDR7FN1j/EB7qJh1V3gRYqbDk6YP6Ud
N6ACz1Pc9DRn2pRyGnTgWdIiac4IQOs1WZ7kjCD+vFl5y5o4a2tvkyT8ZFDP68CLwNsrmGNe
ZXgNPFi5FgPlZYqHAX4M/DeBX4knwrM/Ij/2RP6rYeWlkiSH2e+Jl4n/LumnPH/M8q+S/Y/U
/g+Jfwy8CfXQOL/oKf8++adP/iT+J3zO/3h/2/n+xniQke/qMaJTK+Zbwvt4ODTJJ4rGm0zx
meKtaZPNmsbzb/AL6pl4w/bmZWh9YiRffoKvw5+GnSa+h3dXMV9ks8E8X7G4nM1m4iXcI/9s
8XKByWTqkU18O/JxVQLT49pReGh/njSwSYvkhNcj3855NvLRicSacVqZTPX8iK4jN7sgJd4A
z2sw62jH7AJuR17PeOV4EQwgIvD54nkJw7p0f3EcT54fyU3pfnSByykvnIbs/WvIryDCZ+93
TX4FeZ67FWXrB+V4SXk26WYAGffbfyrLc28Alqnk1YQ3uNRbuD/VtohPpd7C/a6FYX6H0YX7
XTPH/JYhUwTBjVcjZnxaKie89nxL+ODKUYtihFeel5T36x+D7kjND6zC/C74d+3mwtJ6XmN+
74cP124tWITnDeX92fkC4A3mDbOrd6fX1Nw5/hDc9SXAD1j77tZiH9fjf9+/sA2365Hffh7u
211X3WK+6ayVYMuPtwOE87DahPDo7/a4uDLuuWOqN+6tRYM9bwc4PXhgqElxqJ3ZU73BxzNt
Os8V6FDvGDB4ucrt9nS/MGuVuy/G46JOCjnlha83TMiEmxW6rhTlJTTCJ2tM49er1jBGFCJe
tEteAOMRmPH2OYL3U75aZbbeEAYQj9Nleh5hf468cvezqzdEh3jyntC65xH23vEvla8HULkg
DXkPmZ5H+N7yxtnzYPkPidcz3k7HrX7t+Nbpf5f4gbyHyCdm/bm3/nHvJ+2D9c+vRf19nfxf
R3/+jPVjf6J4MOFknO8v5qfwaD3fusxx8UMVRjH+uLLx6Y6o3sYnuZ7o8cMGp8RmK7c9Bvrj
qoc+KSTxDI1N3cFGPty7nvpwXBl0xNb0NN+6bFtZ8sHl1JvK5WME7vZQkPCrxuZ7sqGrSnz+
vfSMPPPP/DP//+Gry/jj7jK+zX5PKUuT+55yRrLfU8qSfz8/y2fe58uSf8//J/n7zHt4WRR8
eyGf+/5yjq8u4vWF+jVU/6o/L40HyH5POSP8svgc6foi/jDARXz3wvN/AbdWbgbbkOmiAAAA
AElFTkSuQmCC</binary>
 <binary id="_81.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMQAAACuAQMAAABTBzAUAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUFDwAaoCi38QAAAzRJREFUeJy1179u00AYAPBIHTrmARj8ACyMTL0H4CF4ANiY
y7F17MDAhDLyAB06VMiJKpEBIY9IjcQFFdGhCk4bKXawfR/3z/ad7/uoFMFV8l37y52/+5+O
gEjr0cNSjwFGDJPrO1jCDBMhIQHJEGHwVD2zWCTAB5VtUBE6jlgagFznSSSVkxtEJoXOd4hw
I13cnqRGYD6UDQgrZSTSSRudJ8zJd9MxvzVwIpN5ICvXH5WWM0rsNHXyy46bSW/GvggOaSeH
gaTAwU+dpFkNuPDljJLiiKEiVT8zVBo12BtUKvXToFIokajkugbHRGhJMWGUSLPgBCI7Uubd
8h0Ko2QNlIwpKYGSuZO4P+YvWE8ld6IWiQjEjn6jP8HzQCpTMrMwkMJJA8sfRSD2c3ruru5D
sW/NlV1tQ7HBZso+DcQErVzAt1UgbmFwJdnLIDbbnVrXOgujvjCFjZaLcAzeuQCUnITjNjYF
BtH+kXqDmTAiOdB5g0htWqsQKZnOCxhMnJK1yXNE7H4SMFggSnJSbJ6Cd7pEUqCiI96R4l0K
AwkPhEA2iNh5bVJKakbJGhG7FkpSsNacJLHc2rchcml/Q2T6kExicefulEE54th7JnO1TE8C
sVeY5FXN20srkAbqazALuZdT81TbW8eQ+WKDKuw83fmStpJCe6YEkrvCxBOb8nsudH4Ty85K
GUtlxYxfIFkr15Fs3apXIzEUV0eNHQ+l2yklSwI57/fd7IASOQrkot/fcvTEl+P+QhvIa/8S
9FuTwDa4NDA9pKSpcKmAek8BfWyh5KQI8E8yX1LwzytfOCV122IkG1Ly7jGUhJIaKLmkxJ0f
RSzuiyMijJJ2KGPZkVKQkpMiSElJ4dC2euTKwQlr5KOrH5yWRo5DqXp59lb4UvTy+LMvsht8
AS8WgTynpD/ChVyc+1ImvXw582Nb96I6EEjfmuo092TZQrR6L0nJSElJgf8k4p/KISWSFLrO
X+RkD5nvITd7yJJTkiSEyGX8n6tNu9NHhGz5ipAVbAm5hYrjspANIV+bJiWklJQ0e0hFCxXB
YkdFTfd0Bb8Bly38JKRi7wmpp68IAZZRor7BtfIH1l9cNBdzld4AAAAASUVORK5CYII=</binary>
 <binary id="_82.png" content-type="image/png">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</binary>
 <binary id="img_0.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAHsAAAAcBAMAAACzGN2uAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUFCRwB
yLdf8gAAAUFJREFUeJy1k9FtAyEMQNnAo2aETBB1hI7QBdpmgKbKbyu1vQHyEX8lVe6oazA2
oN6RpNEZAcb2E9iAo1sEnal+m5TXFvBh2tBV+OmPMiYPlao4T7uwYqF+P8U6+lnn1bPhiESP
PMU2bCsGs4bUF75NxrmviIAVIH8/sTlHfXd5+W44cF+oQssJnJ2HYnlU3DklZfChBsCpcsM4
ahTGCogBq90L3HJlCeVA1Cg0c4GjQhYmMyCEYoQxOdHMDbw4PBDEscBdMtT40vCFlSq35DwW
5oPi0btSxd+l1CXtkL4djy9OzKy/VXh8BUEb1gUe80SrKD8pMTP3UuE7vc++o1EJUfZoefsn
waWu575MitIvg/ZlnFyU102/RvEU9WlH8fvqw14n6a/8F6dLcWj4Zt+9GXAex6ZzbrxVuflz
b8qt+C/ePFIIdIgSFAAAAABJRU5ErkJggg==</binary>
 <binary id="_83.png" content-type="image/png">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
+B+n/07fCPl6JAAAAABJRU5ErkJggg==</binary>
 <binary id="_84.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAPAAAACnAQMAAAAVEEOeAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUFDy4X1Z7CYAAAA7dJREFUeJzt10FvHDUUAOAgDjn2yKFUufaCuHUlVDon4Cfk
Ro+5EKqqhwglqW/NjT/QhpU49JA2oCqqFhRlvVJUcUAhBw4IaNaVKnWF0MZBG+osHvthz9jj
mfXz0IpblU3kmfW363l+9ni8c9D6mnsN3rjQyiu9NtaTFXsYzON858+CswnOnxWsSY7z8tiy
AiAoXxovmVICUJTXh7yNP/ySmVL89QPDWB9AwYrjfFy0ynPGUV4oDvwfnN3rv1he/x8sBEUj
9/y8lZNZeyVWZkhbOCd5G8vupK1xMbjAWphraEsL0yBamGrbtyQTbWdjinXxl2RlkSRZWqZJ
FpZZkrllnmRmWSSZWpZJJpZVirX/x1mVRhIsS6Yov2Nj1vDEzFX9HpllPbI91vA95aAOIlbc
5kvDKhEgf4saL+ewLjou4mvLImRddBxlG7UuOo6ycgwEYcVtsk1oJgbJItYLouANM3B5Fqel
GGjtT2JmngXK1LNEmXhWGOtmMcsqCEFYBqYIi8AMYR6YI8wCIzkvL6hDGDNMAquYdVQ2B7QG
ZUuzkykwjVjUmUXM68wjZnUWEdM6y4iLYOEkC91oPN7Lw1kW3tVZNbhoq86yyXSGO47LEOCo
ydptS/yz4o92PmlyPt/kZzPsv+3eD0iDfcR+UbPpCbx/QpqN59l+YH31pv/chqt59yqpeAqu
FrKpO7kL3YoFjPyl/cXNKlcx97d02BQxEBUzn/LwgKYgK6Z+wOqsAnevuSAmL1h5tjbdrpgM
bzuWPzm+Pfkm8D0/QyebbllaG30a+KHnv7uO15d04K2K3bZGq8U2hvU63/d8ylxo650aL/u7
Y+x3Pas3Qr/7l11axJMFxzc/Ue1Zk2jOs6oKGzEdqmrj7bqjiaqqDis+gwV31vVb6ClkYSpW
Z8/8Jt70+nU2/+d8zm8s6+77dvUlkF/HWA3Nz0s1pFx2MZb3zJ0rDygXFGF98aEY6IvblPNY
YU7tbAlQO9v0LZx7W2Kgeo8T385X7o8gX3mcJRoXy2bHK1YJHlr+8jKD/OUH4dHaYNmxC1RH
x1Tyrl3edlWCiyaxdktO1J/zm8pX1gjA6ZTA4elZzPrbLyjA8YQyfjwhEavhLcNPR5Sxp6OY
z4Y7/fmToyXKfj5aQr791QMK483F/ts/bi4i3H/Qnx/vLVL2+x7KdzN4vtfJDF+JWe71CPDd
G4T1dj+POya/+9rszB59DLDz6COEqbm9fqXFL9v4Tpr7hZnKI1sAkzEf2nI/qvecglfifwEK
1OFZV3u+GAAAAABJRU5ErkJggg==</binary>
 <binary id="_85.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAXcAAABWAQMAAAAOiUSaAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUGBRYVMy01jwAAAgxJREFUeJzt1zFOYzEQANBoG0qOwDEoc4Q9wh4BbUVBYe0J
cgCKLbekpAiSQRSUOQCLjBSJFULks4q0DjHfw3j848yfCWSDFikrYk3l/zJ/vr8nTjqw0oid
9/annWZ0y+RsZp7raTbzqeMAMCxFM0yKCCmaUQMEiun/72twE7CR+yFGhCH3vQA2wC/0j+C8
sU/cX2FEuOJ+P0A3gMv5wdgp9zX5mntP+W32WIz0dxGC9p+zx2L+CO8jjLXfLfWMuA+Uv1VP
RX6/+GvDvNf1O+Fb63mv/XHxE3APYv3PaP3Pud8KsBOgt4b7Z838pt+X+An5CfcVmLHor4r8
Dnpvkvd8/w/wI6K/BsnHqngw7fzY03fcHxU/hUX+xyIPX5r+0v4wwiX3e+RtyR/F8/Yj9JmP
Vcmf66+1/8b9lnjeYJTX60k+r/8D9xcYL67/uu2fNfObfl/W7yadj61+PyffOt+3Qzrim37H
xvHc98k70S8m72fsbcRjcZ6iH4j93A2QPCa6Ff3lyXtxnrr8+wH9jejf7IPweIvv2Y/+1ldv
8DV5+f0g67dUf+N/gx1q32v72A1x0+9L/ar9DiuN9/8/8hF9VakLPatoLB6/UOTYc3KmTvvk
bf4kqJvfqhLDhZ35/oHyN9ofF3+i/Uh7+1r+f+Dn9fzclRfhq5Mz9cC8sp5G+/l6Lni/qVhR
Ir3fZ6o8qV6NAUs8AAAAAElFTkSuQmCC</binary>
 <binary id="_86.png" content-type="image/png">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</binary>
 <binary id="img_1.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMYAAAAgBAMAAAC7qBrxAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUGCSMC
G9WLmgAAAiNJREFUeJzNlb1OI0EMx6ehOIHkV7pH4AUQTwB37VVUJ6VBPAL0cAr9cccDXKTQ
ID6adAhEgSsugixmbM96PjYbNohEzMIo+/eMfzP2eNbR4pvrPPLRSVvtqr+H8fJ1yP2Prvrc
jMr7OdvgXzcN2xR9MmpjQDvjiSeuPEy1TdP7fmc5Ax1wZ5ojV/DuuTvYsQEuHWA6+3Di5q/P
U84AQsI4yb9gwTjhbvwlvIE8VK/VdPXEbUB0kTFYhsQphoFJ25X+ez/YCXTEmFKd3YTFXREd
ZgwoGNDMzDfpz9dsFZQyEj3M/E+03WA4zonTLcgifWj9mqDS2OvUypmvjBF1tAHVJjvnh/9E
96lCRGXICYAYdbIjdzSdEXWwAZN9RrLPmsFJxuBVNqzbsbzo3Mlp9nrb+9nr5XpkjIf8ipAy
KGGgeAH0m8tidZcjbR9Rj7HCB40VGAPELWONgen52pF+L2VgZCQ6KOFRjm6ItuZc/HmOgEGN
vATbu5zdcV3PhlZGqgfTJf3WGgj50DL3/+j08f6Bqx7iTTPg7le9aK5lSa8yUj2Y/tFWYEDz
TmxUnza+SyZ8v9JzHRiroUIX0590ckcG34nX/OPl+LRkFLqY+pS0ktFy91Yjqtb1YzQqFlPo
Yqqym3ju76AL063cCp2asejO6NxwGYwy3gtgNNp8jNav8YzP9CfcR+vg2V7mYrQU6AzD52S8
L+UflI8PZLQilsB4w8krax1rAt+cQMgAAAAASUVORK5CYII=</binary>
 <binary id="img_2.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAGsAAAAcBAMAAACUtlxGAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUGCSMU
7wE+ywAAARNJREFUeJy1k/1Nw0AMxb3BG5URGKEjMAIjdIKqCxQ6Av4LKtJg7tm5DyEuTSLF
URTL934+n88R22Iqy3SX6p5WYK/V/S6YiAnmqJ8jVVCqho+MqanOYsPZVUbR/dxg8zXerq5y
8fiSMdjsXmafrppyPxeMgeRKyjhKMpiCT/pAIFEMptwoLaEH0rVY0IyoWIRz0zOm7nm6Uqzy
JJEnFhn5i8UiWF1bZAo2mOFfTNvWqD+skLt81XbDniYM0UvRWogH0uGUb1wA4tpsPATGu+cE
MB9ajLMj3tB0xRpDInY/Lp5JH66p+OG6YZS1GeXH9pYd2PsKrFjoV2O2COuM+D679VYfYL2/
dx+s99Pvc7aebcV+AQveaMhDyHqMAAAAAElFTkSuQmCC</binary>
 <binary id="_88.png" content-type="image/png">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
rkJggg==</binary>
 <binary id="_89.png" content-type="image/png">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
AABJRU5ErkJggg==</binary>
 <binary id="_90.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAbcAAAB1AQMAAAD3Dj2jAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUGDgoiYbIiPAAABG5JREFUeJy12TFz5DQUAGDPMEzKa+nyE6CjY4dfwM9JddFA
CjryE1JQ3E+4gmEEkyJlWhp4MFdsBcpeGLR7siTk955kWSvZzi4oye5I9vf81vss7yqdP6m5
7my3EMF9VHe9v5x1u15U3bNXs+7R31XdY5BzTU7ijk56O+vEJO7ohHdzLGw8nOKsn+STnEM6
6/K4EydnnPH3VWf9HwvuxzyfzP2z4F433F//i9POFs45cq3X178mZwpHcWwoo7oz1/h4srsq
nHmU6KDh9FfD/sa/Kt4/83bY3/nbRr3oz8mJ0j2Qa9WZvsLX4Uz1eO26Juf6i6Ku2TWvP3Ih
rpk6e4/jMBnPmvkOnzZeF45el5qM547yhzCTTBzVi99NxrNmKf9tOOLEcfu7+7TuuP3SQdUp
3ciTG0B9PgPdOC/cJBTnZaUTDSf1wvwJxfsXx/XC/AnVeXDJ2YZz4W0X864xD+qFeQka89K8
0w1ncMu8y+Imp8PP3I1TBZfFXe2g4RTKeZfFTQ6Cmis0iXu83ImGk2F0rkDFdCJJTgQ3U2hu
yCiLu9b1DeeGd2KmQO0muPfHzqKTTWceg7sd4651+slDL46dQQdt5y/gJosbncbfdqEpv+9E
Fnetg/hbOBXprBvjRgeI2oUm4y5V1y400XBylRvziU6gaxaao5TGuFPXLDTbcEO8FW7Mh51l
JxvOkBvjFg4aLm4rnVnpUj7sNP+1Ck2xS3EL1yo08HWnVrqUDztg0ypQme2TO8ljrUITZ7qU
DzvBrlGgOAx5XHI4rmOA42bPdSkfcjY5WXUmuhSXnEkOqm7cdKqL+ZDT6aFeoCq5GJecmuKj
BtOHE1zMhxwkUi9QOd0pOZmG6oUmznYxH3IiuWqBxi8CWVx0NK7H0EWz57uYDzqbOVlxZnQx
LjqTOai4fMupTmZOZ1trBaoyB5lTmasVGhw9vtypzEEmagUqM6czJ7ORWqGJ05zLszXJOf7Y
taUBJwrWs6Ovo3Yf3c/f0OZPNvj85U3hbj7Gp/1nGNB+e8Fu0+P4Mwfk7pilOHA6d9TdkXN+
8n3alaVt02Wksq7rbJoGDI0Xpf3Mgfj7O3ddZ9LMiKfSlCXKH2cdn0rF3S5+fBTpLjEtUZXu
DDbvdmq8gwkfP1BmDShQXHfj7rKT/Ub5cd2Nu66DfmMw3j3dxambOQN056d1t9Bl54Dcn+Qc
FE6zo/Uz7gZn2f1Kzv5XTuGOcd1NqOgWXp9Qb8iZjRi7w/G25GBDx9uWx3uLeboPktwP0Wly
v0lypnDbK3JX6LgbnGEnyZliXUQ+aTovr/A6lU+GnNrhjs5f4rjahfHDYbyYpNb0votr6hrl
t9v3oV401ws5XzhQ32OduQ9fUPcNOe3fUV07HNd+W9T1TwIGx+tuQF28jpauB+kr19Fh+foT
FFdnXZwnNsMAr8/3frJONqyS0zxxR3kc4jzxwnmpp+X24B7e4Xh/Tcfh7thuH/Bpz/9/uHxg
t7+k7V/TU+ym9kTx4v87fseu+xeao2BrI5qMsgAAAABJRU5ErkJggg==</binary>
 <binary id="_91.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAaEAAAHbAQMAAABY37cmAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUGDg42HwQzRQAADV9JREFUeJztnL+PJEcVx8e6YBOLS0FYdEDgFMvBGXHQIeH9
CStEsOGCjHRG+K7WOsmXWB4hBwQOOnRoWQ4WyeDeYxETwQYEJ2s5eu22vULr9ezcemd6rrur
6Orp+vHqvequGRAJW6ebqZqpT3dtfevHm1dVPRIbhL3Rf5vKNqGK5zahTjnbgMpEugGV+v+w
HoqJ6UbUYn2KC1H+r6haTDai9jei7tZhVG3lq8VuIFVym7oTWEJIvRhILRKm4+E1v9gFVGDb
WIwNFd6i7Hs1bT6w9QIqCe0p5ZtW4mbzL4yyap6/VJ2GUXbbqO7fuAyj7FAIsVyfmjW3W5/K
mz+NrU1Nmv/x2tRYSMnWpaLm/9G6FI+bF59gXqpizYtPMC9VyBefYF5q1t5wXSqXLz7BvNSk
fY3XpMbta7ImFbWvHsF8VCuXVzAf1crlFcxHFas3j2A+atbdcj0qX715BPNRk+49Xosad+9J
OFUruaRgXW0OU0sllxSsTIPvpW9wKSi7yEMV5rYitIS1kksKRlW+h8pVtGHCSzjR8XgNaqzj
STBVaLkawQoWSBm5PD2Mpqz2QPYwmipMlOxhNDUzUbKH0VRuomQPo6mJFY+DqbEVT4KpyIpT
QyJJWXLRgpEU6L6UYJ4WZQVKMJKa2QlKMJLK7URwr5yAVBxIjUEqCaQikCIEoyggFykYRTmj
LSEYRRUwSQhGUTOYJASjqBwmCcEoauKk4yBq7KSTICpy0lgwgnLkogQjKDQ5YsEIqnA/wIIR
1Mz9AAtGULn7ARaMoFy5CMEIypWLEAxTZYSovw5TBSqP+HyYumCIuhimTgjK/YigYkShjzB1
gCBxMUw9wlQVDVAXWw8xJSInl0sdLd3ryvCW0+dcKkW9S4bc+XHvUE1DZQQ1dRwJDlWRRqTI
HFeHQ9W01zAV0IXjUCVnlHtiiBIkxQQHaYdacNIVwi4HqIRyu7CzAWqbpLIBKtuEqmnquJcq
65SsjdN+yqdXP7VR2/C0qIF2yOnWO+2jpk1P4ci91sxMp3IOYx6q+WEXVbE7yzU/2x6JQzBH
OPcq8jxBrrxUvH37Jf+9pmJWRUcEFR0WfVQuZ2FENWNJxXqoiZyFXYo1SAP6qbGchR2KtzN1
1ENFcsBxqDqVM/XYS03kYMiZMzEXca6+I6mVqRELN8iZGlwKUq2pkSBKztTAnoBUOylis+mm
cGwXSOWydO+5EL8lKealJlmT51WXqn7dvHwZe6lx03CXyGwqZMNNIi8VNaWfILNp1lRHxWzj
BVCNJFtVjMymvKmlQ2AoAaqRq7iBBWvyj2IgGKC62k0catyV00N1X7iCRfYlMfXz1dspA9B8
VWLbsAXU1urtKaQ6E4m/SFO886w7VtsJvGYgpUykBzRVdVe7iEjqBk0VXW7HbHrDeXepGJa0
C+rvsYw5Q/GRNjkf7sU6w0mkrnFRbGFqKV5W0S+ZETr5TF2h2ikwtXhOt8+ZGaY4M13g21sM
UV/xHX0BM/HU1iy5s0wR9a54R0WnZmoszfjOM54hal8cG0rfoBSJukGdil1E7V6eq2hmbrAQ
24mimHgfUdvlFUVxPVGX7Oa+SzWm0FxR6VJT04op6hnPHiMqmxjqSs/pU3Mvmtp/qqlzmooJ
6q65V05TgqB2DHVu/q7aohiixPYdU4c5RZX3ElSH4s6LX2jKqnlD1fcyTL0vzgyl28biTP+J
9R9i3DY8LepUU2Q7/ETc0jcwrbe2rJPdOkXU169oe7I0P/0r65f5B+2kCKnLSWKyfqqiRWwm
yb+9IBBVva6/FpH+fjZ5M9ZxPa1YY5Q1Sp5w1tp7kcgLFulFiIigQIilTLw1rMbiifutj1q5
r1vDaiLQSriPOhJ3RGdY5Xh12kedtupNpfE0wy4YH3Up7javmZzqivASLlsqlaNtxYKpqqV2
5UzN42CKS6uE32yVig5Dqc7oaId+7JLxUonQAHb/eKnVXBTJF+Rq8lPtz46VrYvcWn6qVXZl
mSAXmp9amvx4LctLVaZs2HnhpVorsauHKJgSP2rIrs6RYH7qHWN4BPi+VHhkjJwA35dFFYpi
wdReQ3UlRE40P3VgfF4Bvi8VmmKpv2fQ92VCdfs5NQLzId+XFV7mP1XRId+XFd66kajogO/L
Dh9WmYoO+L7ssKPNpiGfgx22hZqGh/wbVuBZoqfcNag009M7K3s9MFao09RQ/X4bm2LvGarf
RwSo32kzky3CqX1zr3Aq3ohKdw01DaV4umP0Cq4Nnmkjcg2Vm1aoW9Qa7fBDrltvr+8Lhn/8
MlHRhePZ6qFOzTa1pfPLu4cqzODJbzPwVQ9lbzFz5vM+yh+uqWvqmrqmrqlr6pq6pq6pa+qa
uqauqf8Patmb9FFvRn1JD8XZaU/SR9WwTDVx5IygSujaKbF7nqIW8CjAwvEPhVFT4jwBQU3h
Tp0psXFnmMrCqKxiqT/ppUq9RNklg6gFpBZeamLly+Zgt1OTtKjFwqL2Lb9n9g2sDZCclh5q
+hTWBkgC6leWt7RXr3/+2KJevQuyMeFLPvmjRd21KNQOAVV7KNTm7aSXWsKusQTdDZTw91Yd
XjCwSsbBUsDXv7Eoe59dnsAtJtHbzCRAzWeZ+WLibHs9YVYatA07bLSXGK+54F1MmCI2p6Kh
DVPEuaiAlUe8boXHbEzhNTK8+RtTeD0Ob/7GFF77w7uYMIXlwoJhKiIoVzBEkXuJXcEQRR1j
Q4IhipALC4YoQi4sGKIIubBgiKLkQoIhipILCYaoiKQcwVyKlAsJ5lKkXEgwlyLlQoJBKqPl
agXz7u5rqoqUqxXso5570XJJwWy7yKVouWQp7PVAl4o81BGofIfyyNWe6fRTHrmkYD2URy4p
mJ8ae+SSgtknGpy24ZHL7WEO5ZPL6WEO5ZPL6WEOFXkp0MMg5ZXL6WGQ8srl9DBIeeVyehik
vHI5QyKkvHI5gkHKLxcUzGlRPVTipaIeyhYMUD1yCX+v7JELCgaoHrmgYIDqkQsKBqgeuYT/
NEGfXEAwQPXJBQQDVNRLWYLZVK9cQDCb6pULCGZTvXIBwWyqVy4gmE31ygUEs6l+uWzBbKpf
Llswm4oGKCOYRQ3IZQtmUQNy2YJZ1IBctmAW9cEQZfb6WNQDKqcd+B2C2iKz2kFvRjAUH6aI
3en8Bp3VBJPDUJX3eTs6UFQ0SOnjkJoavcYGqdnJFqQq8dtBSBTJElLlUO+SgTMOqVPCL4Yp
5UhQ1BHhF0OhVq4ORWUhlD71pih3p1AgtQigFqLbDaeoeEoe/XSpGFLsXyEUTx3qixCqdkrI
zjeingRRTgnT45A6VGcb/zO9NmsbQRRqh+7OLjI4bV7uYKefE2OFiTkR2VJN/JEcFOJe6iNR
JcXqRKS619svvDJ0r1IsP30YmXs1VJRX5HNiAHUp93ZbVDN3cfI5MYA6lX+cRcm5KxqgFnKy
zG1Kzl3jAWoqJ+aZTUlTYzJAHcs6Lqyab0815gPT+QNpcFTtiUjlWxaDps3KuFlN+R0lTY2w
eTmyKDkLDdoAF+r6HcXlcaxn8QDVnq3bMlT1uvwwGqCOkub6uaEKWanJoB3VtI3ZzFCzphIr
NmizFfKRQYbKRcEeBNiHW0Xc1tmKau6yxwJs0WJrJdiKWv1FYXZvpKlodTHWS3Um21hR3alG
fssHtKE79vYXRamd7r02kdqC/xnrqJPui16rTZ26uViLUhaTPHfYUgddCf0PLxVmC/6FotRp
xoNeKjLvLaVKdoLzmqCqTNZKQ53cVDZe8ZrXRuQj3XJujuKGSi5j9dWO99mFM/F9Ff2zOGqo
XzzP1AeJd5qdml8Ol3t390b8aKGzMu9TCDOzW3/O3t0b1ak+AMn9TyFMjXfuXJzvjUrGLcr3
YEu21LPisZjvjebiJ1mXrv2P3mRXmnosnu2NrkS6PUhxeXCvC/sX5aihmNp3XYrEMztzMdHU
++f1aHReWdS2l5o6VMnUEc2SZyFULqmFRcUh1LShruamhD33ygx1KqlvxHaXrnnsrUND7X/S
1OH8KdNUj14W9aTR65ngmb6it23cT03bOJzLFlWnw9THDLbDOrlkuhzeR6XabV40bZ7/7Fv6
u7THt6x7Q/l807/Ex+Z38JFzTNqEd4xpVl3KvnxoPLkXn/rmsNs/MPHn5bhhTwpRTj2aSn5o
dddLtIIwoyzZJ+7iDV53INpU3b/uIOewbyhqYI2Dx0Y9ixpYTxGRGed0KIfWbsSYoBaD60QT
gjofXJPKCUvg0eD612ZrbZut6222hrjZeuVma6MbrsNutua72fryLEXUV+4HmCKe94UeeoUp
wlcUcIqWoN5wPyBKiAe3AIrwtyE7CVPYIsVDK0EdHkQgffC9OIC6jOG+r/hzFkAVB9+1k9XB
D1EWgipT8Oy3MkaPgqOoOQOPI5mLOcpCUFeitKlzmPRR58s6tZJnMOmjzmpuZzuug6jjElB/
h0kv9ex+ZiUfP7sfQj1eQmoZRpWQKoOoY5gtkDqbwzqcB9XG+fyene0MJn3UlXyCiHURUTI3
C9UOYbbAdljGX8Lk1yFU/afv9CR9FL+3gMmgPZziIRxdwvaLhjyV9N979NmV6lA7sQAAAABJ
RU5ErkJggg==</binary>
 <binary id="_92.png" content-type="image/png">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</binary>
 <binary id="_93.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAdEAAABHAQMAAABiRe8yAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUGDjIJ2pFnhwAAAfhJREFUeJztlq9Pw0AUxy8g1iyILkHUdXOAIRXTS0qCmIHs
T6ASgUS2ogzEliHmlwkSHBKB2MRSJAINlcgV1S3bWu5Hm8H1+oMeyxA78e7S+37uvXvXdy3w
czcDIPuJxx1k5nqsVkZmgofPG3bD8rE2B/vCwb5ysG8c7DsHa9dysEOAm2znYENmzMG6HOyU
g/XW5Jdnv8l5dgBgsOH59qKsAQrJbOhez8+y3udv7MrqKHf99jjujYu0+8pBRxHL+lHWgPrt
VHbMwdppbMJ+B0w2W6542B/tj/16uFwK2f06pL7WySbtl8n6//67vyp2qIpmRTiSLBH1qthU
THBIYxM4pUlEqkqWIqDeAH3Jqgr44bHSrhO+Q7Nen0is6j3hlfZ5wwBYjEwp6EVTlSN+8RQl
NcCNJsFBGYAtGDacgMferLFYAHY0LMFSBbG3eLV+/ZSsuq92K8IJzU6FhrkXhHV3EEih3+BR
6yyIuCKNmLlSS6HU1CSSqxFKUktDyVNLuG8x9mshCSWFeS6KQRLVbjlY+IFm5ySiYuMqiHwX
YuTdyNc27G/ZBR6n1eAAmUj9kl+oS2Rmg1i2hoyL136i/brL1eP9+pidsdmUmMm8y2S9TOwH
zY6zxEz+TCMx21nYBZt9zMLOdIolh1bAQz2WlZFx8Pz1ks3XjC9Kt2np1y/D8wAAAABJRU5E
rkJggg==</binary>
 <binary id="_94.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAakAAADBAQMAAABPMt2bAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUGDjoH9fDAiAAAB61JREFUeJzt2t+LHEUeAPCJCjFPg3/BeIl3vimLLwEf2oPA
xRfv6fDB0zwEFdEYOGUnENnaM8J6sJC7N8Mh8yDcPch5cEqiBlIriovkYB4ChmRuqY1LHCTu
1sTo1ozVXXX1o6u6qru6tnsOuRebzW5XT326qvtbVV1dkw6fZ1vu/P/ZpDsXO3t7LgbYPCzl
PJmDUc6R2ln7/L6DB87cvv9XCw82YIRzrHa2Px4tji7QxXPXR63YxY8Xr6z/2P/o2lYDhpVU
7Nri5auz/keNSkOsR9xK9s+NnmrC+Emqdj5bX7j/wKHbh/628ItGpWFqE0D8g+UcezPegvV8
1mvIOA0c/qlYxqfzsCmn8R5X20om87Hq3duTqaZ8ozVT/Y3FiguyTLWLrcAnUaYHhawto0mK
IqaOkU/O4DkYZoDMweZsk5BF70cdE4PyHsNyiCkEWrNMMtiaUclQa0YkiwcuxLBk8cCFGJIs
HrgQg5LFAxdiQLJ44AIsN6AlyzSDLRnVDLVkRLNo4AIMaxYNXIAhzaKBCzCoWTRwAQY0iwau
yiwBrVhmGGzFqGGoFSOGxQJXZdiwWOCqDBkWC1yVQcPaPTqAYbHAVZgjQAuWFQy2YLRgqAUj
BYsErsJwwSKBqzBUsEjgKgwWLBK4CgMFiwSuzDwAGrPMZbAxoy5DjRlxWX3gykznnPacczRh
yGX1gSszqFmi/tQHrsyA+p1qVh+4EtvhLuP9huymz/7ekOUT5BTov582ZJ/oPyxnZxqyZZ/t
a8j+6LO1Rmw52a93NvNXlUlaU57LUjDMsw/yxYHpKyzhk4U3jr5+hO07vPbAwsEDSYXd4d8l
eR3zWrLfitZGXz6/cX6bv3T1dy+PFr9EFYblC4DcMtvVIB8LtvP2B9/wE1f7Txx+ddirMGRa
k10cEG2NCrb79L9uSvbQ6A+B0qBpkvYtX03ZbCX7opLXgwzmtc1ZJn9uL/z76F1H2C8PfyVv
SbfCwMSwNCE5W7HjuteLPIaBrgKiiOYXedp2njrGODKMGMaoHfWm8zFv8xg0DBuWNWGXBoa9
rxnJvm/CkGHvmtII2Ju9bdj4dM7SnQalfWrYhJhb0mtQGjKMWMaXQsoP96WzUO1g/E7eSrLv
w2Olx/aZxrWWv5tm027W24vBYA8ILhLs3d/EsBBn2DRXt3eT4Bjrsi0xmui6AXZM7w35uh3Z
69h/RC69DWb5g/QOf5TzlTiDHXPezf35gzTtiAqfAlG2ZHsiKZbHloLzDLeVMMswsbsguKDq
sMxlNi+AezCaOczWDCJxdDy+U8tIwUTnhobJy4wxTF2GzC4JzU4chjyG7e4eDHrMZEbZsGx8
Boq7DjM7A8JsEGWMe2xmWHAwKVgGsMt2813CYJTRQcFEyxjmhZAZijIy9lgC7eEowzPksNQE
jg7iAUCsZ5hohcdN4KYgNKssGOQrDuuZwM2Cs8qCAf6hmbuwTgeYwGXBWaVlTN12uw+c4QhE
mPw4K/ahyRBe8rKM1jMUYXJxK8REFQOBsww7jLolgNDrgGWongUCZxkUKMhgKHCWAZ8V1wND
gTNMLb8ZRlyGQoEzLHPfaMoM1jIaY6iWEfe1C5cS1cAZVs5Zkygz5J7Ty0lC73GGwdLleBda
DZxhIMaqgcuZv0ToMcoDgctZVmZFvSiv/7LJ/wy6zD+jz0icVQKXMxxnlcDlTNYC2IPAvXnB
tcqcwTirBC5nIuOP9thMsoFNHgsETjN5eGpLk+/4054trcergdNMVmKSWCYyppalXV4NnGbU
Z0mFoSCTiwATr5LFN1RMsm9DjD0smT0mr9L5Yqvrfegymaf4Zly9OxXsrKnK5vF7/3LPn9LH
Hl99XLF0f5UNPLYp6s13N05cPDFio+cWz2sm61HMqmY+k9OZiWYbj75whf11Z/GUYmoxZuwz
ZJOyvU57in178dnL7KkdVdp0n7wHa/ary/Ru+XstMenNu+XVL/dsJb9e/FKwMVsQHya2klv6
lqzba5Mv8atgzL86/tafxS359TerRzsdcRXr8gu+1GQbyK/6Ujt7Eg0rkZN9nYa61qI09dyj
RbsDeiwxzVc/TsdOc1aMmSEZ2mx6nMxPk5mB2ZxWVm65k5kHE7LZ9DMgPw1VaeQ3Z8Uyd1Sm
5rGYn8ZWxWd0otiKYeSGZLBrmUqDrtcLBKPyBQGOzDhDdtVM4YI5Dd5V7EKJEaLYRct2FOtb
ptKg7416VSayMZWNxNlETZBWbLYbinVNGt1Q07Vumf3whQgJfO+VfDDEt76Q7JnnDbt1TrLf
j8tsW5b2zxdNabf+IdnTT9r0tmTHniyxHcX6p022DZlewn2b3hDXtrRDSuzzEyLbpUdsttUN
0apfew6bO7kqSuOvPX/SZ5Rvq9baJ2wJJLJJyLNDhrFOY76t2vlJlKZmbU+xNdlK2CFs2JuS
pb+x6bdkq0nXfZY5jVxuDdtkuQeUWU0PKPe3csep9jfFRJfHarTKD5e7KVODHykGjZwheZgV
hxOZnrlpINO0xLbU/enZkWso0wwUaTmSMbBeYnqhdNOOkxO1QrK/SKuV1eWkxCpbT/6K/weT
EGuw/cx+Zo1YkgwGg+FwOB6P74htNpulYtRYEgOJ/4n4YPa/s7kq+V/l8cb6YmeCjwAAAABJ
RU5ErkJggg==</binary>
 <binary id="_95.png" content-type="image/png">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</binary>
 <binary id="img_01.png_0" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAANAAAAAcBAMAAADioCyIAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUHEBIT
HHNTQAAAAdpJREFUeJzdlF1OwzAMx3MDH3VH2BPSXiaOwBG4ALADABqPQ9roKxIP8xOd1nUm
/kiatmGdoJoQrttadf3/NXEaRxcyl8Rrux+K7KuWrpf9VL9iHaNn8Rbothe0zJ7uT+RyD/Za
IiAH7McFhz6gh5yWpL19+BNd+ECLmoquFlVbdgWheLWU0EdPbQTKtbIpu+MLEFhSI644Uk6L
Dkv2FLQrQvI1NyJJe5vnQFyxS0CNFtU37AoC8U8NfbLMgT7tPlE1iKPlqIygrhbRVDwBYfxA
pBfnePIdHyhXSftQdNGmM0bYATVa4YkuBmkbakgUVQjZWEyuhGADQBdmzqIG1NVKQTqt4YQE
BMDaIASM3xknpYmQ3mdXs1lGawCUTB1PgFNBOAGyEZ0DKmMy9F0g4SitbtoHgVSkoEYLePVM
FKRIWZKqsEo6bW1CTkt353Hc0Hz1KoB6WlRfszPILyVpqf+tUH/mxxQkbfKikib5N50Li9Um
WCp2lNFydFiwp3td2GOI7ilj6RZEoS8h6FZELaSqYP/NphpWOIO+3VSxtamabexeb7MgS9dF
NwGZik3MvRF7C/RTO6XhznlpVDsDhMOvjAMax4ZBCIOvjAOifwcaZy38qR6NYxcDfQFSG5pX
zoWcvgAAAABJRU5ErkJggg==</binary>
 <binary id="img_11.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMsAAAAgBAMAAABOVpFBAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUHEBIb
EqjbcgAAAiNJREFUeJzllb1OwzAQx7MgJL78aoxMiDfoI5SxS+kj9BG6MvSDvUXtgtRKQBYk
hg54aqq0icl92Oc0atIhVCBOFv5jn+93/sg1MMcwHZRO3wVoox/GfFzA389urZhX7rehHUlO
QKaNTE3zPr497w5YZwwF0XKYXkGYp1sWcWFKLC4Z6GEjTKCgpSOQmTBDWXDKYkmd+KCR2nxZ
9ywcRFyixNBDbITR2DZTlJmaSDb3Xer71IkPhUW1hUFCKWx9kpDCBJuPWYd24UIw0Rn1berE
x8MkkErHw7QFs8BGGJpckcwWRoJJruk6G/Sv+BhPNS2G8kVnjTEhVJTHaJeDNjP4XDDSTNk0
4f7Ex3hK7WCUbJlG+AngVWqSxrhkweKpxQQ2+cA9T1aCoeQQQ+/Ew3AO2m3Vx4xt3pyjOw5P
qbTVuml1nJeS8yzHuENLu7lb2IOxuzkEE7mFK9nMmvsmrYqKGE1X7mOaFqMg1IoxPAmPlXKY
C+aB+zbdqfgEknHSYQznCw/a5jLHBhj8dBV+ZZo+67GjxCFvaYIPzfPBo4C3p8x2xBioJoCf
4KvCVMbY/JqGhQRt4MaoHjzmi42x98FiE5q8sTOkMsBWUToTVMvzYumUx6j2l06dL51sbza4
K4Uv9LN2mY2FeR9nWaj33THrrCAURDvs1/OqxEWr/XMueAWmLvt3mJKzrxNTh1VjasmjGqOr
HP4Upo4X8HvuphY7FuYbuFLsWWupiB0AAAAASUVORK5CYII=</binary>
 <binary id="img_21.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMUAAAAcBAMAAAAjJ2YkAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUHEBIg
o6MyVgAAAblJREFUeJzdlEtqAkEQhvsGddQcIauAG8/iBfI4QARdRjC4DbhIrUZJ1MrUc2q0
MySgAVMDWtp//V9119CFLh5Yunxp37tVVuxntbq+5jiWkbEuMyYnCcdH3WZS//tkceKMUgrQ
4UkyIHrM+jWximXezqmmi1ZZ1ElrWKcMJAL6nEnW5tNcdc8f0D68oj6uOSRvT6BNxUlrWJcY
25XXLzJjXGewZlvZCDPEyRgLZ8jPxiW0yUU33oOU9DQVhvCb6Ft0iYEpmxc+V1kFr0wMUwuj
8IPy6UoMmuQ+c2eUkg4XwZpBXg9GaISBHOyISDZpNZeaYCgSY4PdwZszRHdJ8za6G43aHLgV
0IZ6J4LDDD0rGGSks2LnYspvGaTTsfomDr6N2zqjcQakx0o2wQDWCUMPmt84hb/k4Y7za1Uo
a7Z2BjaS6IOdbJKswxLT2c14Ypw+e8dsOZVrwFSy89AEQ0aCYK8DO2lNEV26r+QGkHigFOv8
A6iqOYpwQtH97k7ELv3RnYjpTtR4te/9e9bvVzWXvuY43AlElxnnDzW/LIPOycDBxavZB8Lg
6nn28U8YgyO/pnkMd/AXjC+45Ry6RRl+ogAAAABJRU5ErkJggg==</binary>
 <binary id="img_3.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMAAAAAgBAMAAAC2tmq2AAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AUHEBIk
pM72TwAAAfZJREFUeJztlc1OwkAQx3sxJn7tq/kExjfgEfBiwgV9hD6CVw8o3sWUi4kmai8m
mvTAnoAUyrg7szs7tU1RgQOJI8KU+c/8dme2JYINW7RqgdMIrb8xwPuBff+IfwB4cZ/zVAqK
pC4taIod6y5adQkPZcBVxbGW1y8saO5OypG87CLA9FDBoo+eAriV+sz86ygSa/mmyXfZxToZ
a2A2clkaQMEsQc/4Awno2Tdl/mwEQGoWdH0WA0eMrscamCcSME194FkCuvUAq5nS9WSvBOgG
QBE7AOaPyTOBiQS0fKJ9QUnjAMVxwhFFCaQBaEuAFt7QHm3beypL61GyjA4AGJYiij303ZA9
AKfJvVDaAXBkvgxrPCBPOOIBUQQCQAvU3IvQbFcWNyy+Rc1n57zTwW/uOeI3qqG0gyqAWqQa
AbyDRbwcYG3CgTG3lOZUBxgHgO+UU7S9RuPAI26uPaY0/CcGKDym4RBpJTWu8gWw3lrXr8ic
r0sE0AjtXaHpBuSeWvoAb9AwaKEhQJ66bbg6AyCNWcy8L59F+KhAuwFhmbzQUNXQfX9dTTAP
h/S3DzsFFU2BXrZfTVDhYUf26lNGsmaRQo0FzSP94BxWEsxu32B9v2hHlYCm7a4MWGb/ADTV
ENuKHTTWWAdANwW3AtA04+2Ywd/p67AvnEY35AbLvSMAAAAASUVORK5CYII=</binary>
 <binary id="_98.png" content-type="image/png">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
30Mh/v8AVGouwaUDpS8AAAAASUVORK5CYII=</binary>
 <binary id="_991.png" content-type="image/png">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</binary>
 <binary id="_992.jpg" content-type="image/jpeg">/9j/4QDmRXhpZgAASUkqAAgAAAAFABIBAwABAAAAAQAAADEBAgAcAAAASgAAADIBAgAUAAAA
ZgAAABMCAwABAAAAAQAAAGmHBAABAAAAegAAAAAAAABBQ0QgU3lzdGVtcyBEaWdpdGFsIElt
YWdpbmcAMjAxMjowNTowOCAxODoxMDoxNgAFAACQBwAEAAAAMDIyMJCSAgAEAAAAMTI1AAKg
BAABAAAAiAEAAAOgBAABAAAAbQEAAAWgBAABAAAAvAAAAAAAAAACAAEAAgAEAAAAUjk4AAIA
BwAEAAAAMDEwMAAAAAAAAAAA/8AACwgBbQGIAQERAP/bAEMAAwICAgIBAwICAgMDAwMEBwQE
BAQECQYGBQcKCQsLCgkKCgwNEQ4MDBAMCgoPFA8QERITExMLDhUWFRIWERITEv/EAG0AAQAB
BQEBAQAAAAAAAAAAAAAGAQIEBQcIAwkQAAEDAwMCAwQHBAYECQ0BAAIBAwQABQYHERITIQgU
MRUiQVEWI2FxgZHwCRcyMxgkUqGx0QpDWOElNDlCdpbB0/EoNTZFU1ViY3WDlJW11f/aAAgB
AQAAPwD9U6UpXzkCRQjQDUF2/iFN1H7UTZe/y7LXDcp1oz/930nMtK9GAznEkQItqei30oc+
8SHDFpl2Ez5cm1t6um1vMcfaQWgekADjQsE9ObHrZo1fbFEvdj1awq4W243duwRJcPIIzrEi
4mKK3CbMXFEnyFRVGh95d0VEXftsrXqxpZexkLZNScWuPlEt6v8AlLww90vP8PIcuJLt5jqN
9Hf+bzHhy3SsK+a26L49kV3smQau4Xa7hYGG5d2iTb9GZdgMmbQgbwEaK2JE+wKKWyKrzad+
YoulxLVHJ7l4acgzXNdNpVqvuMxzcuOJWW5sXy6tPtw2pJRuLGzayDVzdltDVTbcjmvTJ0mm
8nSrUadmWnNryXMforZZF+uDsG0Q7Zfn5iSDabdJxlRkxIroSm1ZlI5H6XNvy7nNdxIA6M8P
KMQ8RLdPQk3Ra4Nppr7nd8yywtagadWCw2zIslvOGW9+1ZS7c3kuFsKcjxPNOQY4gwSWuWou
AZF7zKK2iEStdGl636L2/R6DqHP1bwyNit0kFEgX16+xgt8t4VNFbakKfTM0Vp1OIkq/Vn/Z
XZI1v0Xhz34krV3C2X4smfDfaO/xhNp6C2js5sk57icdtUN0V7tCqEfFO9ZUzVvSq3O40Fw1
LxWKWaC2WNo9eWA9tI4raAsTcvr+SutbdPffqBtvyStUniG0DXStM6/fdgSY2s/2Ul4XI4qQ
Vl9PqeXR7qcFd6fvcN9+O67bJW1hat6VXLNW8at2peLSrw9Pl2pu3s3hg5Ry4giUqOLSFyV5
kTBXG0TkCEKkibpVY+rGlkzCLJk0PUnFn7Pks8LXZbi1eGDjXKWZmAR47qFxddI23BQAVSVQ
JETdFqUo4C77Luo+qbVza2+Jrw33m4lDtHiA04nSAjPzCajZVDcNGWWydec4i4q8AbAzIvRB
AiXsirW/uGrWlVptFquF01LxWHFv1veu1qffvLDbc+Gyz13ZDJKWzjQM/WEY7iIe8q7d6yrT
qNp9fsphWKx5xYLhcrlaAyCFCi3Jp2RJtxkghMbbElI45EqIjqIoKq7ItavHdb9F8wxW833E
tW8MvdsxyP5u8Tbdfo0li3M8TLqvuAai0HFpxeRKibNn/ZXbf4xl+J5tg8XJ8Nya1X6zTlJI
txtkwJUV9RMgLg6CqJbGBCuy9lFUXvWNK1CwGBrFC07nZvYI2V3OOsuFYnrk0FxlMohqrjcd
S6hgiNOLyQVT6svku2VlWW4rguBSsqzbJbVj9lg8PNXG6TG4sVjmaAPNw1QR3MhFN17qSInd
UqLJ4gtBFzqDi4624Ct6uixkg21MkiLKlLJADjI011ORq6DrZBxReaOCo7oSVs52rWldrz53
FLnqVi0S9MXCJaXbc/eGG5TcyWBHFjk2pckdeASJsFTkaCqii7VqoXiF0DuNoauFu1twOVFf
SWrTzGRxXAcSIyL8pRVD2VGmTB1zb+ACQy2FUWtrO1b0qtg40ty1LxWKmacFxpXrwwCXrn0+
HlNy+v5dZrbp8t+oG38SVlYXqLp9qRiz1808znH8otsaQsR6ZZbm1NYaeQRJWyNoiESQTFVF
V32JF+KVi/va0r/fh+7H95WLfTDfb6P+2GPaX8nrf8X5dT+V9Z/D/B73p3rC1s1Bn6X+EnMN
SbLYod+k4lZ3705bpFxKEL7TAK66KOi06on0hNQTgqESCiqKKpjEIett8k+PCxaHFjGPG+/j
L97yOdFv0h1LPKZWMLkJtFhC3INVnQyTd1p1GnuobbaGyj2g0s191LzbxA2jE8k0qxWzW66r
kgOzoWYvzHmCsdwC3yPqyt7KGrkl4Fb3cH6pCNeJJwLUXDxR5ha9BrVfZem2Kjld+z5/Codh
ayyU42aM3X2U7OJ4LapNsjOUEUjaQeDrO7nXcaYLu2W57gemmPtXzUTOLBi1tkvhCZmXq5Mw
WnXVElRpDcURUlQTJBTvsKqnbfb6taj6evXLHobOdY8b+WxTm4+0NzZUruwDaOG7FTl9cCNk
JqQbogqi+netZbtb9F7xbimWjVvDJzDdoeyA3Y1+jOiFuZdJp6Yqia7RwdAwJ1fcEgJFVFRU
rFXxB6CJjnthdbsBS3rA9q+b+ksTo+U8z5XzHPqbdLzH1PPfj1Pc35dqQfEHoJc7O3cbbrdg
UuI8stG5DGSRHGjWIwj8pENHNl6LJC6539wCQi2Fd6yrbrhovebWU20at4ZOjhZ3ciN2NfYz
gjbWnCadmqqGu0cHAMCdX3BICRVRUVKlVovNov8AjEK92G6RLlbrjHCXDmQ3heYkMmKEDgGK
qJAQqioSLsqKipWZSlKUpSlWODzYUfy++vPg4f4pNMfDtA0s0Ts2l1xi4xBjWjHr7lF+nMue
UY4g2kmExDLk6jAo2RhJESMeojbYr0E5Za9P52B4U54UMavdrTP7hl2PZJaeoT1xjw7BaTih
CuM5pG2CTeNjrbDoNOEBS3mk6kcZTaN9JuPhWnWHKdNXcDv78+y4vHxzHcgst7uDbTNxtdlO
S/b5IutRFd85HlusvIIky08jZNubCW9QOB4ZPEc7okuN5QmnF0dHCo2MADd6mR1eWRPYcyNJ
MjyZG+5dWGEcclqAuMu+6AEROyXOoYbi3iPw/CblemsP02l5ZkWaTLxfWXcnmDFlW0mFZiC1
IGCisyGGmbfH2SOQONxCMlF11VHoGmOD3nTrEYeNE7FubEiRc71drirhRy9ozJhSzGPF4mgs
E5JlbIT3JoQZBVfUicScuipRyFE337KnzSvNOHeFZyX4W9T7HmOGYDiudak/SeHKyfHw9oS1
iXeQ9IFHpBx4zzvSJ8Q4KXEhitL7vLg3V/QfVC2eFmRZcUx3FQyS8Z7Z8vuMe55xdrg0IW+R
AdRDuUph+RJeMbYy2P1DDbYOoPE1Z5Pww/Dj4kr5cre3fLNpvAiwncklmcTLZr75rdMgiXsG
myW2gscgKEMUZTZdVhXvNNIjjANliZV4Rdac68EuPaK3VjFrRFjZhkd5n3GPnV1mSWIdzauI
NKjpRW3Zbza3d1XAecAZAxEFw9pJ9KfZjpHr7l0m65quO4DFyW6XHEhK0llctyEMWxXV659b
ziW9DV543uh0vLoDYj1OZ79KoWfh48Qt8lOYjlmMYVb7Fktqz+wTrvZclenyLUOSS/aISijP
Q46Oiw4wEbiLnJxX0NUARJKyrv4Msiv1rYnyLba4su6e1od4ti6g5DKAW7g1bmTlSLgrgSrm
oBa20WE4kZlwHAb5grHWd9b+VJOACggADxQRFNk+GyfJNt/T+74+IJPh28S+Z4ngzOX6fYra
et7RuN/S351ICTHuE27wshcQiaiAsdpZls8kJR3pDrAzQcFX/LkTki1Uxi3ab4h4e9P5szBI
l9PUubfoVqyG6yJkSRKKHdZHHzUt1yU46sqWw0kxUIhkPMPIyJEEZd3op4Tcm088VE3P7/Mt
M9L1l101DdNu+3MmrZcLhHdjuQGICK3Fe6Yul/wi6KOmHJvyzSkLgarGvCxrGUq73zIyxm3X
Rb/IyiHEZyabeYkyQWTR741GE5EZtbY0iRRjmUVtwX1dR91pTjtgffNJ8MyzG3cwybMo9qi3
rNr8N8k261TDlxYHTt8OCDQSHG2ie5DBF1VVpvZXlDYkDmersemeX2jxe3rI3ImLTcbvd+TL
fNzBceuVvljaWbWkaM3xQG922OosvqKXB16P0dj6ybrxAYdlWonggzrTzCgtZXnKrDLscYrp
LcjRmkktqybhG204ScAMiREBeSig7ii8k8+teG7XmKzqRiLcDAGsT1IxGNh4SnMklHcrG04t
xdlumnkBG5OjJu8lQcccjuvi02r7nWcddW3U+wnqz+0t1U0txC+YC7d73pJbsSuo3CRxu9oh
TJFz8zIY4IZETYPQ3DikLQuq/EInmkAOrpHvBrrFdp4Xe6Dj8ObMu98ud0jxdQrwbG0jILff
ogQ/6sCQzV2EcRx2ODRghDKTrOCjIzHUTws6hZB4Y8AwnD2sYts/Er/dc4CVKyC4yvIXwmLg
7bSFx9t52ajdwnNvPPvkHU8uRdBRd6DfUfDXo/O0Q8NJaWOWy1QbNZL9dXMdbt892Wo2yRPe
lRxdV5sSBwBeRshQnf5SF1SUthh2baE6nZh+0YXUUW8eh421Hx6NHlLkUxx/jbJsia4r1q8u
kSQThySZbJx1VjqIyWlF1BAej69YNk+feCDONPMJYtjl3yewS7DFW7TXI8dsZTSsm4boNOn7
omR7IKqaigqo78h5xD0g1qxDULFL7gFqw5XrPhORRpj97yOU8buQ3aRHnOOm2zCbB2P5yLuS
h5dOMtxW2WkaBs/vp9ozqziHibxDI5jWLO2aHAyty9ON3h/zUeZfbu3cyZjteVQXmWTYBpHT
caJ1HSc6bSgLaw+1eGvWO06HX6UFmwyRnGQaiQ8mdB7LZSW6Naot/cvrERpwbchIQyJEpr3m
iJfMm6rnEW4zc91w0Y1SzLRO645jWZSMpK8ZNaLuMPIbw1ZGLREhXAJpMwpNvgLJEz6LTSE4
RkCbOIaEKi5DrJ4SMlgavYzk93m2ye00sB64RyyG6Ms2o4V4m3RnZlgmwvLqrNFnzM1Wz6kf
zbgPm+6ysa8Otmn6gMOZlptP03u9mx7VPMcyizLbciblXW4OO3WEzFmE006KgUecw+k1DM0Z
WO2kcx4vF8cf8OnimsuC2Oxnjelr3sjH8FsLj6ZrPFZA43cjmq4qeyu3mUPpqO69Pbfk53Gp
PpNoHr3gXiHDU+7w8Unz3BzFty1lmcsocVu63GPdIbcfa2ig7SW323nCBXFR1HEMxbajNRnB
vBfqZj3h/ewq4ybUPmMSxKI+63nN2kOldMfujssW2HjZRyFFlNGCIUch8mfJWmXf4i9NaNaf
vabaFwcafjxWHhflTX2Y8+XPFt2TKekuIsmUZvvlzfLk+4qE6SkfBpCRpud0pSlKUpSrHg6k
Yg/tdv1/lXybB0ZI7ivFE2Xcuyevp89vtT4p37VkUpSlKUpSlKVQk3D0Vdu/ZdqxBiuI2ict
lFFH3VVEX19O/b9euyKn0aacCQhEg78eKl6qSJ6fd3Vfn9+9ZFKUq0x5NqiKqL80WvkyDjYg
Cj2H3d09Nvu37f3/AA/D70pSlKUpVpjyaUe/f5LtXzaA0eIiBB3VV2Re3w/3/D/NftSlKUpS
lKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlUVURO67Vb1QV5G0VeSpun
Zdvz/D/D5pV9WoYKWyL3XvtV1KUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKVaf8pfX8E3W
oLc8xnQfGnimAMsQlt97xi93p95RVXheiSbW0AgW+yCqTnVJNt9wD02XfN1Cz1rD7Fa41tty
Xe/5LcPY+P25X+g1MmdF19eo/wASRpkGY77rjnEiQGSQAddVto45gq+IKN4gzs+flh11xNiz
HJ9v2q3PWt6TOceAWogRHJMhUFlpp83HScTmstgQFFadUupUpSlKUpSlKUpSlKUpSlKUpSlK
UpSlKUpSlKUpXyk8/JEre3JO6brsm+/z+H9/3L6V4C8T3jMznRj9triGB2/QMsjnu2F6wY5t
ljUP217YlW/ga7smkdW5FvcY4mSct0cVQFU39n5/g302tVrk265pasgx2eN5sFz6XmW40tGH
WFJxlVFHmTZkPtOByFVB4lbNp1AcD6YHYdRLY/NnaiZrar5Lko2DLNnsPsqFGAUXcumb8h0n
jUtiInlDi00gACo4TkvpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpVCIQbUzJBEU3VVXZE
StNleXYnheBS8mzLKbVj9ngK35q43SaESNH5GIh1HDIRHkRAKbqm6kid99q8K+IKLpdqv+2J
0E1otOnme5NYMYS4rfchs+H36TDIIweYs70dxhjhJZ844bguxlMHBNFMlb47+3cI1AwzUPHT
u+GZFDujDD6xZQsqovQpCAJnGkskiOR5A8x5suiLgehCK9kkgOtuboBJunqnoqfenwq5V2Sr
RdaPbgaFv3TZfX9dvzq+lUq3qtoSCpJuvonxWqoYqqJv6+m6etVIhBtSJdkRN1WrVdbQ1FST
dPVPy/zSguAZKIr3T1Tb0q+lKUpSlKUpSlKUpSlKUpSlKUpSlKVY9v5dVEuKp33/AF+vvrkO
nTaanan3bU+/J17fj98uVhw+KartB8o4cCbLcDvvKdkNS2we5kqRemICyT0oXczNdYpuN67t
6e4/pHmWb3QrQN5fcsT9qFiM0rpsiEgpUtlWiIhNRRR+s4PdNXOi8jeNkOOWLVjSmDrdow9b
G8ynWFubiOSvRyj+dYcbV9iLMLp9U7e6rn1rBjuPLmCNPttOBN9Osxteo2h2M6iWNuSxbMnt
Ea8QmZQCDwsyWheBDQVVOSCSIqIq99+69lqRvqYxSVvjy+CEuyKvy3+H69a4Po/rnqrqZeca
nytL8LjY9fWhuT0q252U24Qra+1JKBcThuQWCRiUUcUbRTR1EeTkCK28LfWsx1F0/wBOsWZv
moOb2LGLfIkJEalXm4NQmnHlEjRpCdUUU1ECVB9VQVX4UwvUbT7UjE3r9p3nNgym2R5BRXZl
luTU5gHhESJtTaIk5oJgvHffYh+aVhZ7njeMMQ7LZrYt7ym9cxs1nF7o9bpqPUkPO8S6ERnm
2rr6iXHm2AC666yy7pNNMx1ByjN8kx/PNLCxRvH0jRxuEe6LKgXZ94CdcGKRsMuuNtMrFQni
aBFddfaFF8upnIMgzS24vnmJWe4xpByMwu52SITAgQtPhBlTFV1VVFQOnDcFNkVeSjumyqqS
N1xHICkwaKSoij9vxT4p/jXCsp1s1Xj6w5Zi2nOlOGZLGxx9qBDK5Z4drmXi5HbvPnb2GDgG
HmEjKDm/V6ag6Jc9xfRrubStk6K80MkXvyXui7L6J8F9f76yaUpSlKUpSlKUpSlKUpSlKUpS
lKUpVjm3RVV22Tuu/wAq5F4cHAtHhtXTJ4y83plcH8QICXqO+TjCC21xxwfdN962PW94ibXj
zfJOIKKtBxvVHTzUbUjW3Uyeei2oDNzu1vbxHE7yzk0FjHljR2XVZl3WEFx5TWvOS5ZG0/Ge
FY6Nh5fmT4Oeo8qyey4PpVeM4yqb5O0Y/b37pcZKAbvQjtNqbxIgipFxECXiI9+ybb1GvD/i
98w7wbYNjmUxRg36BYYoXmGjgGMaaTQm+01wJW22RdVwQaa2abAQBpBaABSS6gnnoaL3f918
KwysrKOoWpu/SXWLejxKiIb5NAbigKKpKIoinx48g5cxgvh78O2n2gGjUe0YXhNrsN2nW+A1
fZER/ruTH40UGEU30aa6m3El5Iy2hmbjqtibp7zPM8AtOd4o3Zr3NvkZhqSMsSs1+nWh1XEE
hRFciPNGQe9v01JRVUQlTkiKl2F4HasCxV602Odf5LTz6ySO85FOvDyGoimyPTHXXED3U9xC
QUXkqCikW8e1AwnK3NT7FqZp9HtEzIcfgTbSFru0socObFmuxnH0WQ2y6bLouQ47gn03RJBd
BW0VwHmd7hiahyMWelahQbDAuD8gjZt9mluymIjCCKCBSXAbV8yJCPmjLKChoGxK31HIHqP4
VtHtT9acczfJ9NcKmz7XdvaN3dm45HlvXtpIEqIEd4zTdQBX2HR5c0RYraII7CQ9StWP2qx2
CFZ7LaosC3W6OESJFjNi02wyAogtgAoiCCIIpxTZO3pXGdKPD+MTX6968au6f4a3qfcLxIkR
blaJztwbhwjjRIrbbbjzDJiaMRAAiJD945Btq2EpxgcjwhZlYMu8Kz30fz/6WxrblWR21mY5
fTu7oxmrxL8qBSXHHHHESKUVQUyVVaNot1QwruVKUpSlKUpSlKUpSlKUpSlKUpSlKUqx3l5Y
uCKq7boieq/ZUFzTTaXessYyzDslmYtlMVgYqXRhluSzOYAlNuLNYc/nx0cUi902nw6jwtPN
I+6pwGXqT4jrLr9ZdMH9LdOLxcrrZrhdY91bzWZbmZLMF6Gy64cdbY8scjKcyQso8+gpzFXT
4oRSmzaY5hkmTw8i1lyaJcUhPtzYeL2iOjdlhvgSOMuum4ivzZDRquzpk2ypNsPDGaeaBwek
xwkc0N5dl+Kbrsu/4+vb8PRPiq5NKUpSlKtMeTSj37/Jdq+bQGjxEQIO6quyL2+H+/4f5r9q
UpSlKUpSlKUpSlKUpSlKUpSlKUpSqL6VynIf+VL09/6AZZ//AEMfrq9KUpSlKUpSlKoqoKbk
qIm+3ereo3sq8tkFN1VfRKqpiPrv8vRasWQyiKvUTtuvbuq+np8/VPT41cjzRByFwSTbfdF3
T03/AMKor7KNqauIgjvuX/NTZdl3X761c/LMftuc2jGZc9Uut96xQYjbJuOGDI8nXSQRXptB
u2JOHxBDdZBS5utiXLrv4xvDzj+qOQYhfswuttnYncI1tv70vFrozBtLshxG45SZZRkjssuE
qKDxuI2QqhISj3rs/UBS4oSKu2+yfL51xjHvGHoNlN5KFZLxlbytX1rGJL7mC3tmNDubj4MD
FkPnDFth3rOtgouEPEjFF23qeakapYZpNgzGR5tJubMCRcI9rArdZplzc8w+XBkFbitOGPM1
EBVRRFMwDfkYosWwfxQ6KaiLOXGMjupN2y/hi052fjdxtzUW6HyQYjhyI7Yg7zEW+JKio48w
2uzj7In1NXG0eRtSRCX0T9fcv5VfSlKUpSlKUpSlKUpSqEuwKq79k+Cb1yfInAT9qNp6fJOP
0Ayxey77/wDCFg/yrrHJOW3xqtKUpSlKUpSlYN9tbF8wufZZRywYuEZyK8USW5FfEDFRJW3m
1E2z2VdjAhJF2VFRURU/NHwPZZ4sc40LvuTYplGe39qdpFdFZuWRTH5kV7MAus4LcsNy4EoF
xiC0LnRXoIoij/1la/HWvEnimA6U5HcM18QuQynM2xm4363JjGQtJaoTUfjfYz/Nx5+aKmMI
yVxpGCInUiIvOS03neF7J9ZLfqPj1x8T87Xy2Yljukl7PIp14jZJEjM3IbnOfJx54BHk8Nqc
3B1SJRUWhbLrC2gwCx3PxU+2yx2PkGvsKVOTCpUxu9t5K+77KbjMBk70eOTgSHuF0egdRIhg
/wBNxwWSBg3FXZ6iF4ncW8RVo04wPVXWbLc/e01t93x5XnJ8LzlwHJW4rUybAF9xiM2traIX
VmqgrvykiEgzGvYem1on2T9u3rVc88t0o3MkxeyycDnTWVeaKzxGuFyYjP7EDIDNfYJyOqgR
E427xLkh15c8QuAakZz4q/E5HxnAtRroOZ3fDIFjsn0QmN2HLzgOstyhlTijCUdhpWy2eblR
gJNy6jg8Sr9C9ONUbXqbfMzgW/Hr9Z5WGZNKxia3eIaR1kPstsuDIZFCJSjuNSGTBxeKkKoq
JsqLXjHQO+ZDoefiD8SmZWrV1vE7Zm2RX0cK+h8iIlyg3KXBOPeGUktsKRttxZHUQyNWWdy2
Y3LregvFXqRieMXbTTS7IpN0GZmGWQ7nHG1WaZdJDceyvN3R1wI0ZozcRTixmFFP4EldbYxZ
NF81ae5rZmf2f/jaxGTAyCLkF0zW/wAiHZZFgnszngyCOEWzCkYmkd5yXlQRDihChCRIAqK1
7k0RtmW2rwhYDatQzku5ZbcagRb4UqX5p5ZwxmxkK47yNHD6iGiuci5LyXku9TylKUpSlKUp
SlKUpSlfGUpDAMh47im6ci4p+K/BPt/uWvz48SvjdzTSX9uLj2nFn8P8y/3WJaHcasBPX9Lc
F9K8vWxxt4CcjkAg2/DKPvzUVLmqmHAhr9BmjUjHfj7yb9i3T0T0X4p9vavvSlKUpSlKUpWF
erXHveIzbNLclgxPYOM6cSW5FfETRRVW3myFxs0RexgSEK7KKoqItQ7SbRjA9DtIAwDTKzS7
XjjDzj7Vtfusme20rncxaKS4ZACruXAVQOROFtualU3Fk/MKZrui7dvXv8/s+7/fX0VsVHbj
XyWOqgqEvLv8U9fnvttvv8fh29K5+WgenJeMJdeltl0+my25bStwW/TVZWJx28ssXq9BWVJe
orfBB6qdTbmqnU1l2S3XC5wJtxtMSXItb6yYTr7YmcVxW3Guo2Soqi4rTrjaqip7rppvsSou
WcZCUiIeSonufFRXf1RV9N9k/KsO12O32WK5FtFtiW+M7IelEzFaRsCeecN111RTZORuuOGa
om5kSkqqqrV1wstvvMAIl7tsWdHbkMSwakgLwA8y6LrLiISbcm3GwMS9UIRJO4otWpYrcWTR
749aoh3KHFciMS1aEnm2nSbN5sD2RREzZaIkTZCVsFVPcGsWZhuM3HMWsln4xanr1FJvoXJy
I2cpvpC+LSi6o8x4hLlImypxSQ8iKiGW+2ZZNpQBBAWxHiiCmyCieiIm3b1/Db7d6yKUpSlK
UpSlKUpSlKV8pDYuRFAk+KKi7IqoqLuipuipui7L+FeIPE5o9h2S/wCkMeGDLL6xMmybpGu7
LkfzBNsslaI5ToTgcOLiEkmSpFuaiSAAqm2/L26Cp5rjum6Ku+yenZN/uVVXfbv2r7bonrVv
VaQd1NE77d/Xf5ffRHWydUBLdR7L9i+u337VfSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUq
hEggpLvsnfsm9abLMqx/EdO5mR5FPSNAi8QUwbN5w3TNG2mmmwEjceN0gbBsBIzMhABIiRF5
jYNIZGaaM3W86nRpNpy/NZVtvk1mJJadcxp6GrTsCDHdUXANuG+0jvvcmXZDkpzpo3IJmpVp
Hml3y3BH4eXNRIuX4xICy5XFiAXlWbkkZh4ljKplvHcbkMvNqqqfTeAXEB0XAGcSDRYaqKmi
psSbIu/z227fL0/8K8p6wv3a+/tRIWFRcQ1RvsFuw2aOv0TzibZLZA89Pn+YmXBWZbRJ0Y9u
dVpWw2dMiadJTOLw9K4fYRxbTu0Y17cuV4W0W9i3+fuknzE6Z0gQOq+7siuOnxUiLZORKpbJ
W9pSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKpXzdcFY3uugKmm4807fP03SuRWNf3t+Idcyk
oRYdgVwlQceUvq3JN7aWZAuUk0XciZZA3IrSEoIRrLMmzBIrqdUbbJllGUVCT499lROyKvp3
X8ERPTttXKtUjTTTPE19huCluhwBh54Kl1DOxxxkutymG1/1kZ51xxRBUVxhyUiBIeGMg9YB
rmiI42myDx2RNhXf+JNvl2Rfx/CotiGluKYFnGU5LjrV3CdmE0bneDmXyXPB+QIIHMG33DFn
6sWw4tII8GWg2QWwQYFg8e3QP2t+pp2/FbpB9r4lj3mbquPyWYdylxXbijyrMVoWHXgZl28e
xkXBOCfyjRvuNKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpVrn8lV232TeuV6rXO65TeY+jGG
XWREumSNml9udtkE3Kxq1G08JTWzRUQZButKxHUl5C4pvCDoxXhToNrskCw43Ds1ltkW32u2
xgiQoMNoWWI7QCIttttgiCAigoiIibCiJtsnavJ2smPv5LrJqTkNszjPLXCgX/DcBRu25vdr
eEG4TpMUZ02LGYlDHFPJXe3K2piQdeM4pMkikT3rO02xm0YtFtEKTLcYgRwisuSpjst1UbFB
RXHXCJx0u3vEZERLupEqrXN9KdtMNRB0AlJxtcG3FMwRU+sJbJFCIy5GeNNl60V6Q22imKKc
d2IquPOjJIerETT7KgKiW224knf57Ki+lUbaIHE5ERbf85du/wCCff8AKvtSlKUpSlKUpSlK
UpSlKUpSlKUpSlKUpSlKoRCDamZIIim6qq7IlRzP84tOAaWP5PdGpcgBfjQ40aGAk/LkyX22
IzDfIhAScedbbQnCBsVNCMhBCJNPpJhN0w/B37hlr0N/McldC75VIhGXlHbgrDLJDHFRFRjN
tsNMtIQofTYBTU3CccOR5hbr7edJ7zaMUyVMevU2A8xbrv5QZfs+QQKjb/RNUFzgSoXAl4lt
svZVrikTwbYFYsdxhMWy/Oo15xS/xMhj3S45jdJ/mJIykenOnGKSMbqzG3Jjbpo0if1x1eKp
7q97AXERCLjzIUUk57oheuyLtvt3X4flUH1awe7ZZp01OxR+HEy7F3nLxiciU4SRGrgMd5hs
XwQS5MONSH2XUQeXTeJW1BwW3A3WA5jbM90/j5JaWZUdtX5cCTElNCL0SXGkHHlMGoKQKTT7
LraqBEBKCkBGKiSyelKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUqxwVJlRFVTfb0Xbt8ajGZa
a4JqLjbNpz/BrBksNh8ZjUa829mcy2+iEKOCDoEKGgkSckTfuveoiPhP8Lqe7/Rq0r2RVX/0
OgfH/wC19369Lv6J/hc/2a9K/wDqfA/7mn9E/wALn+zXpX/1Pgf9zT+if4XP9mvSv/qfA/7m
qH4T/C70l4+GvSzfbtth9v3/AA3ZqY4NpxgemmNuWXT3CLFjFuekFKciWeA1EZN5RQVdIWxF
FJREB3232FE9EqTUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUp
SlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSl
KUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKU
pSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpSlKUpS
lKVaZg20TjhIIim6qq7IiVzbP/Ebo7pfcbq1nGUSbexYYyybtcAs8yRb7cvT6osvy2mSYakG
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</binary>
 <binary id="_100.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAcMAAAB8AQMAAAAvo0mJAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUJCAcHw/bk0gAAA3dJREFUeJzt2UFM01AYB/ARjHrQAXKBBBgJXDx4ILsMialT
D5w4G5fpYAkk4opowkETunjSZFESYgLZLh48KEHjgYHWwIymXAhcFIxj65DEmUAZC7JNy6iv
r+1oR9d2zXAz2XeAt5bf3v+9PV671MDorIih6JJwto0t9N5t9y32mccXfggN7rC53gMbfaWS
ltRikoWVmkq/ZOQkebSyGDPEFFaSWkx5JahVyYxTvyS1mPJKUKuSGad+SWox5ZWgVsUcZ8TA
F8IfCggHDJXCX2WOGKpEMiY05xhunGTmJC00sMyhmChtgSRbZDyuLGXTQvl7R4eEaf9s6JeW
kc7xHDKAKKSlr4X8IX8OGRPastLW6PdZtMgIdrhPe84+B90Wp9Hhq2Bl8kDCcdLvDqX1YOyr
aVaiwfv2qZdoEEpGKuNvTho6xzCxDIMfO8wSJ5tCjzuMX6GMnpKkzUQ7kKvCK1YO2Kfw4aAD
yO1gP6Yiv316cMcRPYOsA2nrB/ImlEnnqiDJHHKZevHWa5uaC8aItuqGdWPNmBumtW2oyrXN
Du/l5wwpXUNJm2raRYqivTeeZsvImg9RkWGK4tNKJF9K0nOFuAdmCIvGduD/Z1Qqn0BlEskU
/LUH1xDNfSqVUIJlJ5IzVVBWkNstx6xmjzWA0G5OVh3In9zeFDkhlm5+kzLRdn/Qhb6iyJSw
b7GS2ykimc1NLLl9jZWz3u5hlJVcn1BytcmnNYnley5tJQnk1YFh0CcdEKXlKvYRyjXpDC1B
iZAb9lnShS4CKZ4hXjJKe9/3loYus89KIKr7UKSr1foIUfw8c8jENBoMYUrS4TTcJuo/WGpr
pGkT88a6sOKKHwr5E3jv59DkaJYEfV5XkxfwukTjs1Fp2i0g7YppgQzjvYn064msGbrUelF5
hoZW/ctAfpmckKblt1CFtD09ze1EnbOt9uxRXQWZlLOaOI7puAoy6Wm8wzWnR+4NzuAooudq
n/Yr9qksz1O60qa6wQyZ9EhQ+2ykf3NXk5fUf/fG6KwS+AagSTJyMo8q2N04WQSZR5VXwlHI
8kpQq1JdCfsmvTK9JUe1pKV35d5Pk/xlCRDNo1pkVtG7Ky7c5ZI9p0HeisueUxsnkKez+9Qy
zjS1cg6nJnXI/SbLw/nAiJa0edT/sicwcjKPKuBTL/HDLtjIPOwq3FOvv9wjDb3H9n+kAAAA
AElFTkSuQmCC</binary>
 <binary id="_101.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAUgAAAFBAQMAAAAv1aS4AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUJChAdOJNNUAAAAx9JREFUeJzt2r9rE2EYB/BQQesgRVw6KN38E6RbBwPqH+BS
EHQRpIiDQyY53ZyMIIgOxU0nh4ok6JJKBxEKDm5NjiuNP3CIKaiJciSvuffucve+9zzHV03a
0Dzv0Kbhw/veJenxzfu9gkJHYTTyVyE98qSfetyfSOnDsgvLNiw9WNZg6aCyr0zZZWXPkl9Y
6cNzdhN5Z/HuiRxZDtYL5VZj9Tkpw4/inNoOfh0aPFE/ubpGSkf/fJKa071Ez+nYJ7YMy+NH
z99XTUTGQ+T0yNzrp6O4IVKkSJH/Jdfjy86RrDSvS178dDcrzWvdJEoq19GSynXe9oVH8+9O
O6akcp3X+Xy9uvK4ZkqPlN+OVUuvl0xZo+WtaunVmikdevWVzOp2rtM5xNu5NjijpwuGtHOd
G75Kbd8Ljist7VzXi2R4Bmlp57pIvh38vWBKO9f1jPdoN/VRtHOdz76bZK6LZY35LOlc10rL
JUbqXPcGmTMewStfPHz5HCQ7rYuVNiR3vzbONLE5P7mdFri6+xCTO8V7xbOD93OC/t/3SuLX
T2UOR3FDpEiRIscm8evSOL7tjlYCu3CRBHbhIunBsgZLB5V2WuOlndZ4aac1XnZh2U7kg8WZ
q7MfWVkOEmcoN93K1rObTlbetnOde+pls1oiZDhSua7hvqjnSJUc52a9Uq9Sq2fkh9mZK/M/
kP1kb5CNc/Yq0zJ4AMly8IDaLczIeIjcS4n3HcYQKVKkSJEiRYoUKVLkBMiDdP8SLg/8/Uu8
tHdO+O/a9s6Ji9y/FK/ByPehHTZiPnL/km7EviN7LLoRo1YPpZesrhsxXqrkjJZhqRuxjUnd
LZwOmddJ7W93ht9RYIzxSLLTJyXZ6dOS6vQZSXT6zOrZTp+WVKdPS6rT56TKdPqMJDp9RkYj
7PQRCc9JddCk7LfhOQEZdfqAjDp9QEadvgfMyXf6mdV1p38DOaOg0+/P7c//5kjk+O9fwq+0
1nH/tfRhKY1YbgYzlh3K33Aj9jMngw07KZ3rKEnnuhabFe1cx+dPlRynznXriGRzXUbqXAfJ
eIicHvmPjdgfodZoEkPTUmwAAAAASUVORK5CYII=</binary>
 <binary id="_102.png" content-type="image/png">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</binary>
 <binary id="_103.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAHIAAADTAQMAAABnU9V1AAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUJDQoGB5Ro4gAAAjVJREFUeJzV1TFvEzEUB/CrOrAUgtSlWyfUFcFaKZFgZeE7
sLGgrqD7BkwoAlHuPoozMVX0I1gRUtg4pAyO5LPd88X2vffPJdcTC6Sqop/ks9//XWxnjn0W
WZ/rY+51nTNXTjDL5o9aNCOoc6eobTMjWFObYZsBH3we10NjvY15HgF5b6Efa8v7VR9xOxjv
YD4H6+1agfWAzUjbf9w79YefbLL5yqxdCf58+e77lPj6y5NPJenvdXFRnlN/uyhK8j74+Mqd
XJ7+mJD3WbP10MJtcuop5MkPO7bjvjb/mcfmG+rXzn5DywEP7b+h/fi3+y0GurfFONsH4Mlh
u7E+B5fjHG+k6J81twwN6N5vyZw3ZzSxjW+0+/2pzQvu+hezptatz46YV6+ecz98yp5ffXiW
0/lXb5g3x6cZqU+1dyStV7M8EvIK5lvL+7H8w/v1+9Hh/kmYD+fH9cHYXxt3CMlLreOO2WMV
d0xnS12BpQs7Yo9F+KeWxDm3DWvsswk1MevOGqzSoH5XaRHitqitJVikEP3OUxN6HQ6bCqyi
DTgcbnqfw2FowDa6Am/jtGX1WgQLsAzOudPlUPU7XTYKrLfW4Hi2+4F9jneDX4i5KcxbgkWy
6HWeLMGVd4oTbDqrPuvOGmy8Fbgrv1kqeEns49zEQMFF3tnHKWaTx1MfKPr1/KX/lo390OLq
44nbuo1TXM3ft4GCb9bzt8FtnOVycuafU8Ep0CLTYEVtdl1RW7CbZYuMfmZ3Bbiuy7uUvIsA
AAAASUVORK5CYII=</binary>
 <binary id="_104.png" content-type="image/png">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
AAAAAElFTkSuQmCC</binary>
 <binary id="_105.png" content-type="image/png">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</binary>
 <binary id="_106.png" content-type="image/png">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</binary>
 <binary id="_107.png" content-type="image/png">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
lKMuaVTJCwAkAKEaA3g5DxIAs3lxMXWpkheAuf5rqmvHgwRALV5ak7tUyQugeBHztCPPmwUQ
sfi8pkxV8hJoFnBSZR355p2/uoD4tKnXUAWvAINHA7gTn9u8ihXqUAWvgJ9hHg3gNnydQFKb
V8Ywhyp4BRj7N2gAt+HrBJDYPAMYVkt+qiJvoVfg05vyLwcLej2d+2fPVkt+V80953oKvqsy
MZgwVtPJycxWS54stNlDdVVZDias1XR2WNjqYCPT/j9Rp6s3RGDCXE2niVpBInWwkdcBLzsu
1dXRprviOuCZpQ420nrApqp2VR1Y8OrlRPUxNFIHG+VaVTacqFenk4xQ2Q2T2oPsTA949TEy
SwvVDUIt+UwnrImstlwYS74sVvF0XKiWqY+h6RVQBxv6lWjBHyt+oVVa55vyiEiAqvcXKVBt
vlJfa8+rhD8qVO8QJht70+SvNB8pPjH5LcxvNXzayv5NZb/iC8gnrfgEtx/wFyE+yYjyn+Zn
2n+7jf/+pB3WV/6bAbXk9YcxRH1iNdGPEzBhZfUDI7bU9eO3zfiRNRf6RkgdbBRrjl8eqfxx
tWL+4CcqYWU6YekvVBYgf+ntvLOZrYr8GaliOmHqL2TgN3B6OzHr2ar9/U83+Zz/nP9/8r9c
k//Benxhbmx05YsvHt549bkX3v7wBXL2pW/+9LnO/O++e2vv9b398z063h/vPenK8wdb38kf
vXdz8ttovP/yNx51bv/B1tfyj36enP+aj/fzvY+69v/Wwdath08+3b+Q9u93tZ/vvvyVG2//
4u8/Fv232b3/kAhfDv4D2FLWJJ5ATz8AAAAASUVORK5CYII=</binary>
 <binary id="img_4.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAIgAAAAcBAMAAABIY+o0AAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AULEhwR
Jax0NAAAAU1JREFUeJy9k81twzAMhbkBR+0InsDoCB2hC/RngLpIj+2lHiCH8NQCiY1XkZIY
qUAtownMCAkNPn8iXyTCFYI8m3cpmcbmW64FXivI0bP7JuRYpwoh0rW3xkKCp7/fFuKwTCsU
EuB0iBCxnwfElDEs9MAQTlpWNaadQ0Khd8jHMgRJG9P5LkP06SYWwvpehHDSii2gKyHsdMEb
mTlkH5AICZcQ9v7ti6oCzCxxGzXCIyEz4n4RQoQSci4kZe6dJdQ4TR9LeXewDxgh/BtSjMOC
EiJYhHQO+SpdDJAwC3MF6TJEzGQ7bFbonf7uvYvaosbmfZM3/Xnm+TYbqzHYedTspYSw/jOU
r0d6dbBjbszpubw7e88e0QrXMk7jxReQ/QLGmMecHJqQrA3TfVaQ/0Ty+TJIihUQbio26mTF
Nm2JNBVbQdq+buXJirgK5AeMlOzlbqVKugAAAABJRU5ErkJggg==</binary>
 <binary id="img_5.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAIUAAAAcBAMAAAC9nWGEAAAAMFBMVEUAAAAREREiIiIzMzNE
RERVVVVmZmZ3d3eIiIiZmZmqqqq7u7vMzMzd3d3u7u7///97EBgKAAAAB3RJTUUH3AULEhwX
zM/RAQAAAUJJREFUeJzNk91twkAMgG8Dj9oROgGzsEBpB2il9LFIoAzAQ/0EqIWa8y9OpXCI
VKiXKHGSz985zqXQ5IElwmNnwaFvZa0iYjY5viKatxzzQSiOUnjfkIT1xvNospI/L04KKw6s
d4ieSEOgt2EiDsJKfndOErPuqJezcCxH61By358dy3DwVA8MAe+7Cw4mt0ESs8kB+gT5+r3I
6xbeUI7ZgUFKLA6QfNCmQWoA8uBEtFtKYpDJYWLPDgcA1md1RnCHzx1MOOC3I70LT120SCfH
HY/xZBt1pC05dkECs7rG5HrmPaGP9BWsJTatkvxtTcqs9ZSHrBYJX7NDWoJehxwPnZFF2PS/
bCJa0OUha92asZj6z+H5n9Nx7D34bDnWdgZhk+OGocnTHHStA5vAXerwpTGpjn/iaLb0Xv34
gzqucJwA/X7ZNa+zSn0AAAAASUVORK5CYII=</binary>
 <binary id="_108.png" content-type="image/png">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</binary>
 <binary id="_109.png" content-type="image/png">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
AElFTkSuQmCC</binary>
 <binary id="_110.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAdsAAACdAQMAAADGwkCyAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUMESoNJyA/7gAAAZlJREFUeJzt2DtOw0AQBmBHFKEIisQBYjraXADccgu4QKRQ
pYCwKbkFNQ3UELCPkAMASSREGRwphS35kSCncSSPx9pfkbViVlPup7FnZ6dYa62/5pahOIq4
Pd8+iYOEwx/BfrB/zuHXGxL/Tjn8MqYzdzg8pjGfmcVeFmo38jjNItmJv2ofcfhzQOOEw7OA
xNsOK8O+T+LthjKcLcF5HFoFq5m386Idlsn/LFiwYMEyAPXxqgqeFGP32OZxeDEsxG+HbeUp
Bi9Pzopxq62mXOZll8YLXey2bLXicfE/V8Ihgb2Ww3923CXOeaT4gqUNAlsOf1SxRWO2SUhs
6K2SAWgYHiHYrS3z1z/EULUNxVCTGHQlZYbtE6cHuji8T9JIFwenQ/3MwfNwPTAPRxB+Aqod
PyK4geAQwOsm0J7mXkkZgIL1cYDgCYIfAHxnA/jWAXBfAfgKwX3knK8R3EPwpZEzLEVwguAI
wJVe4ghc6SWOwu8/PoAXdWF3MasJez0PwCMF4I4D4CovcWVDX3A1XPsAFCy4DGstDG8AAemL
qA80wxgAAAAASUVORK5CYII=</binary>
 <binary id="_111.png" content-type="image/png">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</binary>
 <binary id="_112.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAYcAAAD0AQMAAABKEXjmAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUMEiIZ92XfwgAABHdJREFUeJztmr1uE0EQx89ycVQ4JQWSRcULUHOiS0UegALJ
FHSkQUCVpQodj4CfIERCwlAQXRA9KUGAsV/AH0lk+2Lf3nK272P29uZuJlYsEHaTQ7pf5us/
s+MllmJ+AmsFwrKsavz80rIq5YRQahY/u0rJDfFvEb4QEzciAodE2GLoxES1kOha0UdI5cXP
DsWGJcaJVzSiBryySXEoELmgEJeqR2KDTCRxkIlTtlfBGmzw4+DnSkFiQCE84FVQoxAjkRLy
IYkAXsldCjEFNoLmFSmxmRI+u4KSlF1YD5+UXVhzmg3oFS0Ovg2YXXlCIc5gBd2rUcmEl91w
tp+L/Mj92njxapawtQpCIuhcLN6IiXS2w46CXgUdlWvD0jpKCUD8bjSuNXYMoqbn6hAQ7daP
g9YHg9A7SvPq153Op6evskS25iBy2T7rHL1zcwgPya5st34emV4VVNC73nh8o7Hji0IC2pgN
FPhoxHNAKAoxtNldO1mloxSpo77Djqob2s3J1bdi7c7cYqJnaFcVE92Kod0cogvi6PUM7eYQ
mBIj7c5fULgSYa5w7WJnbaRdaXqFKTHSrucUElBXuBJhHHAy4ISWK9IUhQRN7Vg9aATMLq5d
SMAKItoNZ3tChHt76lUtJBLDGmEDogoIK9Fu7FU62xXY2+XAj5/r8dwVx+G/7NRGJT1xwr09
jSN8jrS78MrbS4g62MJt4FU11m4Ux5uYkPrenp7OTqzdiOhj/eGa2l1GPiboSlfilKArGoHr
ymdvfRQiUmKUKwoRKTHMM51Y/mDYiDYAk7gQCLFUojQJuDNoxFKJs2IiAJt+pESvbhDaBrAL
CahEH5uiu4YScwi478LJoOsKEhLJLk6MXa4StS0cnaJY5HC244TWH4eGdgOn0Ia+iy60K4vj
0HeG5asmgWVXn6KYrjQb2gbgg9me3mU4edurQdhgJla17OpT1Mdme452M3GEsz09PywnZ3v1
MrkKZ3vStdpsR5UoQa4ydzK4drGu1T+UrsUJrGtxAutamg3abJ+wz48Vu5Z2RiEdhRPYdzWc
GOFenZ80ywhJIlbLFfE8Z9dcu78iqX3EVjvtZgKrIE3t/E3mHNmQcYJfD9qNF2qjXUrM72Tg
nlgpJ8DePrchcSKd7fDeh5DdcLZrJ2eznKhzZ6LE70sQIrtTd9i6ItnQvhvw+5zUg/zzAxL4
jTAWB/H8ADZOSQTsjz77jCISwKs+u2u77AoO1vzNCydWq+DfQ/Dj4OfqNZvosL1y2ZGvg+DH
0V2Ddv9bgvg3E4BAfytOTNdATASbcLnEgE90uMSXOpeYiQ2xITbEhliJSK7T0EMgSyRHTfmR
sCEuRQwdLrH8fwEWwfZqdrEveIT37L3LtPGx7zCJ1ohiYwoJkleAGL64XycQY6PmgSgmvhpE
t4S4myV8q5gYBiZR/KkZhDwu8cokfDZR/P5qxPD21vZnh0PMHrTaPcEiHu3ffMLyam7jLYuY
hMQBy6vhra3te6zIo/34SuuxIYgE43S+xN/Q/wFiVWHlSayDLQAAAABJRU5ErkJggg==</binary>
 <binary id="_113.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAMMAAADAAQMAAACDJUVHAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUMEi0JbUrTaQAAA6RJREFUeJzF2LFu2zAQAFAVHTLmE/QJRadmqn4l/9ChKVqY
MDxk9Cf4MzoyRQaPHjs1dJrBSwsayEAHFMmSd0dSisUUIYJWGWT6ySfqKN3ZaVxh2zY1crfG
Vxe4Uzi0Z9vmB8eXHxnsdzg0388bs8KDSRQNg8ix0PCrFzUWGr47b/S0+GiqKL+nz+PlW0sX
gO/c4bA/q8vO/xcLe60kXqLtEWQUpSSmxTo2FqmkJuFjEVIaEjEWLqVlKLuxMCExjHV6JD6G
xDDWmZEYH85JFDsSHUSh4LSjKMekeyBZDUUGoTNi1CjChjFDUUPhIBxFD4WBbFDMQMJFSAzj
h5AMEoOiUSAqifZ/EsOEociiUCyJzBKuPww7FJVFkAiUhyzcYT6HEVEYicJ3QzJQbIgjYY4o
PIqJ0pNsougoPgwtConCOUAYWkgSmUQ4WnwSgbODaafl2zaHNkyF5N75ISRjHkSxtMaGRLiF
l+5nXn27OXRh/ytI393iKeE2O0HZM5CrgVz2IAd2DcLgAkBeo+y7tRc2d0nsqz7cBG7berHs
JIu7QulRWkwUyB6fIne68zLrBtLPUNYhO3RPUPV6j7t7SfUgS9pIRIXwCmFJbIf7L74qr0di
6IDP2wZaRBYqVe7TtgktIj4AFDhsMy9yLJwOwOpvKkQXzzOQA836re+ALT1+kzkoi3xREZNi
x3JDyU71IAmflYQxNhSWpHecT4svz5uBWJdEOaGmxfeAYV8wWVZOmmnxT/+wL+gkUGq6KTFh
IKZEO6y1g1pFsgsfU1Miggz6gkzCwyT6KWGpaaX6hkKFlx/LA4pIwqMoPNfuWGgWOgmLInDm
5lg6FHsklOXcF9IbJr5YPRZcTaxbIOlQvAN07gtJNlFiX9BR4LrCgeaxsCi+ZEJfwG+gc5oJ
9VroCwsSk+UG+8Ic3li4DyghKPWFBcmbLNQXUK5tS8KDQF+4ROlPs2yxLyxhvD6ckPi12Kfq
D9Jm6U9BYFXcbs9IwkpBX4hySwCJhb4Qv8qth6Ll1PdEzOPzxPxVYrm/SwKrcbFtKPf0xTGK
/XjexHK/yeHCZXiJZVgdCx/OFTZeIaJ4HhIq926ZReKvHHe8wcefKbpCTIXYJ2XyDolP/fOE
V4goiqwQVSG6QkyF2ApxrEJ4UUSFyApRFaIrxJSFl8S284L07aIgh6KUP2NPr0u/0UONn5Zl
UTa7kuzKUsqBU0X5Z/+nuCuKKMqmKKoo+kWlfJ7lEzn4A+/C6lL91zcoAAAAAElFTkSuQmCC
</binary>
 <binary id="_114.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAY0AAACSAQMAAACDngRoAAAABlBMVEUAAAD///+l2Z/dAAAA
B3RJTUUH3AUNDQIvAp3t0QAAA9dJREFUeJzlmL9y1DAQxv0mPIpfh44O0ukRKCiAgnEZ3uCK
TEYtMymuoKC4YVQkTApIbiaXyZH4bJHYlna/1R/LKdLg4kYr+yfvJ+2u5Kvs0utv9XLITnY3
s0gru80sspfdOo+cd9tb2X3cGnC2r6n9rbKbbnsjkY+t+c3tjr32a/XrpDd3gjhbddrwjpaQ
s6Pq+6o319KvdxJRdO+osse9uZKOven0htsPhNjXlf1g63BdenXJ7fua2p9eMGD+K6SmphmQ
OnzmHqyetfWArEMEFhIGUAMSLL61r8Di+TQih4AQPcyNfpJfS+QcTU3NbkICMehXr6jdJiqM
8Ktj7f2ESDHCLz7i1i1lnfPr8TG6jENQjHxpE0NQjPDLKtbWDsFxG7DwpvJhWfNH+KgWy29P
kczFSL94vHWEcDHCL6jpLSHMX+kXOM0Q1i/94snyFNMeITHSL8i2LUO8mMAv2HwMQ7wY6RdG
hublwg0u/cIdTXGkSfjVQwcg04IFdYAnyzB7hEwT814iMEYHyOhA4BckyxBurFo2Ub9wOvaI
XEb9gmQZXjlbkzGTTAmCZ5UiBIuzLkEMWKoEqbkx5MEcAskyRgJHDuo0KOgQLuNccKRVp70W
CC6tRA4rtcFBrQiXMdsY8vDWhkgTDsAdu31EpGMKLCORG3WJ+RQUdC2RyCWOtqoAwXApQgxY
47rOIDVYXQGC4TIpk4gGC08yU92UyDryjL+2UQRjShwhTBTBtUM3EwjMkYwFHUe4LzJIVRzZ
JdrWT3mAcDGYLO6l4VLW1GzwTptCmBhViJAAefrZpxB6UH4HblMIiRHJ4jIhgqzFI/7SScSL
qcUNlUScmF7eSCNudJEsfogYMomRX8Eu4mLIDkh/uTmPIZMYLbrdW6Plon76kcnigzSKDC4F
Fd3kkJ3/KUYO3A9/6RwyiGlkp8oiaxskCwVDHNlFPrb8dMSRQ+RPE99R/vX6DMSHXAqRGckm
PYX8CHrMHKLTPeWImkNWy5Hge5YqQfEkUy4UIxQNSUTWFyoeSUTmMaVP2rEGTVOAiJApQYQY
XYAIMWRlJrmBAaiZQUAMq2oZBMSwvM4gIKYMATFs58ghXAyrnTmEizFlCBejyxAuhtFZhIkp
RUgM39CzCInhW1o+kRvX4EU9j3gx/AyQR7wYvgvOnPnVYsSLMeWIE6PLESdGlSOTGDiazRXY
ZviFw8kcMoqB7XkOuV+OjGLgADi7WTRPP3AEKvvvwixCBjF6ETKIUYuQRzGHpYi113guL0HE
wbQAufiyGLn5uRi5ewayQbsAuTpZjPz5vBiR13OQf0X1DxXvEe0IAAAAAElFTkSuQmCC
</binary>
</FictionBook>
