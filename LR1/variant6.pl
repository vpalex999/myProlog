/*
Вариант 6
1. Напишите предикат p(+V,+X,-L) - истинный тогда и только тогда,
когда список L получается из списка V после удаления всех вхождений X на всех уровнях,
например, p([1, [2, 3, [1]], [3, 1]], 1, [[2, 3, []], [3]]) - истина.

p([1, [2, 3, [1]], [3, 1]],1,L).
L = [[2, 3, []], [3]].

p([], 1, L).
L = [].

p([1,2],1,L).
L = [2].

p([1,2,1],1,L).
L = [2]

p([2,[1],2],1,L).
L = [2,[],2].

p([2,[1,2],2],1,L).
L = [2,[2],2].

p([2,[2,[1,2]],3],1,L).
L = [2,[2,[2]],3].

*/

p([],_,[]).

p(V,X,L):-
    p(V,X,[],L1),   % расширяем с накапливающим параметром
    реверс(L1,L).   % реверс результирующего списка

p([],_,L,L).

p([X|V],X,L1,L):-   % если голова - совпалает с Х
    p(V,X,L1,L).

p([H|V],X,L1,L):-   % если голова - список
    is_list(H),
    p(H,X,[],L2),
    реверс(L2,L3),  % реверс подсписка
    p(V,X,[L3|L1],L).

p([H|V],X,L1,L):-   % если голова не совпадает с Х
    p(V,X,[H|L1],L).


% вспомогательная функция - реверс списка.
реверс([],[]).

реверс(L1,L):-
    реверс(L1,[],L).

реверс([],L,L).

реверс([H|L1],L2,L):-
    реверс(L1, [H|L2],L).



/*
2. Напишите обобщение предиката member,
когда ищется элемент на всех уровнях в списке.

тест:

p([],1).
false.

p([2],1).
false

p([2,[3]],1).
false.

p([1],1).
true.

p([2,1],1).
true.

p([2,[1]],1).
true

*/

p2([X|_],X).    % голова списка унифицируется с Х

p2([H|_],X):-   % если голова - список, уходим в подцикл
    is_list(H),
    p2(H,X).

p2([_|T], X):-  % если голова не унифицируется, уходим в цикл
    p2(T,X).

